{
'id': 'bugs.core_5330',
'qmid': None,
'tracker_id': 'CORE-5330',
'title': "Trace session leads FB 4.0 to hang after 2nd launch of trivial .sql script. Neither attach to any database nor regular restart of FB service can be done.",
'description':
 """
   Ticket issue was reproduced on trivial trace config with single line ("enabled = true").
   We prepare such config, launch trace session in async mode and run THREE times isql with logging its output.
   Then we stop trace session and open isql log - it should contain three 'packets' of table records.
   If FB becomes unavaliable, this (and all subsequent) test will not finish at all.

   Checked on 4.0.0.331 (SS, SC) - works fine.
 """,
'min_versions': '4.0',
'versions': [
{
 'firebird_version': '4.0',
 'platform': 'All',
 'test_type': 'Python',
 'init_script':
  """
  """,
 'test_script':
  """\
import os
import time
import subprocess
from subprocess import Popen

os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password

db_conn.close()

# Obtain engine version:

fbb='' # 'C:/MIX/firebird/fb40sc/' # '/opt/fb40ss/bin/'

txt30 = '''database =
{
  enabled = true
}
'''

f_trccfg=open( os.path.join(context['temp_directory'],'tmp_trace_5330.cfg'), 'w')
f_trccfg.write(txt30)
f_trccfg.close()

# Starting trace session in new child process (async.):
#######################################################

f_trclog=open( os.path.join(context['temp_directory'],'tmp_trace_5330.log'), 'w')
f_trcerr=open( os.path.join(context['temp_directory'],'tmp_trace_5330.err'), 'w')


p_trace=Popen([fbb+"fbsvcmgr", "localhost:service_mgr",
               "action_trace_start",
                "trc_cfg", f_trccfg.name],
                stdout=f_trclog, 
                stderr=f_trcerr
             )

# Wait! Trace session is initialized not instantly!
time.sleep(2)

sql='''recreate table ttt(id int generated by default as identity, x int, y int);
commit;

set term ^;
execute block as
    declare s varchar(200) = 'insert into ttt(x, y) values(?, ?)';
    declare n int = 3;
begin
    while (n>0) do
    begin
      execute statement (s) (:n, :n * 2);
      n = n - 1;
    end
end
^
set term ;^
commit;
set list on;
select * from ttt;
'''

f_isql_cmd=open( os.path.join(context['temp_directory'],'tmp_isql_5330.sql'), 'w')
f_isql_cmd.write(sql)
f_isql_cmd.close()

f_isql_log=open( os.path.join(context['temp_directory'],'tmp_isql_5330.log'), 'w')
f_isql_err=open( os.path.join(context['temp_directory'],'tmp_isql_5330.err'), 'w')

for i in range(3,0,-1):
    subprocess.call(['isql', dsn, '-i', f_isql_cmd.name], stdout=f_isql_log, stderr=subprocess.STDOUT)
    if i > 1:
        time.sleep(1)
f_isql_log.close()
f_isql_err.close()


#####################################################
# Getting ID of launched trace session and STOP it:

# Save active trace session info into file for further parsing it and obtain session_id back (for stop):
f_trclst=open( os.path.join(context['temp_directory'],'tmp_trace_5330.lst'), 'w')
subprocess.call([fbb+"fbsvcmgr", "localhost:service_mgr",
                 "action_trace_list"],
                 stdout=f_trclst, 
                 stderr=subprocess.STDOUT
               )
f_trclst.close()

trcssn=0
with open( f_trclst.name,'r') as f:
    for line in f:
        i=1
        if 'Session ID' in line:
            for word in line.split():
                if i==3:
                    trcssn=word
                i=i+1
            break
f.close()

# Result: `trcssn` is ID of active trace session. Now we have to terminate it:
f_trclst=open(f_trclst.name,'a')
f_trclst.seek(0,2)
subprocess.call([fbb+"fbsvcmgr", "localhost:service_mgr",
                 "action_trace_stop",
                 "trc_id",trcssn],
                 stdout=f_trclst, stderr=subprocess.STDOUT
               )
f_trclst.close()

# do NOT remove this delay: trase session can not be stopped immediatelly:
time.sleep(2)

# Terminate child process of launched trace session (though it should already be killed):
p_trace.terminate()
f_trclog.close()
f_trcerr.close()

# STDERR for ISQL (that created DB) and trace session - they both must be EMPTY:
#################
f_list=[f_isql_err, f_trcerr]
for i in range(len(f_list)):
   f_name=f_list[i].name
   if os.path.getsize(f_name) > 0:
       with open( f_name,'r') as f:
           for line in f:
               print("Unexpected STDERR, file "+f_name+": "+line)
       f.close()

# STDLOG of isql:
#################
with open(f_isql_log.name,'r') as f:
    for line in f:
        if line.split():
            print(line)

#####################################################################
# Cleanup:
time.sleep(1)

f_list=[f_isql_cmd, f_isql_log, f_isql_err, f_trccfg, f_trclst, f_trcerr, f_trclog]
for i in range(len(f_list)):
    if os.path.isfile(f_list[i].name):
        os.remove(f_list[i].name)
  """,
 'expected_stdout': 
  """
    ID                              1
    X                               3
    Y                               6

    ID                              2
    X                               2
    Y                               4

    ID                              3
    X                               1
    Y                               2

    ID                              1
    X                               3
    Y                               6

    ID                              2
    X                               2
    Y                               4

    ID                              3
    X                               1
    Y                               2

    ID                              1
    X                               3
    Y                               6

    ID                              2
    X                               2
    Y                               4

    ID                              3
    X                               1
    Y                               2
  """,
 'expected_stderr': 
  """
  """
}
]
}
