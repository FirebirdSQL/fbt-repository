{
'id': 'bugs.core_4135',
'qmid': None,
'tracker_id': 'CORE-4135',
'title': "In SS sweep blocks establishment of concurrent attachments",
'description':
 """
   We create DB-level trigger in order to log attachments info. 
   Also, we create table with long-key indexed fields (use varchar(100)) for sweep take
   not less than 5-7 seconds.
   Then we insert data into this table and create indices on its fields.

   After this we delete just inserted rows and make commit thus providing lot of job to GC.

   When we call on next step sweep, it will take more than 15-20 seconds (at least on host
   with common PC characteristics: P-IV 3.0 GHz, SATA, and with FB DefaultDBCachePage =2048).
   We launch SWEEP by async. call of FBSVCMGR and save current timestamp in 't1' variable.
   We allow sweep to work about 1 second and then run loop with launching ISQL attachments,
   all of them - also in async. mode.
   Each ISQL connect will add one row to the log-table ('mon_attachments') by ON-CONNECT 
   trigger - and we'll query later its data: how many ISQL did establish connections while
   sweep worked.
   After loop we wait several seconds in order to be sure that all ISQL are loaded.
   Then we save new value of current timestamp in 't2' variable.
   After this we call FBSVCMGR with arguments to make SHUTDOWN of database, thus killing all
   existing attachments (SWEEP will be interrupted in that case). This is done in SYNC mode,
   Then we return database to ONLINE state and make single ISQL connect with '-nod' switch.
   This (last) attachment to database will query data of Log table 'mon_attachments' and check
   that number of ISQL sessions which ACTUALLY etsablished attachment is equal to 'planned'
   number, i.e. which we have launched in the loop.

   Checked 07-jun-2016 on:
   3.0.0.32527, SS/SC/CS.
   4.0.0.238, SS/SC/CS.

   WARNING. 07-JUN-2016: delay for making connection of every launched ISQL was increased 
   from 3 to 5 seconds because of 4.0 Classic.

   On any architecture this test run about 22 seconds.
 """,
'min_versions': '3.0',
'versions': [
{
 'firebird_version': '3.0',
 'platform': 'All',
 'test_type': 'Python',
 'test_script': 
  """
import os
import sys
import subprocess
from subprocess import Popen
import zipfile
import time
import datetime
from datetime import datetime

os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password

db_conn.close()

#zf = zipfile.ZipFile( os.path.join(context['files_location'],'core_4135.zip') )
#zf.extractall( context['temp_directory'] )
#zf.close()

# Result: file tmp_core_4135.fdb is extracted into context['temp_directory']
db_file="$(DATABASE_LOCATION)bugs.core_4135.fdb"

sql_ddl='''\
    recreate table mon_attach_data (mon_attachment_id bigint,
            mon_server_pid integer,
            mon_state smallint,
            mon_attachment_name varchar(255) character set unicode_fss,
            mon_user char(31) character set unicode_fss,
            mon_role char(31) character set unicode_fss,
            mon_remote_protocol varchar(10) character set ascii,
            mon_remote_address varchar(255) character set ascii,
            mon_remote_pid integer,
            mon_character_set_id smallint,
            mon_timestamp timestamp,
            mon_garbage_collection smallint,
            mon_remote_process varchar(255) character set unicode_fss,
            mon_stat_id integer,
            mon_client_version varchar(255) character set ascii,
            mon_remote_version varchar(255) character set ascii,
            mon_remote_host varchar(255) character set unicode_fss,
            mon_remote_os_user varchar(255) character set unicode_fss,
            mon_auth_method varchar(255) character set ascii,
            mon_system_flag smallint);

    recreate table test (s01 varchar(100),
            s02 varchar(100),
            s03 varchar(100));
    set term ^;

    create trigger trg_connect 
    active on connect position 0 
    as
    begin
        IN AUTONOMOUS TRANSACTION DO
        insert into mon_attach_data (
          mon_attachment_id
          ,mon_server_pid
          ,mon_state
          ,mon_attachment_name
          ,mon_user
          ,mon_role
          ,mon_remote_protocol
          ,mon_remote_address
          ,mon_remote_pid
          ,mon_character_set_id
          ,mon_timestamp
          ,mon_garbage_collection
          ,mon_remote_process
          ,mon_stat_id
          ,mon_client_version
          ,mon_remote_version
          ,mon_remote_host
          ,mon_remote_os_user
          ,mon_auth_method
          ,mon_system_flag
        ) 
        select
          mon$attachment_id        
          ,mon$server_pid          
          ,mon$state               
          ,mon$attachment_name     
          ,mon$user                
          ,mon$role                
          ,mon$remote_protocol     
          ,mon$remote_address      
          ,mon$remote_pid          
          ,mon$character_set_id    
          ,mon$timestamp           
          ,mon$garbage_collection  
          ,mon$remote_process      
          ,mon$stat_id             
          ,mon$client_version      
          ,mon$remote_version      
          ,mon$remote_host         
          ,mon$remote_os_user      
          ,mon$auth_method         
          ,mon$system_flag         
        from mon$attachments
        where mon$attachment_id = current_connection;
    end ^
    set term ;^
    commit work;
'''

sql_ddl_cmd=open( os.path.join(context['temp_directory'],'tmp_ddl_4135.sql'), 'w')
sql_ddl_cmd.write(sql_ddl)
sql_ddl_cmd.close()

sql_ddl_log=open( os.path.join(context['temp_directory'],'tmp_ddl_4135.log'), 'w')
subprocess.call( ["isql", dsn, "-i", sql_ddl_cmd.name],
                 stdout=sql_ddl_log, 
                 stderr=subprocess.STDOUT
               )
sql_ddl_log.close()

#--------------------------------------------------

sql_data='''\
set echo on;
set term ^;
execute block as
  declare n int = 20000; -- 4.0 Classic: cant establish required ISQL attachments!
begin
  while (n>0) do
    insert into test(s01, s02, s03)
    values( rpad('', 100, uuid_to_char(gen_uuid()) ),
            rpad('', 100, uuid_to_char(gen_uuid()) ),
            rpad('', 100, uuid_to_char(gen_uuid()) )
          ) returning :n-1 into n;
end^
set term ;^
commit;
create index test_a on test(s01,s02,s03);
create index test_b on test(s02,s03,s01);
create index test_c on test(s03,s02,s01);
create index test_d on test(s01,s03,s02);
create index test_e on test(s02,s01,s03);
create index test_f on test(s03,s01,s02);
commit;
set count on;
delete from test;
delete from connects_log;
commit;
'''

sql_data_cmd=open( os.path.join(context['temp_directory'],'tmp_data_4135.sql'), 'w')
sql_data_cmd.write(sql_data)
sql_data_cmd.close()

sql_data_log=open( os.path.join(context['temp_directory'],'tmp_data_4135.log'), 'w')
subprocess.call( ["isql", dsn, "-i", sql_data_cmd.name],
                 stdout=sql_data_log, 
                 stderr=subprocess.STDOUT)
sql_data_log.close()

#--------------------------------------------------


# Now we run SWEEP in child process (asynchronous) and while it will in work - try to establish several attachments.
##################

fbsvc_log=open( os.path.join(context['temp_directory'],'tmp_svc_4135.log'), 'w')
fbsvc_log.write("Starting sweep")
fbsvc_log.seek(0,2)
p_sweep=subprocess.Popen([ "fbsvcmgr","localhost:service_mgr",
                           "action_repair", "dbname", db_file, "rpr_sweep_db"],
                           stdout=fbsvc_log, stderr=subprocess.STDOUT
                        )

time.sleep(1)

#---------------------------------------------------------

# Save current timestamp: this is point BEFORE we try to establish attachmentas using several ISQL sessions:
t1 = datetime.strftime(datetime.now(), '%Y-%m-%d %H:%M:%S')

# Try to establish several attachments to database while sweep is in work:

planned_attachments = 10

sqlatt=open( os.path.join(context['temp_directory'],'tmp_att_4135.sql'), 'w')
sqlatt.write('set list on; select current_connection, m.* from mon$attachments m order by m.mon$attachment_id; quit;')
sqlatt.close()

f_list=[]
p_list=[]
for i in range(0, planned_attachments):
    sqllog=open( os.path.join(context['temp_directory'],'tmp_att_4135_'+str(i)+'.log'), 'w')
    f_list.append(sqllog)

for i in range(len(f_list)):
    p_isql=Popen( [ "isql" , dsn, "-i", sqlatt.name ],
                  stdout=f_list[i], 
                  stderr=subprocess.STDOUT
                )
    p_list.append(p_isql)

# Here we have to wait a little in order to all ISQL will establish their attachments:
# 4.0.0.238 Classic: one needed to increased time from 3 to 5 seconds otherwise NOT ALL
# ISQL attachments can be etsablished!

time.sleep(5)

# Save current timestamp: we assume that now ALL isql sessions already FINISHED to establish attachment (or the whole job and quited):
t2 = datetime.strftime(datetime.now(), '%Y-%m-%d %H:%M:%S')

#---------------------------------------------------------

# Move database to shutdown in order to stop sweep, and then extract header info:

dbshut_log=open( os.path.join(context['temp_directory'],'tmp_sht_4135.log'), 'w')
dbshut_log.write("Call DB shutdown")
dbshut_log.seek(0,2)
subprocess.call(["fbsvcmgr","localhost:service_mgr",
                 "action_properties", "dbname", db_file, 
                 "prp_shutdown_mode", "prp_sm_full", "prp_force_shutdown", "0"],
                stdout=dbshut_log, stderr=subprocess.STDOUT)

dbshut_log.seek(0,2)

subprocess.call(["fbsvcmgr","localhost:service_mgr",
                 "action_db_stats", "dbname", db_file, "sts_hdr_pages"],
                stdout=dbshut_log, stderr=subprocess.STDOUT)

# Kill all child ISQL processes:
for i in range(len(f_list)):
  p_list[i].terminate()
  f_list[i].close()

p_sweep.terminate()

#---------------------------------------------------------

# Return database online in order to check number of attachments that were established while sweep was in work:

dbshut_log.seek(0,2)
dbshut_log.write("Return DB to online")
dbshut_log.seek(0,2)
subprocess.call(["fbsvcmgr","localhost:service_mgr",
                 "action_properties", "dbname", db_file, "prp_db_online"],
                stdout=dbshut_log, stderr=subprocess.STDOUT)

dbshut_log.seek(0,2)
subprocess.call(["fbsvcmgr","localhost:service_mgr",
                 "action_db_stats", "dbname", db_file, "sts_hdr_pages"],
                stdout=dbshut_log, stderr=subprocess.STDOUT)

dbshut_log.close()
fbsvc_log.close()


#---------------------------------------------------------

# Check: number of ISQL attachments between t1 and t2 must be equal to 'planned_attachments'

# SuperServer has two system attachments with mon$user='Garbage Collector' and 'Cache Writer',
# we have to SKIP them from counting:

sql_data='''\
set list on;
select iif( cnt = %s, 
            'OK, number of attachments is equal to expected value.', 
            'Wrong: '||cnt||' attachments could be done instead of expected '||%s 
          ) as check_num_of_attachments
from (
   select 
       count( nullif(mon_system_flag,1) )  as cnt
   from mon_attach_data d
   where 
       d.mon_timestamp between '%s' and '%s' 
       and d.mon_remote_protocol is not null 
       and mon_remote_address is not null 
       and mon_remote_process containing 'isql'
);
commit;
'''

sqlchk=open( os.path.join(context['temp_directory'],'tmp_chk_4135.sql'), 'w')
sqlchk.write(sql_data % (planned_attachments, planned_attachments, t1, t2) )
sqlchk.close()

sqllog=open( os.path.join(context['temp_directory'],'tmp_chk_4135.log'), 'w')
subprocess.call( [ "isql" , dsn, "-nod", "-i", sqlchk.name ],
                  stdout=sqllog, stderr=subprocess.STDOUT
               )
sqllog.close()

with open(sqllog.name) as f:
  print( f.read() )
f.close()

time.sleep(1)

#---------------------------------------------------------

for i in range(len(f_list)):
  os.remove(f_list[i].name)

os.remove(dbshut_log.name)
os.remove(fbsvc_log.name)
os.remove(sqllog.name)
os.remove(sql_data_log.name)
os.remove(sql_data_cmd.name)
os.remove(sql_ddl_log.name)
os.remove(sql_ddl_cmd.name)
os.remove(sqlchk.name)
os.remove(sqlatt.name)

  """,
 'expected_stdout': 
  """
    CHECK_NUM_OF_ATTACHMENTS        OK, number of attachments is equal to expected value.
  """,
 'expected_stderr': 
  """
  """
}
]
}
