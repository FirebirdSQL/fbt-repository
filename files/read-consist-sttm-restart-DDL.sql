-- Common DDL script for testst which veriry STATEMENT RESTART functionality that is able in READ CONSISTENSY.
-- About statement restart:
-- https://asktom.oracle.com/pls/asktom/f?p=100:11:::::P11_QUESTION_ID:11504247549852
SET BAIL ON;
create or alter view v_worker_log as select 1 x from rdb$database;
create table test(id int generated by default as identity primary key using index test_pk_asc, att int default current_connection, x int);
create table tsrc(id int generated by default as identity primary key using index tsrc_pk_asc, att int default current_connection, x int);
create table flag(id int primary key);
commit;
create descending index test_id_des on test(id);
commit;

create table tlog_want(
    id int generated by default as identity
    ,att int default current_connection
    ,trn int default current_transaction
    ,who varchar(30)
    ,old_id int, old_x int
    ,new_id int, new_x int
    ,op varchar(3)
    ,rec_vers int
    ,global_cn int
    ,snap_no int
    ,dts timestamp default 'now'
);
create table tlog_done(
    id int generated by default as identity
    ,att int default current_connection
    ,trn int default current_transaction
    ,who varchar(30)
    ,old_id int, old_x int
    ,new_id int, new_x int
    ,op varchar(3)
    ,rec_vers int
    ,global_cn int
    ,snap_no int
    ,dts timestamp default 'now'
);

create or alter view v_worker_log as
    select
        d.old_id
        ,d.new_id
        ,d.op
        ,dense_rank()over(order by d.rec_vers) as rec_vers
        ,dense_rank()over(order by d.snap_no) as snap_no
        --, rec_vers, snap_no, dts
    from tlog_done d
    where upper(d.who) starting with upper('worker')
    order by d.id
;
commit;

-----------------------------------------

set term ^;
create trigger test_biud for test inactive before insert or update or delete as
    declare v_trn int;
    declare c int;
    declare v_rec_vers int;
    declare v_snap_no type of column tlog_want.snap_no;
    declare v_global_cn type of column tlog_want.global_cn;
    declare v_who type of column tlog_want.who;
begin
    v_who = rdb$get_context('USER_SESSION', 'WHO');
    v_trn = current_transaction;

    --- does not work! always has value = 0 : v_rec_vers = iif(inserting or updating, new.rdb$record_version, old.rdb$record_version);
    if (deleting) then
        rdb$set_context('USER_TRANSACTION', 'REC_VERS', (select rdb$record_version from test t where t.id = :old.id) );


    v_global_cn = rdb$get_context('SYSTEM', 'GLOBAL_CN');
    v_snap_no = rdb$get_context('SYSTEM', 'SNAPSHOT_NUMBER');

    in autonomous transaction do
    begin
        -- All following statements lead to firing trigger TRG_COMMIT which, in turn also adds rows to tlog* tables.
        -- But we want to log only those commits which we explicitly entered.
        -- In order to skip such excessive inserts, we temporary make assign NULL to the context variable 'WHO'.
        -- Trigger TRG_COMMIT will do inserts only when this variable is not null.
        rdb$set_context('USER_SESSION', 'WHO', null);
        if (deleting) then
            insert into tlog_want( trn, old_id, old_x, op, rec_vers, global_cn, snap_no, who ) values( :v_trn, :old.id, :old.x, 'DEL', :v_rec_vers, :v_global_cn, :v_snap_no, :v_who );
        else if (updating) then
            insert into tlog_want( trn, old_id, old_x, new_id, new_x, op, rec_vers, global_cn, snap_no, who ) values( :v_trn, :old.id, :old.x, :new.id, :new.x, 'UPD', :v_rec_vers, :v_global_cn, :v_snap_no, :v_who );
        else
            insert into tlog_want( trn, new_id, new_x, op, rec_vers, global_cn, snap_no, who ) values( :v_trn, :new.id, :new.x,'INS', :v_rec_vers, :v_global_cn, :v_snap_no, :v_who );
    end

    rdb$set_context('USER_SESSION', 'WHO', v_who );


end
^
create trigger test_aiud for test inactive after insert or update or delete as
    declare v_trn int;
    declare c int;
    declare v_rec_vers int;
    declare v_snap_no type of column tlog_done.snap_no;
    declare v_global_cn type of column tlog_done.global_cn;
    declare v_who type of column tlog_done.who;
begin
    v_who = rdb$get_context('USER_SESSION', 'WHO');
    v_trn = current_transaction;

    --- does not work! always has value = 0 : v_rec_vers = iif(inserting or updating, new.rdb$record_version, old.rdb$record_version);
    if (not deleting) then
        rdb$set_context('USER_TRANSACTION', 'REC_VERS', (select rdb$record_version from test t where t.id = :new.id) );
    
    v_rec_vers = rdb$get_context('USER_TRANSACTION', 'REC_VERS');

    v_global_cn = rdb$get_context('SYSTEM', 'GLOBAL_CN');
    v_snap_no = rdb$get_context('SYSTEM', 'SNAPSHOT_NUMBER');

    in autonomous transaction do
    begin
        -- All following statements lead to firing trigger TRG_COMMIT which, in turn also adds rows to tlog* tables.
        -- But we done to log only those commits which we explicitly entered.
        -- In order to skip such excessive inserts, we temporary make assign NULL to the context variable 'WHO'.
        -- Trigger TRG_COMMIT will do inserts only when this variable is not null.
        rdb$set_context('USER_SESSION', 'WHO', null);
        if (deleting) then
            insert into tlog_done( trn, old_id, old_x, op, rec_vers, global_cn, snap_no, who ) values( :v_trn, :old.id, :old.x, 'DEL', :v_rec_vers, :v_global_cn, :v_snap_no, :v_who );
        else if (updating) then
            insert into tlog_done( trn, old_id, old_x, new_id, new_x, op, rec_vers, global_cn, snap_no, who ) values( :v_trn, :old.id, :old.x, :new.id, :new.x, 'UPD', :v_rec_vers, :v_global_cn, :v_snap_no, :v_who );
        else
            insert into tlog_done( trn, new_id, new_x, op, rec_vers, global_cn, snap_no, who ) values( :v_trn, :new.id, :new.x,'INS', :v_rec_vers, :v_global_cn, :v_snap_no, :v_who );
    end

    rdb$set_context('USER_SESSION', 'WHO', v_who );

end
^


create or alter trigger trg_commit inactive on transaction commit position 999 as
begin
    if ( rdb$get_context('USER_SESSION', 'WHO') > '' ) then
    begin
        insert into tlog_want( op, who ) values(  'COM', rdb$get_context('USER_SESSION', 'WHO') );
        insert into tlog_done( op, who ) values(  'COM', rdb$get_context('USER_SESSION', 'WHO') );
    end
end
^

create or alter trigger trg_rollback inactive on transaction rollback position 999 as
begin
    if ( rdb$get_context('USER_SESSION', 'WHO') > '' ) then
        in autonomous transaction do
        begin
            insert into tlog_want( op, who ) values(  'COM', rdb$get_context('USER_SESSION', 'WHO') );
            insert into tlog_done( op, who ) values(  'RBK', rdb$get_context('USER_SESSION', 'WHO') );
        end
end
^


set term ;^
commit;

commit;
alter trigger test_biud active;
alter trigger test_aiud active;
alter trigger trg_commit active;
alter trigger trg_rollback active;
commit;

