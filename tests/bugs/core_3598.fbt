{
'id': 'bugs.core_3598',
'qmid': None,
'tracker_id': 'CORE-3598',
'title': "TRACE: add statistics of actions that were after transaction finished",
'description':
 """
   1. Obtain engine_version from built-in context variable.
   2. Make config for trace in proper format according to FB engine version.
   3. Launch trace session in separate child process using 'FBSVCMGR action_trace_start'
   4. Run ISQL with test commands.
   5. Stop trace session. Output its log with filtering only interested lines.

   Checked on: 
   *  WI-V2.5.6.26963 -- absent line with per-table info for ROLLBACK event, see issue in the ticket 20.01.2016
   *  WI-V3.0.0.32280 (SS, SC, CS). -- works fine.
   
   ##########################
   NB: implementation for 2.5 was deferred because its output does not contain per-table block for ROLLBACK event.
   11.05.2017: TEMPLY REPLACED 'min_versions': '2.5.2' with '3.0' because trace for 3.0+ always contains auxiliary
   Tx with TIL = RC (see sample of trace log below).
   Checked on 3.0.3.32721 (SS, CS), 4.0.0.638 (SS, CS)
 """,
'min_versions': '3.0',
'versions': [
{
 'firebird_version': '3.0',
 'platform': 'All',
 'test_type': 'Python',
 'init_script':
  """
    recreate table tfix(id int);
    recreate global temporary table gtt_ssn(id int) on commit preserve rows;
    recreate global temporary table gtt_tra(id int) on commit delete rows;
  """,
 'test_script':
  """\
import os
import subprocess
from subprocess import Popen
import time

os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password

# Obtain engine version:
engine = str(db_conn.engine_version)
db_file = db_conn.database_name
db_conn.close()

#---------------------------------------------

def flush_and_close(file_handle):
    # https://docs.python.org/2/library/os.html#os.fsync
    # If you're starting with a Python file object f, 
    # first do f.flush(), and 
    # then do os.fsync(f.fileno()), to ensure that all internal buffers associated with f are written to disk.
    global os
    
    file_handle.flush()
    if file_handle.mode not in ('r', 'rb'):
        # otherwise: "OSError: [Errno 9] Bad file descriptor"!
        os.fsync(file_handle.fileno())
    file_handle.close()

#--------------------------------------------

def cleanup( f_names_list ):
    global os
    for i in range(len( f_names_list )):
       if os.path.isfile( f_names_list[i]):
            os.remove( f_names_list[i] )
            if os.path.isfile( f_names_list[i]):
                print('ERROR: can not remove file ' + f_names_list[i])

#--------------------------------------------


txt25 = '''# Trace config, format for 2.5. Generated auto, do not edit!
    <database %[\\\\\\\\/]security?.fdb>
        enabled false
    </database>
    <database %[\\\\\\\\/]bugs.core_3598.fdb>
        enabled true
        log_transactions true
        print_perf true
        time_threshold 0 
        log_initfini false
    </database>
'''

# NOTES ABOUT TRACE CONFIG FOR 3.0:
# 1) Header contains `database` clause in different format vs FB 2.5: its data must be enclosed with '{' '}'
# 2) Name and value must be separated by EQUALITY sign ('=') in FB-3 trace.conf, otherwise we get runtime error:
#    element "<. . .>" have no attribute value set

txt30 = '''# Trace config, format for 3.0. Generated auto, do not edit!
    database=%[\\\\\\\\/]security?.fdb
    {
        enabled = false
    }

    database=%[\\\\\\\\/]bugs.core_3598.fdb
    {
        enabled = true
        log_transactions = true
        print_perf = true
        time_threshold = 0 
        log_initfini = false
    }
'''

f_trccfg=open( os.path.join(context['temp_directory'],'tmp_trace_3598.cfg'), 'w')
if engine.startswith('2.5'):
    f_trccfg.write(txt25)
else:
    f_trccfg.write(txt30)
flush_and_close( f_trccfg )

#####################################################
# Starting trace session in new child process (async.):

f_trclog = open( os.path.join(context['temp_directory'],'tmp_trace_3598.log'), 'w')
# Execute a child program in a new process, redirecting STDERR to the same target as of STDOUT:
p_trace=Popen([context['fbsvcmgr_path'], "localhost:service_mgr", "action_trace_start", "trc_cfg", f_trccfg.name], stdout=f_trclog, stderr=subprocess.STDOUT)

# Wait! Trace session is initialized not instantly!
time.sleep(1)

#####################################################
# Running ISQL with test commands:

sqltxt=\
'''
    insert into tfix(id) values(1);
    commit;
    insert into tfix(id) values(2);
    rollback;
    insert into gtt_ssn(id) values(1);
    commit;
    insert into gtt_ssn(id) values(2);
    rollback;
    insert into gtt_tra(id) values(1);
    commit;
    insert into gtt_tra(id) values(2);
    rollback;
'''

# !!! NB !!! 11.05.2017
# Command switch "-n" does NOT help to prevent "auxiliary" Tx and its rollback, TIL=RC (3.0.2 & 4.0)
# Trace logs in current FB versions looks like this:
'''
	C:\MIX\FIREBIRD\QA\FBT-REPO\TMP\BUGS.CORE_3598.FDB (ATT_9, SYSDBA:NONE, NONE, TCPv4:127.0.0.1/4029)
	C:\MIX\firebird\fb30\isql.exe:288
		(TRA_14, CONCURRENCY | WAIT | READ_WRITE)

2017-05-11T17:28:04.0000 (3264:014B2558) START_TRANSACTION
	C:\MIX\FIREBIRD\QA\FBT-REPO\TMP\BUGS.CORE_3598.FDB (ATT_9, SYSDBA:NONE, NONE, TCPv4:127.0.0.1/4029)
	C:\MIX\firebird\fb30\isql.exe:288
		(TRA_15, READ_COMMITTED | NO_REC_VERSION | WAIT | READ_WRITE)

2017-05-11T17:28:04.0000 (3264:014B2558) ROLLBACK_TRANSACTION
	C:\MIX\FIREBIRD\QA\FBT-REPO\TMP\BUGS.CORE_3598.FDB (ATT_9, SYSDBA:NONE, NONE, TCPv4:127.0.0.1/4029)
	C:\MIX\firebird\fb30\isql.exe:288
		(TRA_15, READ_COMMITTED | NO_REC_VERSION | WAIT | READ_WRITE)
      0 ms, 1 read(s), 1 write(s), 1 fetch(es), 1 mark(s) <<<<<< THIS TX DID APPEAR IN RECENT FB 3.0 & 4.0

2017-05-11T17:28:04.0000 (3264:014B2558) COMMIT_TRANSACTION
	C:\MIX\FIREBIRD\QA\FBT-REPO\TMP\BUGS.CORE_3598.FDB (ATT_9, SYSDBA:NONE, NONE, TCPv4:127.0.0.1/4029)
	C:\MIX\firebird\fb30\isql.exe:288
		(TRA_14, CONCURRENCY | WAIT | READ_WRITE)
      0 ms, 1 read(s), 4 write(s), 1 fetch(es), 1 mark(s) <<<<<<<<<< THIS IS TX WHICH WAS STARTED BY US
'''

runProgram('isql',[dsn,'-n'],sqltxt)

# do NOT remove this otherwise trace log can contain only message about its start before being closed!
time.sleep(2)

#####################################################
# Getting ID of launched trace session and STOP it:

# Save active trace session info into file for further parsing it and obtain session_id back (for stop):
f_trclst=open( os.path.join(context['temp_directory'],'tmp_trace_3598.lst'), 'w')
subprocess.call([context['fbsvcmgr_path'], "localhost:service_mgr", "action_trace_list"],stdout=f_trclst, stderr=subprocess.STDOUT)
flush_and_close( f_trclst )

trcssn=0
with open( f_trclst.name,'r') as f:
    for line in f:
        i=1
        if 'Session ID' in line:
            for word in line.split():
                if i==3:
                    trcssn=word
                i=i+1
            break

# Result: `trcssn` is ID of active trace session. Now we have to terminate it:
f_trclst=open(f_trclst.name,'a')
f_trclst.seek(0,2)
subprocess.call([context['fbsvcmgr_path'], "localhost:service_mgr", "action_trace_stop","trc_id",trcssn],stdout=f_trclst, stderr=subprocess.STDOUT)
flush_and_close( f_trclst )

# 23.02.2021. DELAY FOR AT LEAST 1 SECOND REQUIRED HERE!
# Otherwise trace log can remain empty.
time.sleep(1)

# Terminate child process of launched trace session (though it should already be killed):
p_trace.terminate()
flush_and_close( f_trclog )

###################################################################

# Output log of trace session, with filtering only interested info:

# Pwerformance header text (all excessive spaces will be removed before comparison - see below):
perf_header='Table                             Natural     Index    Update    Insert    Delete   Backout     Purge   Expunge'
i=0
with open( f_trclog.name,'r') as f:
    for line in f:
        if ' ms,' in line and ('fetch' in line or 'mark' in line): # One of these always WILL be in trace statistics.
            print('Statement statistics detected.')
            i =  i +1
            '''
            if engine.startswith('2.5') and ( i == 2 or i == 4):
                # Dummy emulation of output in 2.5 for it will match to 3.0 - see comment by hvlad in the ticket, 21/Jan/16 11:26 AM:
                # Per-table statistics at transaction level are not accumulated in v2.5
                # Enabling it is possible but have almost no sence as it adds some run-time cost, 
                # while there is no way to query it (except of "tx end" trace event). 

                print('Performance block detected.')
                if i==2:
                    print('Found table statistics for: TFIX')
                else:
                    print('Found table statistics for: GTT_SSN')
            '''
        if ' '.join(line.split()).upper() == ' '.join(perf_header.split()).upper():
            print('Performance block detected.')
        if line.startswith('TFIX') or line.startswith('GTT_SSN') or line.startswith('GTT_TRA'):
            print('Found table statistics for: '+line.split()[0])

# Cleanup:
##########
time.sleep(1)

cleanup( [i.name for i in (f_trccfg, f_trclst,f_trclog)] )

  """,
 'expected_stdout': 
  """
    Statement statistics detected.
    Statement statistics detected.
    Statement statistics detected.
    Performance block detected.
    Found table statistics for: TFIX
    Statement statistics detected.
    Statement statistics detected.
    Performance block detected.
    Found table statistics for: GTT_SSN
    Statement statistics detected.
    Statement statistics detected.
  """,
 'expected_stderr': 
  """
  """
}
]
}
