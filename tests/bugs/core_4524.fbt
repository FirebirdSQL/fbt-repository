{
'id': 'bugs.core_4524',
'qmid': None,
'tracker_id': 'CORE-4524',
'title': "New gbak option to enable encryption during restore",
'description':
 """
    Part of this test was copied from core_6071.fbt.
    We create new database and try to encrypt it using IBSurgeon Demo Encryption package
    ( https://ib-aid.com/download-demo-firebird-encryption-plugin/ ; https://ib-aid.com/download/crypt/CryptTest.zip )
    License file plugins\dbcrypt.conf with unlimited expiration was provided by IBSurgeon to Firebird Foundation (FF).
    This file was preliminary stored in FF Test machine.
    Test assumes that this file and all neccessary libraries already were stored into FB_HOME and %FB_HOME%\plugins.

    Anyone who wants to run this test on his own machine must
    1) download https://ib-aid.com/download/crypt/CryptTest.zip AND 
    2) PURCHASE LICENSE and get from IBSurgeon file plugins\dbcrypt.conf with apropriate expiration date and other info.
    
    ################################################ ! ! !    N O T E    ! ! ! ##############################################
    FF tests storage (aka "fbt-repo") does not (and will not) contain any license file for IBSurgeon Demo Encryption package!
    #########################################################################################################################

    We create several generators in the test DB and get number of generators page using query to RDB$PAGES (page_type=9).
    Also we get page_size and using these data we can obtain binary content of generatord page. This content futher is parsed
    in order to verify that generators names are readable (while DB is not yet encrypted).

    Then we encrypt DB using  'alter database encrypt with <plugin_name> ...' command
    (where <plugin_name> = dbcrypt - name of .dll in FB_HOME\plugins\ folder that implements encryption).
    NB: we have to make delay after this about 1..2 seconds BEFORE detach from database.

    After this we:
    1. Change temp DB state to full shutdown and bring it online - in order to be sure that we will able to drop this file later;
    2. Make backup of this temp DB, using gbak utility and '-KEYHOLDER <name_of_key_holder>' command switch.
    3. Make restore from just created backup.
    4. Make validation of just restored database by issuing command "gfix -v -full ..."
       ( i.e. validate both data and metadata rather than online val which can check user data only).
    5. Open restored DB as binary file and attempt to read again generators names - this must fail, their names must be encrypted.
    6. Check that NO errors occured on any above mentioned steps. Also check that backup and restore STDOUT logs contain expected 
       text about successful completition

    Checked on 4.0.0.2119 SS/CS, time: ~10s.

    === NOTE-1 ===
    In case of "Crypt plugin DBCRYPT failed to load/607/335544351" check that all 
    needed files from IBSurgeon Demo Encryption package exist in %FB_HOME% and %FB_HOME%\plugins
    %FB_HOME%:
        283136 fbcrypt.dll
       2905600 libcrypto-1_1-x64.dll
        481792 libssl-1_1-x64.dll

    %FB_HOME%\plugins:
        297984 dbcrypt.dll
        306176 keyholder.dll
           108 DbCrypt.conf
           856 keyholder.conf
    
    === NOTE-2 ===
    Version of DbCrypt.dll of october-2018 must be replaced because it has hard-coded 
    date of expiration rather than reading it from DbCrypt.conf !!

    === NOTE-3 ===
    firebird.conf must contain following line:
        KeyHolderPlugin = KeyHolder

 """,
'min_versions': '4.0',
'versions': [
{
 'firebird_version': '4.0',
 'platform': 'Windows',
 'init_script':
  """
  """,
 'test_type': 'Python',
 'test_script': 
  """
import os
import time
import subprocess
import binascii
import re
import fdb

os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password
db_conn.close()

#--------------------------------------------

def cleanup( f_names_list ):
    global os
    for i in range(len( f_names_list )):
       if os.path.isfile( f_names_list[i]):
            os.remove( f_names_list[i] )

#--------------------------------------------

def check_page_for_readable_values(dbname, gen_page_number, pg_size, check_sequence_values):

    global binascii

    db_handle = open( dbname, "rb")
    db_handle.seek( gen_page_number * pg_size )
    page_content = db_handle.read( pg_size )
    # read_binary_content( db_handle, gen_page_number * pg_size, pg_size )
    db_handle.close()
    page_as_hex=binascii.hexlify( page_content )

    # Iterate for each sequence value:
    for n in check_sequence_values:

        # Get HEX representation of digital value.
        # NOTE: format( 830624, 'x') is 'caca0' contains five (odd number!) characters.
        hex_string = format(abs(n),'x')

        # Here we 'pad' hex representation to EVEN number of digits in it,
        # otherwise binascii.hexlify fails with "Odd-length string error":
        hex_string = ''.join( ('0' * ( len(hex_string)%2 ), hex_string ) )

        # ::: NOTE :::
        # Generator value is stored in REVERSED bytes order.
        # dec 830624 --> hex 0x0caca0 --> 0c|ac|a0 --> stored in page as three bytes: {a0; ac; 0c}

        # Decode string that is stored in variable 'hex_string' to HEX number,
        # REVERSE its bytes and convert it to string again for further search
        # in page content:
        n_as_reversed_hex = binascii.hexlify( hex_string.decode('hex')[::-1] )

        print(n, n_as_reversed_hex, 'FOUND.' if n_as_reversed_hex in page_as_hex else 'NOT FOUND.' )
        # print(n, n_as_reversed_hex, 'UNEXPECTEDLY FOUND AT POS. ' + '{:5d}'.format( page_as_hex.index(n_as_reversed_hex) ) if n_as_reversed_hex in page_as_hex else 'Not found (expected).' )

#--------------------------------------------

tmpfdb='$(DATABASE_LOCATION)'+'tmp_core_4524.encrypted.fdb'
tmpres='$(DATABASE_LOCATION)'+'tmp_core_4524.restored.fdb'
tmpbkp='$(DATABASE_LOCATION)'+'tmp_core_4524.encrypted.fbk'

cleanup( (tmpfdb, tmpres) )

con = fdb.create_database( dsn = 'localhost:'+tmpfdb )
con.close()
con=fdb.connect( dsn = 'localhost:'+tmpfdb )

con.execute_immediate('create sequence gen_ba0bab start with 12192683')
con.execute_immediate('create sequence gen_badf00d start with 195948557')
con.execute_immediate('create sequence gen_caca0  start with 830624')
con.execute_immediate('create sequence gen_c0ffee start with 12648430')
con.execute_immediate('create sequence gen_dec0de start with 14598366')
con.execute_immediate('create sequence gen_decade start with 14600926')
con.execute_immediate('create sequence gen_7FFFFFFF start with 2147483647')
con.commit()

cur=con.cursor()
get_current_seq_values=\
'''
    execute block returns( gen_curr bigint) as
        declare gen_name rdb$generator_name;
    begin
        for
            select rdb$generator_name from rdb$generators where rdb$system_flag is distinct from 1 order by rdb$generator_id
            into gen_name
        do begin
            execute statement 'execute block returns(g bigint) as begin g = gen_id('|| gen_name ||', 0); suspend;  end' into gen_curr;
            suspend;
        end
    end
'''

# Obtain current values of user generators:
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cur.execute(get_current_seq_values)
check_sequence_values=[]
for r in cur:
    check_sequence_values += r[0],
#print('check_sequence_values=',check_sequence_values)



# Obtain page size and number of generators page:
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cur.execute('select m.mon$page_size,min(rdb$page_number) from mon$database m cross join rdb$pages p where p.rdb$page_type = 9 group by 1')
pg_size, gen_page_number = -1,-1
for r in cur:
    pg_size=r[0]
    gen_page_number=r[1]
    # print(r[0],r[1])
cur.close()


# Read gen page, convert it to hex and check whether generator values can be found there or no:
# Expected result: YES for all values because DB not encrypted now.
# ~~~~~~~~~~~~~~~
check_page_for_readable_values(tmpfdb, gen_page_number, pg_size, check_sequence_values)

################################################
###    e n c r y p t      d a t a b a s e    ###
################################################

con.execute_immediate('alter database encrypt with dbcrypt key Red')
con.commit()
time.sleep(2)
#          ^
#          +-------- !! ALLOW BACKGROUND ENCRYPTION PROCESS TO COMPLETE ITS JOB !!

con.close()

#-------------------------- shutdown temp DB and bring it online --------------------

f_dbshut_log = open( os.path.join(context['temp_directory'],'tmp_dbshut_4524.log'), 'w')
subprocess.call( [ "gfix", 'localhost:'+tmpfdb, "-shut", "full", "-force", "0" ],
                 stdout = f_dbshut_log,
                 stderr = subprocess.STDOUT
               )
subprocess.call( [ "gfix", 'localhost:'+tmpfdb, "-online" ],
                 stdout = f_dbshut_log,
                 stderr = subprocess.STDOUT
               )
f_dbshut_log.close()

#--------------------------- backup and restore --------------------------------------
fn_bkp_log=open( os.path.join(context['temp_directory'],'tmp_backup_4524.log'), 'w')
fn_bkp_err=open( os.path.join(context['temp_directory'],'tmp_backup_4524.err'), 'w')

subprocess.call([ "gbak.exe"
                 ,"-b"
                 ,"-v"
                 ,"-KEYHOLDER", "KeyHolder"
                 ,"-crypt", "DbCrypt"
                 ,'localhost:' + tmpfdb
                 ,tmpbkp
                ],
                stdout=fn_bkp_log, stderr=fn_bkp_err)

fn_bkp_log.close()
fn_bkp_err.close()


fn_res_log=open( os.path.join(context['temp_directory'],'tmp_restore_4524.log'), 'w')
fn_res_err=open( os.path.join(context['temp_directory'],'tmp_restore_4524.err'), 'w')

# C:\FB\40SS\gbak.exe -rep -KEYHOLDER KeyHolder C:\FBTESTING\qa\misc\C4524.fbk /:C:\FBTESTING\qa\misc\c4524.restored.FDB
subprocess.call([ "gbak"
                 ,"-rep"
                 ,"-v"
                 ,"-KEYHOLDER", "KeyHolder"
                 ,tmpbkp
                 ,'localhost:' + tmpres
                ],
                stdout=fn_res_log, stderr=fn_res_err)

fn_res_log.close()
fn_res_err.close()

#-------------------------- validate just restored database --------------------

f_valid_log = open( os.path.join(context['temp_directory'],'tmp_valid_4524.log'), 'w')
subprocess.call( [ "gfix", 'localhost:'+tmpres, "-v", "-full" ],
                 stdout = f_valid_log,
                 stderr = subprocess.STDOUT
               )
f_valid_log.close()

#-----------------------------------------------

# Read gen page in RESTORED database, convert it to hex and check whether generator values can be found there or no.
# Expected result: NOT for all values because DB was encrypted.
# ~~~~~~~~~~~~~~~~
check_page_for_readable_values(tmpres, gen_page_number, pg_size, check_sequence_values)

#-----------------------------------------------

# Check that all was fine:

with open(f_dbshut_log.name,'r') as f:
    for line in f:
        print('UNEXPECTED SHUTDOWN OUTPUT: ' + line)

with open(fn_bkp_err.name,'r') as f:
    for line in f:
        print('UNEXPECTED BACKUP STDERR: ' + line)

with open(fn_res_err.name,'r') as f:
    for line in f:
        print('UNEXPECTED RESTORE STDERR: ' + line)

with open(f_dbshut_log.name,'r') as f:
    for line in f:
        print('UNEXPECTED VALIDATION OUTPUT: ' + line)


# gbak -b should finish with line:
#    gbak:closing file, committing, and finishing. 512 bytes written
gbak_backup_finish_ptn=re.compile('gbak:closing\s+file,\s+committing,\s+and\s+finishing.*', re.IGNORECASE)
with open(fn_bkp_log.name,'r') as f:
    for line in f:
        if gbak_backup_finish_ptn.search(line):
            print('EXPECTED BACKUP FINISH FOUND: '+line.upper() )


# gbak -c should finish with lines:
#    gbak:finishing, closing, and going home
#    gbak:adjusting the ONLINE and FORCED WRITES flags

gbak_restore_finish_ptn=re.compile('gbak:adjusting\s+the\s+ONLINE\s+and\s+FORCED\s+WRITES\s+.*', re.IGNORECASE)
with open(fn_res_log.name,'r') as f:
    for line in f:
        if gbak_restore_finish_ptn.search(line):
            print('EXPECTED RESTORE FINISH FOUND: '+line.upper() )


# Allow all file buffers to be flushed on disk before we will drop them:
time.sleep(1)

# cleanup
##########

f_list = [ i.name for i in ( f_dbshut_log, fn_bkp_log, fn_bkp_err, fn_res_log, fn_res_err, f_valid_log ) ] + [ tmpfdb, tmpres, tmpbkp ]
cleanup( f_list )

  """,
 'expected_stdout':
  """
    12192683 ab0bba FOUND.
    195948557 0df0ad0b FOUND.
    830624 a0ac0c FOUND.
    12648430 eeffc0 FOUND.
    14598366 dec0de FOUND.
    14600926 decade FOUND.
    2147483647 ffffff7f FOUND.

    12192683 ab0bba NOT FOUND.
    195948557 0df0ad0b NOT FOUND.
    830624 a0ac0c NOT FOUND.
    12648430 eeffc0 NOT FOUND.
    14598366 dec0de NOT FOUND.
    14600926 decade NOT FOUND.
    2147483647 ffffff7f NOT FOUND.

    EXPECTED BACKUP FINISH FOUND: GBAK:CLOSING FILE, COMMITTING, AND FINISHING.
    EXPECTED RESTORE FINISH FOUND: GBAK:ADJUSTING THE ONLINE AND FORCED WRITES FLAGS
  """,
 'expected_stderr':
  """
  """,
  'substitutions': [('\d+ BYTES WRITTEN', '')]
}
]
}
