set bail on; set autoddl off; set list on; select 'oltp30_DDL.sql start' as msg, current_timestamp from rdb$database; set list off; commit; set term ^; execute block as begin begin execute statement 'recreate exception ex_exclusive_required ''At least one concurrent connection detected.'''; when any do begin end end begin execute statement 'recreate exception ex_not_suitable_fb_version ''This script requires at least Firebird 3.x version'''; when any do begin end end end ^ set term ;^ commit; set term ^; execute block as begin if ( rdb$get_context('SYSTEM','ENGINE_VERSION') starting with '2.' ) then begin exception ex_not_suitable_fb_version; end if ( exists( select * from mon$attachments a where a.mon$attachment_id<>current_connection and a.mon$remote_protocol is not null ) ) then begin exception ex_exclusive_required; end end ^ set term ;^ commit; set term ^; execute block as declare stt varchar(8190); declare ref_name varchar(31); declare tab_name varchar(31); declare view_ddl varchar(8190); declare c_view cursor for ( with a as( select rf.rdb$relation_name view_name, rf.rdb$field_position fld_pos,  trim(rf.rdb$field_name) fld_name from rdb$relation_fields rf join rdb$relations rr on rf.rdb$relation_name=rr.rdb$relation_name where coalesce(rf.rdb$system_flag,0)=0 and coalesce(rr.rdb$system_flag,0)=0 and rr.rdb$relation_type=1 ) select view_name, cast( 'create or alter view '||trim(view_name)||' as select ' ||list( fld_pos||' '||trim(lower(  fld_name  )) ) ||' from rdb$database' as varchar(8190) ) view_ddl from a group by view_name ); begin open c_view; while (1=1) do begin fetch c_view into tab_name, stt; if (row_count = 0) then leave; execute statement (:stt); end close c_view; end^ set term ;^ commit; set term ^; execute block as declare stt varchar(512); declare ref_name varchar(31); declare tab_name varchar(31); declare c_trig cursor for (select rt.rdb$trigger_name from rdb$triggers rt where coalesce(rt.rdb$system_flag,0)=0 ); declare c_view cursor for (select rr.rdb$relation_name from rdb$relations rr where rr.rdb$relation_type=1 and coalesce(rr.rdb$system_flag,0)=0 ); declare c_func cursor for (select rf.rdb$function_name from rdb$functions rf where coalesce(rf.rdb$system_flag,0)=0 ); declare c_proc cursor for (select rp.rdb$procedure_name from rdb$procedures rp where coalesce(rp.rdb$system_flag,0)=0 ); declare c_excp cursor for (select re.rdb$exception_name from rdb$exceptions re where coalesce(re.rdb$system_flag,0)=0 ); declare c_fk cursor for (select rc.rdb$constraint_name, rc.rdb$relation_name from rdb$relation_constraints rc where rc.rdb$constraint_type ='FOREIGN KEY' ); declare c_tabs cursor for (select rr.rdb$relation_name from rdb$relations rr where rr.rdb$relation_type in(0,4,5) and coalesce(rr.rdb$system_flag,0)=0 ); declare c_doms cursor for (select rf.rdb$field_name from rdb$fields rf where coalesce(rf.rdb$system_flag,0)=0 and rf.rdb$field_name not starting with 'RDB$' ); declare c_coll cursor for (select rc.rdb$collation_name from rdb$collations rc where coalesce(rc.rdb$system_flag,0)=0 ); declare c_gens cursor for (select rg.rdb$generator_name from rdb$generators rg where coalesce(rg.rdb$system_flag,0)=0 ); declare c_role cursor for (select rr.rdb$role_name from rdb$roles rr where coalesce(rr.rdb$system_flag,0)=0 ); begin open c_trig; while (1=1) do begin fetch c_trig into stt; if (row_count = 0) then leave; stt = 'drop trigger '||stt; execute statement (:stt); end close c_trig; open c_func; while (1=1) do begin fetch c_func into stt; if (row_count = 0) then leave; stt = 'create or alter function '||stt||' returns int as begin return 1; end'; execute statement (:stt); end close c_func; open c_proc; while (1=1) do begin fetch c_proc into stt; if (row_count = 0) then leave; stt = 'create or alter procedure '||stt||' as begin end'; execute statement (:stt); end close c_proc; open c_view; while (1=1) do begin fetch c_view into stt; if (row_count = 0) then leave; stt = 'drop view '||stt; execute statement (:stt); end close c_view; open c_func; while (1=1) do begin fetch c_func into stt; if (row_count = 0) then leave; stt = 'drop function '||stt; execute statement (:stt); end close c_func; open c_proc; while (1=1) do begin fetch c_proc into stt; if (row_count = 0) then leave; stt = 'drop procedure '||stt; execute statement (:stt); end close c_proc; open c_excp; while (1=1) do begin fetch c_excp into stt; if (row_count = 0) then leave; stt = 'drop exception '||stt; execute statement (:stt); end close c_excp; open c_fk; while (1=1) do begin fetch c_fk into ref_name, tab_name; if (row_count = 0) then leave; stt = 'alter table '||tab_name||' drop constraint '||ref_name; execute statement (:stt); end close c_fk; open c_tabs; while (1=1) do begin fetch c_tabs into stt; if (row_count = 0) then leave; stt = 'drop table '||stt; execute statement (:stt); end close c_tabs; open c_doms; while (1=1) do begin fetch c_doms into stt; if (row_count = 0) then leave; stt = 'drop domain '||stt; execute statement (:stt); end close c_doms; open c_coll; while (1=1) do begin fetch c_coll into stt; if (row_count = 0) then leave; stt = 'drop collation '||stt; execute statement (:stt); end close c_coll; open c_gens; while (1=1) do begin fetch c_gens into stt; if (row_count = 0) then leave; stt = 'drop sequence '||stt; execute statement (:stt); end close c_gens; open c_role; while (1=1) do begin fetch c_role into stt; if (row_count = 0) then leave; stt = 'drop role '||stt; execute statement (:stt); end close c_role; end ^ set term ;^ commit; create sequence g_common; create sequence g_doc_data; create sequence g_perf_log; create sequence g_init_pop; create sequence g_qdistr; commit; create collation name_coll for utf8 from unicode case insensitive; create collation nums_coll for utf8 from unicode case insensitive 'NUMERIC-SORT=1'; commit; recreate exception ex_context_var_not_found 'required context variable(s): @1 - not found or has invalid value'; recreate exception ex_bad_working_mode_value 'db-level trigger TRG_CONNECT: no found rows for settings.working_mode=''@1'', correct it!'; recreate exception ex_bad_argument 'argument @1 passed to unit @2 is invalid'; recreate exception ex_test_cancellation 'test_has_been_cancelled (external text file ''stoptest'' is not empty)'; recreate exception ex_record_not_found 'required record not found, datasource: @1, key: @2'; recreate exception ex_cant_lock_row_for_qdistr 'can`t lock any row in `qdistr`: optype=@1, ware_id=@2, qty_required=@3'; recreate exception ex_cant_find_row_for_qdistr 'no rows found for FIFO-distribution: optype=@1, rows in tmp$shopping_cart=@2'; recreate exception ex_no_doc_found_for_handling 'no document found for handling in datasource = ''@1'' with id=@2'; recreate exception ex_no_rows_in_shopping_cart 'shopping_cart is empty, check source ''@1'''; recreate exception ex_not_all_storned_rows_removed 'at least one storned row found in ''qstorned'' table, doc=@1'; recreate exception ex_neg_remainders_encountered 'at least one neg. remainder, ware_id: @1, info: @2'; recreate exception ex_mism_doc_data_qd_qs 'at least one mismatch btw doc_data.id=@1 and qdistr+qstorned: qty=@2, qd_cnt=@3, qs_cnt=@4'; recreate exception ex_orphans_qd_qs_found 'at least one row found for DELETED doc id=@1, snd_id=@2: @3.id=@4'; recreate exception ex_can_not_lock_any_record 'no records could be locked in datasource = ''@1'' with ID >= @2.'; recreate exception ex_can_not_select_random_id 'no id>=@1 in @2 found within scope @3 ... @4'; recreate exception ex_snapshot_isolation_required 'operation must run only in TIL = SNAPSHOT.'; recreate exception ex_read_committed_isolation_req 'operation must run only in TIL = READ COMMITTED.'; recreate exception ex_nowait_or_timeout_required 'transaction must start in NO WAIT mode or with LOCK_TIMEOUT.'; recreate exception ex_update_operation_forbidden 'update operation not allowed on table @1'; recreate exception ex_delete_operation_forbidden 'delete operation not allowed on table @1 when user-data exists'; recreate exception ex_debug_forbidden_operation 'debug: operation not allowed'; commit; create domain dm_dbkey as char(8) character set octets; create domain dm_ids as bigint; create domain dm_ctxns as varchar(16) character set utf8 check( value in ('','USER_SESSION','USER_TRANSACTION', 'SYSTEM')); create domain dm_ctxnv as varchar(80) character set none; create domain dm_dbobj as varchar(31) character set unicode_fss; create domain dm_setting_value as varchar(160) character set utf8 collate name_coll; create domain dm_mcode as varchar(3) character set utf8 collate name_coll; create domain dm_name as varchar(80) character set utf8 collate name_coll; create domain dm_nums as varchar(20) character set utf8 collate nums_coll; create domain dm_qty as numeric(12,3) check(value>=0); create domain dm_qtz as numeric(12,3) default 0 check(value>=0); create domain dm_cost as numeric(12,2); create domain dm_vals as numeric(12,2); create domain dm_aux as double precision; create domain dm_sign as smallint default 0 check(value in(-1, 1, 0)) ; create domain dm_account_type as varchar(1) character set utf8 NOT null check( value in('1','2','i','o','c','s') ); create domain dm_unit varchar(80); create domain dm_info varchar(255); create domain dm_stack varchar(512); commit; recreate global temporary table tmp$shopping_cart( id dm_ids, snd_id bigint, qty numeric(12,3) not null, optype_id bigint, snd_optype_id bigint, rcv_optype_id bigint, storno_sub smallint default 1, qty_bak numeric(12,3) default 0, dup_cnt int default 0, cost_purchase dm_cost, cost_retail dm_cost, constraint tmp_shopcart_unq unique(id, snd_id) using index tmp_shopcart_unq ) on commit delete rows; commit; recreate global temporary table tmp$dep_docs( base_doc_id dm_ids, dependend_doc_id dm_ids, dependend_doc_state dm_ids, dependend_doc_dbkey dm_dbkey, dependend_doc_agent_id dm_ids, ware_id dm_ids, base_doc_qty dm_qty, dependend_doc_qty dm_qty, constraint tmp_dep_docs_unq unique(base_doc_id, dependend_doc_id) using index tmp_dep_docs_unq ) on commit delete rows; commit; recreate global temporary table tmp$result_set( snd_id bigint, id bigint, storno_sub smallint, qdistr_id bigint, qdistr_dbkey dm_dbkey, doc_id bigint, optype_id bigint, oper varchar(80), base_doc_id bigint, doc_data_id bigint, ware_id bigint, qty numeric(12,3), cost_purchase numeric(12,2), cost_retail numeric(12,2), qty_clo numeric(12,3), qty_clr numeric(12,3), qty_ord numeric(12,3), qty_sup numeric(12,3), qty_inc numeric(12,3), qty_avl numeric(12,3), qty_res numeric(12,3), qty_out numeric(12,3), cost_inc numeric(12,2), cost_out numeric(12,2), qty_acn numeric(12,3), cost_acn numeric(12,2), state_id bigint, agent_id bigint, dts_edit timestamp, dts_open timestamp, dts_fix timestamp, dts_clos timestamp, state bigint ) on commit delete rows; commit; create index tmp_result_set_ware_doc on tmp$result_set(ware_id, doc_id); create index tmp_result_set_doc on tmp$result_set(doc_id); commit; recreate global temporary table tmp$perf_mon( unit dm_name, cnt_all int, cnt_ok int, cnt_err int, err_prc numeric(6,2), ok_min_ms int, ok_max_ms int, ok_avg_ms int, cnt_deadlock int, cnt_upd_conf int, cnt_lk_confl int, cnt_user_exc int, cnt_chk_viol int, cnt_no_valid int, cnt_unq_viol int, cnt_fk_viol int, cnt_stack_trc int, cnt_zero_gds int, cnt_other_exc int, first_done timestamp, last_done timestamp, rollup_level smallint, dts_beg timestamp, dts_end timestamp ) on commit delete rows; commit; recreate global temporary table tmp$idx_recalc( tab_name dm_dbobj, idx_name dm_dbobj, idx_stat_befo double precision, idx_stat_afte double precision, idx_stat_diff computed by( idx_stat_afte - idx_stat_befo ), constraint tmp_idx_recalc_idx_name_unq unique(idx_name) ) on commit preserve rows; commit; recreate global temporary table tmp$mon_log( unit dm_unit ,fb_gdscode int ,att_id bigint default current_connection ,trn_id bigint ,pg_reads bigint ,pg_writes bigint ,pg_fetches bigint ,pg_marks bigint ,rec_inserts bigint ,rec_updates bigint ,rec_deletes bigint ,rec_backouts bigint ,rec_purges bigint ,rec_expunges bigint ,rec_seq_reads bigint ,rec_idx_reads bigint ,rec_rpt_reads bigint ,bkv_reads bigint ,frg_reads bigint ,rec_locks bigint ,rec_waits bigint ,rec_confl bigint ,mem_used bigint ,mem_alloc bigint ,stat_id bigint ,server_pid bigint ,mult dm_sign ,add_info dm_info ,dts timestamp default 'now' ,rowset bigint ) on commit preserve rows; commit; recreate global temporary table tmp$mon_log_table_stats( unit dm_unit ,fb_gdscode int ,att_id bigint default current_connection ,trn_id bigint ,table_id smallint ,table_name dm_dbobj ,rec_inserts bigint ,rec_updates bigint ,rec_deletes bigint ,rec_backouts bigint ,rec_purges bigint ,rec_expunges bigint ,rec_seq_reads bigint ,rec_idx_reads bigint ,rec_rpt_reads bigint ,bkv_reads bigint ,frg_reads bigint ,rec_locks bigint ,rec_waits bigint ,rec_confl bigint ,stat_id bigint ,mult dm_sign ,rowset bigint ) on commit preserve rows; commit; recreate table ext_stoptest external 'stoptest.txt' ( s char(2) ); recreate table settings( working_mode varchar(20) character set utf8, mcode dm_name, context varchar(16) default 'USER_SESSION', svalue dm_setting_value, init_on varchar(20) default 'connect', constraint settings_unq unique(working_mode, mcode) using index settings_mode_code, constraint settings_valid_ctype check(context in(null,'USER_SESSION','USER_TRANSACTION')) ); commit; recreate table optypes( id dm_ids constraint pk_optypes primary key using index pk_optypes ,mcode dm_mcode ,name dm_name ,m_qty_clo dm_sign ,m_qty_clr dm_sign ,m_qty_ord dm_sign ,m_qty_sup dm_sign ,m_qty_avl dm_sign ,m_qty_res dm_sign ,m_cost_inc computed by(iif(m_qty_avl=1,1,0)) ,m_cost_out computed by(iif(m_qty_res=-1,1,0)) ,m_cust_debt dm_sign ,m_supp_debt dm_sign ,acn_type dm_account_type ,multiply_rows_for_fifo dm_sign default 0 ,end_state bigint ,constraint optypes_mcode_unq unique(mcode) using index optypes_mcode_unq ,constraint optype_mutual_inc_out check( abs(m_cost_inc)+abs(m_cost_out) < 2 ) ,constraint optype_mult_pay_only check( m_supp_debt=1 and m_cost_inc=1 or m_cust_debt=1 and m_cost_out=1 or m_supp_debt<=0 and m_cust_debt <=0 and (m_cost_inc=0 and m_cost_out=0) ) ); commit; recreate table rules_for_qdistr( mode dm_name ,snd_optype_id bigint ,rcv_optype_id bigint ,storno_sub smallint ,constraint rules_for_qdistr_unq unique(snd_optype_id, rcv_optype_id) using index rules_for_qdistr_unq ); create index rules_for_qdistr_rcvop on rules_for_qdistr(rcv_optype_id); commit; recreate table doc_list( id dm_ids ,optype_id dm_ids ,agent_id dm_ids ,state_id dm_ids ,base_doc_id bigint ,cost_purchase dm_cost default 0 ,cost_retail dm_cost default 0 ,acn_type dm_account_type ,dts_open timestamp default 'now' ,dts_fix timestamp ,dts_clos timestamp ,constraint pk_doc_list primary key(id) using index pk_doc_list ,constraint dts_clos_greater_than_open check(dts_clos is null or dts_clos > dts_open) ); create descending index doc_list_id_desc on doc_list(id); commit; recreate table doc_data( id dm_ids not null ,doc_id dm_ids ,ware_id dm_ids ,qty dm_qty ,cost_purchase dm_cost ,cost_retail dm_cost default 0 ,dts_edit timestamp ,constraint pk_doc_data primary key(id) using index pk_doc_data ,constraint doc_data_doc_ware_unq unique(doc_id, ware_id) using index doc_data_doc_ware_unq ,constraint doc_data_qty_cost_both check ( qty>0 and cost_purchase>0 and cost_retail>0 or qty = 0 and cost_purchase = 0 and cost_retail=0 ) ); create descending index doc_data_id_desc on doc_data(id); commit; recreate table money_turnover_log( id dm_ids not null ,doc_id dm_ids ,agent_id dm_ids ,optype_id dm_ids ,cost_purchase dm_vals ,cost_retail dm_vals ,dts timestamp default 'now' ); recreate table money_saldo( agent_id dm_ids constraint pk_money_saldo primary key using index pk_money_saldo, cost_purchase dm_vals, cost_retail dm_vals ); recreate table wares( id dm_ids generated by default as identity constraint pk_wares primary key using index pk_wares ,group_id dm_ids ,numb dm_nums ,name dm_name ,price_purchase dm_cost ,price_retail dm_cost ,constraint wares_numb_unq unique(numb) using index wares_numb_unq ); create descending index wares_id_desc on wares(id); recreate table phrases( id dm_ids generated by default as identity constraint pk_phrases primary key using index pk_phrases ,pattern dm_name ,name dm_name ,constraint phrases_unq unique(pattern) using index phrases_unq ); create index phrases_name on phrases(name); create descending index phrases_id_desc on phrases(id); recreate table z_used_views( name dm_dbobj, constraint z_used_views_unq unique(name) using index z_used_views_unq); recreate table invnt_saldo( id dm_ids generated by default as identity constraint pk_invnt_saldo primary key using index pk_invnt_saldo ,qty_clo dm_qty default 0 ,qty_clr dm_qty default 0 ,qty_ord dm_qty default 0 ,qty_sup dm_qty default 0 ,qty_avl dm_qty default 0 ,qty_res dm_qty default 0 ,qty_inc dm_qty default 0 ,qty_out dm_qty default 0 ,cost_inc dm_cost default 0 ,cost_out dm_cost default 0 ,qty_acn computed by(qty_avl+qty_res) ,cost_acn computed by ( cost_inc - cost_out ) ,dts_edit timestamp default 'now' ,constraint invnt_saldo_acn_zero check (NOT (qty_acn = 0 and cost_acn<>0 or qty_acn<>0 and cost_acn=0 )) ); commit; recreate table qdistr( id dm_ids not null ,doc_id dm_ids ,ware_id dm_ids ,snd_optype_id dm_ids ,snd_id dm_ids ,snd_qty dm_qty ,rcv_doc_id bigint ,rcv_optype_id bigint ,rcv_id bigint ,rcv_qty numeric(12,3) ,snd_purchase dm_cost ,snd_retail dm_cost ,rcv_purchase dm_cost ,rcv_retail dm_cost ,trn_id bigint default current_transaction ,dts timestamp default 'now' ); create index qdistr_ware_sndop_rcvop on qdistr(ware_id, snd_optype_id, rcv_optype_id); create descending index qdistr_sndop_rcvop_sndid_desc on qdistr(snd_optype_id, rcv_optype_id, snd_id); commit; alter table qdistr add  constraint pk_qdistr primary key(id) using index pk_qdistr; commit; recreate table qstorned( id dm_ids not null ,doc_id dm_ids ,ware_id dm_ids ,snd_optype_id dm_ids ,snd_id dm_ids ,snd_qty dm_qty ,rcv_doc_id dm_ids ,rcv_optype_id dm_ids ,rcv_id dm_ids ,rcv_qty dm_qty ,snd_purchase dm_cost ,snd_retail dm_cost ,rcv_purchase dm_cost ,rcv_retail dm_cost ,trn_id bigint default current_transaction ,dts timestamp default 'now' ); create index qstorned_doc_id on qstorned(doc_id); create index qstorned_snd_id on qstorned(snd_id); create index qstorned_rcv_id on qstorned(rcv_id); alter table qstorned add  constraint pk_qdstorned primary key(id) using index pk_qdstorned; commit; recreate table pdistr( id dm_ids generated by default as identity constraint pk_pdistr primary key using index pk_pdistr ,agent_id dm_ids ,snd_optype_id dm_ids ,snd_id dm_ids ,snd_cost dm_qty ,rcv_optype_id dm_ids ,trn_id bigint default current_transaction ,constraint pdistr_snd_op_diff_rcv_op check( snd_optype_id is distinct from rcv_optype_id ) ); create index pdistr_snd_id on pdistr(snd_id); create index pdistr_sndop_rcvop_sndid_asc on pdistr (snd_optype_id, rcv_optype_id, snd_id); create descending index pdistr_sndop_rcvop_sndid_desc on pdistr (snd_optype_id, rcv_optype_id, snd_id); create index pdistr_agent_id on pdistr(agent_id); commit; recreate table pstorned( id dm_ids generated by default as identity constraint pk_pstorned primary key using index pk_pstorned ,agent_id dm_ids ,snd_optype_id dm_ids ,snd_id dm_ids ,snd_cost dm_cost ,rcv_optype_id dm_ids ,rcv_id dm_ids ,rcv_cost dm_cost ,trn_id bigint default current_transaction ,constraint pstorned_snd_op_diff_rcv_op check( snd_optype_id is distinct from rcv_optype_id ) ); create index pstorned_snd_id on pstorned(snd_id); create index pstorned_rcv_id on pstorned(rcv_id); recreate table rules_for_pdistr( mode dm_name ,snd_optype_id bigint ,rcv_optype_id dm_ids ,rows_to_multiply int default 10 ,constraint rules_for_pdistr_unq unique(snd_optype_id, rcv_optype_id) using index rules_for_pdistr_unq ); commit; recreate table doc_states( id dm_ids constraint pk_doc_states primary key using index pk_doc_states ,mcode dm_name ,name dm_name ,constraint doc_states_mcode_unq unique(mcode) using index doc_states_mcode_unq ,constraint doc_states_name_unq unique(name) using index doc_states_name_unq ); recreate table agents( id dm_ids generated by default as identity constraint pk_agents primary key using index pk_agents ,name dm_name ,is_customer dm_sign default 1 ,is_supplier dm_sign default 0 ,is_our_firm dm_sign default 0 ,constraint agents_mutual_excl check(  bin_xor( is_our_firm, bin_or(is_customer, is_supplier) )=1 ) ,constraint agents_name_unq unique(name) using index agents_name_unq ); create descending index agents_id_desc on agents(id); create index agents_is_supplier on agents(is_supplier); create index agents_is_our_firm on agents(is_our_firm); recreate table ware_groups( id dm_ids constraint pk_ware_groups primary key using index pk_ware_groups ,name dm_name ,descr blob ,constraint ware_groups_name_unq unique(name) using index ware_groups_name_unq ); recreate table semaphores( id dm_ids constraint pk_semaphores primary key using index pk_semaphores ,task dm_name ,constraint semaphores_task_unq unique(task) using index semaphores_task_unq ); commit; recreate table invnt_turnover_log( ware_id dm_ids ,qty_diff numeric(12,3) ,cost_diff numeric(12,2) ,doc_list_id bigint ,doc_pref dm_mcode ,doc_data_id bigint ,optype_id bigint ,id dm_ids not null ,dts_edit timestamp default 'now' ,att_id int default current_connection ,trn_id int default current_transaction ); create index invnt_turnover_log_ware_dd_id on invnt_turnover_log(ware_id, doc_data_id); recreate table business_ops( unit dm_unit, sort_prior int unique, info dm_info, mode dm_name, kind dm_name, random_selection_weight smallint, constraint bo_unit unique(unit) using index bo_unit_unq ); create index business_ops_rnd_wgth on business_ops(random_selection_weight); commit; recreate table fb_errors( fb_sqlcode int, fb_gdscode int, fb_mnemona varchar(31), fb_errtext varchar(100), constraint fb_errors_gds_code_unq unique(fb_gdscode) using index fb_errors_gds_code ); recreate table perf_log( id dm_ids ,unit dm_unit ,exc_unit char(1) ,fb_gdscode int ,trn_id bigint default current_transaction ,att_id int default current_connection ,elapsed_ms bigint ,info dm_info ,exc_info dm_info ,stack dm_stack ,ip varchar(15) ,dts_beg timestamp default 'now' ,dts_end timestamp ,aux1 double precision ,aux2 double precision ,dump_trn bigint default current_transaction ); create descending index perf_log_dts_beg_desc on perf_log(dts_beg); create descending index perf_log_unit on perf_log(unit, elapsed_ms); create descending index perf_log_trn_desc on perf_log(trn_id); create index perf_log_gdscode on perf_log(fb_gdscode); recreate global temporary table tmp$perf_log( id dm_ids ,id2 bigint ,unit dm_unit ,exc_unit char(1) ,fb_gdscode int ,trn_id bigint default current_transaction ,att_id int default current_connection ,elapsed_ms bigint ,info dm_info ,exc_info dm_info ,stack dm_stack ,ip varchar(15) ,dts_beg timestamp default 'now' ,dts_end timestamp ,aux1 double precision ,aux2 double precision ,dump_trn bigint default current_transaction ) on commit delete rows; create index tmp$perf_log_unit_trn_dts_end on tmp$perf_log(unit, trn_id, dts_end); recreate table mon_log( unit dm_unit ,fb_gdscode int ,elapsed_ms int ,trn_id bigint ,add_info dm_info ,rec_inserts bigint ,rec_updates bigint ,rec_deletes bigint ,rec_backouts bigint ,rec_purges bigint ,rec_expunges bigint ,rec_seq_reads bigint ,rec_idx_reads bigint ,rec_rpt_reads bigint ,bkv_reads bigint ,frg_reads bigint ,bkv_per_seq_idx_rpt computed by ( 1.00 * bkv_reads / nullif((rec_seq_reads + rec_idx_reads + rec_rpt_reads),0) ) ,frg_per_seq_idx_rpt computed by ( 1.00 * frg_reads / nullif((rec_seq_reads + rec_idx_reads + rec_rpt_reads),0) ) ,rec_locks bigint ,rec_waits bigint ,rec_confl bigint ,pg_reads bigint ,pg_writes bigint ,pg_fetches bigint ,pg_marks bigint ,mem_used bigint ,mem_alloc bigint ,server_pid bigint ,remote_pid bigint ,stat_id bigint ,dump_trn bigint default current_transaction ,ip varchar(15) ,usr dm_dbobj ,remote_process dm_info ,rowset bigint ,att_id bigint ,id dm_ids generated by default as identity constraint pk_mon_log primary key using index pk_mon_log ,dts timestamp default 'now' ,sec int ); create descending index mon_log_rowset_desc on mon_log(rowset); create index mon_log_gdscode on mon_log(fb_gdscode); create index mon_log_unit on mon_log(unit); commit; recreate table mon_log_table_stats( unit dm_unit ,fb_gdscode int ,trn_id bigint ,table_name dm_dbobj ,rec_inserts bigint ,rec_updates bigint ,rec_deletes bigint ,rec_backouts bigint ,rec_purges bigint ,rec_expunges bigint ,rec_seq_reads bigint ,rec_idx_reads bigint ,rec_rpt_reads bigint ,bkv_reads bigint ,frg_reads bigint ,bkv_per_seq_idx_rpt computed by ( 1.00 * bkv_reads / nullif((rec_seq_reads + rec_idx_reads + rec_rpt_reads),0) ) ,frg_per_seq_idx_rpt computed by ( 1.00 * frg_reads / nullif((rec_seq_reads + rec_idx_reads + rec_rpt_reads),0) ) ,rec_locks bigint ,rec_waits bigint ,rec_confl bigint ,stat_id bigint ,rowset bigint ,table_id smallint ,is_system_table smallint ,rel_type smallint ,att_id bigint default current_connection ,id dm_ids generated by default as identity constraint pk_mon_log_table_stats primary key using index pk_mon_log_table_stats ,dts timestamp default 'now' ); create descending index mon_log_table_stats_rowset on mon_log_table_stats(rowset); create index mon_log_table_stats_gdscode on mon_log_table_stats(fb_gdscode); create index mon_log_table_stats_tn_unit on mon_log_table_stats(table_name, unit); commit; alter table doc_list add constraint fk_doc_list_agents foreign key (agent_id) references agents(id) ; alter table doc_data add constraint fk_doc_data_doc_list foreign key (doc_id) references doc_list(id) on delete cascade using index fk_doc_data_doc_list ; alter table wares add constraint fk_wares_ware_groups foreign key (group_id) references ware_groups(id) ; commit; set term ^; create or alter function fn_infinity returns bigint deterministic as begin return 9223372036854775807; end ^ create or alter function fn_is_lock_trouble(a_gdscode int) returns boolean as begin return a_gdscode in (335544345, 335544878, 335544336,335544451 ); end ^ create or alter function fn_is_validation_trouble(a_gdscode int) returns boolean as begin return a_gdscode in ( 335544347,335544558 ); end ^ create or alter function fn_is_uniqueness_trouble(a_gdscode int) returns boolean as begin return a_gdscode in ( 335544665,335544349 ); end ^ create or alter function fn_halt_sign(a_gdscode int) returns dm_sign as declare function fn_halt_on_severe_error() returns dm_name deterministic as begin return rdb$get_context('USER_SESSION', 'HALT_TEST_ON_ERRORS'); end declare result dm_sign = 0; begin if ( a_gdscode  = 0 ) then result =1; if ( result = 0 and fn_halt_on_severe_error() containing 'CK'  ) then result = iif( a_gdscode in ( 335544347 ,335544558 ) ,1 ,0 ); if (result = 0 and fn_halt_on_severe_error() containing 'PK' ) then result = iif( a_gdscode in ( 335544665 ,335544349 ) ,1 ,0 ); if (result = 0 and fn_halt_on_severe_error() containing 'FK' ) then result = iif( a_gdscode in ( 335544466 ,335544838 ,335544839 ) ,1 ,0 ); if ( result = 0 and fn_halt_on_severe_error() containing 'ST'  ) then result = iif( a_gdscode = 335544842, 1, 0); return result; end ^ create or alter function fn_remote_process returns varchar(255) deterministic as begin return rdb$get_context('SYSTEM', 'CLIENT_PROCESS'); end ^ create or alter function fn_remote_address returns varchar(255) deterministic as begin return rdb$get_context('SYSTEM','CLIENT_ADDRESS'); end ^ create or alter function fn_is_snapshot returns boolean deterministic as begin return fn_remote_process() containing 'IBExpert' or rdb$get_context('SYSTEM','ISOLATION_LEVEL') is not distinct from upper('SNAPSHOT'); end ^ create or alter function fn_doc_open_state returns int deterministic  as declare v_id type of dm_ids = null; declare v_key type of dm_name = 'DOC_OPEN_STATE'; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_DOC_OPEN_STATE'); if (v_id is null) then begin v_stt='select s.id from doc_states s where s.mcode=:x'; execute statement (v_stt) ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'DOC_STATES', v_key ); end rdb$set_context('USER_SESSION', 'FN_DOC_OPEN_STATE', v_id); end return v_id; end ^ create or alter function fn_doc_fix_state returns int deterministic  as declare v_id type of dm_ids = null; declare v_key type of dm_name = 'DOC_FIX_STATE'; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_DOC_FIX_STATE'); if (v_id is null) then begin v_stt='select s.id from doc_states s where s.mcode=:x'; execute statement (v_stt) ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'DOC_STATES', v_key ); end rdb$set_context('USER_SESSION', 'FN_DOC_FIX_STATE', v_id); end return v_id; end ^ create or alter function fn_doc_clos_state returns int deterministic  as declare v_id type of dm_ids = null; declare v_key type of dm_name = 'DOC_CLOS_STATE'; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_DOC_CLOS_STATE'); if (v_id is null) then begin v_stt='select s.id from doc_states s where s.mcode=:x'; execute statement (v_stt) ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'DOC_STATES', v_key ); end rdb$set_context('USER_SESSION', 'FN_DOC_CLOS_STATE', v_id); end return v_id; end ^ create or alter function fn_doc_canc_state returns int deterministic  as declare v_id type of dm_ids = null; declare v_key type of dm_name = 'DOC_CANC_STATE'; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_DOC_CANC_STATE'); if (v_id is null) then begin v_stt='select s.id from doc_states s where s.mcode=:x'; execute statement (v_stt) ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'DOC_STATES', v_key ); end rdb$set_context('USER_SESSION', 'FN_DOC_CANC_STATE', v_id); end return v_id; end ^ create or alter function fn_oper_order_by_customer returns int deterministic  as declare v_id type of dm_ids = null; declare v_key dm_sign; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_OPER_ORDER_BY_CUSTOMER'); if (v_id is null) then begin v_stt = 'select o.id from optypes o where o.m_qty_clo = :x and o.m_qty_clr = 0'; v_key = 1; execute statement (v_stt) ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'OPTYPES', v_key ); end rdb$set_context('USER_SESSION', 'FN_OPER_ORDER_BY_CUSTOMER', v_id); end return v_id; end ^ create or alter function fn_oper_cancel_customer_order returns int deterministic  as declare v_id type of dm_ids = null; declare v_key dm_sign; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_OPER_CANCEL_CUSTOMER_ORDER'); if (v_id is null) then begin v_stt = 'select o.id from optypes o where o.m_qty_clr = :x'; v_key = 1; execute statement (v_stt) ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'OPTYPES', v_key ); end rdb$set_context('USER_SESSION', 'FN_OPER_CANCEL_CUSTOMER_ORDER', v_id); end return v_id; end ^ create or alter function fn_oper_order_for_supplier returns int deterministic  as declare v_id type of dm_ids = null; declare v_key dm_sign; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_OPER_ORDER_FOR_SUPPLIER'); if (v_id is null) then begin v_stt = 'select o.id from optypes o where o.m_qty_ord = :x'; v_key = 1; execute statement (v_stt) ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'OPTYPES', v_key ); end rdb$set_context('USER_SESSION', 'FN_OPER_ORDER_FOR_SUPPLIER', v_id); end return v_id; end ^ create or alter function fn_oper_invoice_get returns int deterministic  as declare v_id type of dm_ids = null; declare v_key1 dm_sign; declare v_key2 dm_sign; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_OPER_INVOICE_GET'); if (v_id is null) then begin v_stt = 'select o.id from optypes o where o.m_qty_ord=:x and o.m_qty_sup=:y'; v_key1 = -1; v_key2 = 1; execute statement (v_stt) ( x := :v_key1, y := :v_key2 ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'OPTYPES', 'm_qty_ord=-1 and m_qty_sup=1' ); end rdb$set_context('USER_SESSION', 'FN_OPER_INVOICE_GET', v_id); end return v_id; end ^ create or alter function fn_oper_invoice_add returns int deterministic  as declare v_id type of dm_ids = null; declare v_key dm_sign; declare v_key1 dm_sign; declare v_key2 dm_sign; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_OPER_INVOICE_ADD'); if (v_id is null) then begin v_stt = 'select o.id from optypes o where o.m_qty_avl=:x'; v_key = 1; execute statement (v_stt)  ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'OPTYPES', 'm_qty_sup=-1 and m_qty_avl=1' ); end rdb$set_context('USER_SESSION', 'FN_OPER_INVOICE_ADD', v_id); end return v_id; end ^ create or alter function fn_oper_retail_reserve returns int deterministic  as declare v_id type of dm_ids = null; declare v_key1 dm_sign; declare v_key2 dm_sign; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_OPER_RETAIL_RESERVE'); if (v_id is null) then begin v_stt = 'select o.id from optypes o where o.m_qty_avl=:x and o.m_qty_res=:y'; v_key1 = -1; v_key2 = 1; execute statement (v_stt) ( x := :v_key1, y := :v_key2 ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'OPTYPES', 'm_qty_avl=-1 and m_qty_res=1' ); end rdb$set_context('USER_SESSION', 'FN_OPER_RETAIL_RESERVE', v_id); end return v_id; end ^ create or alter function fn_oper_retail_realization returns int deterministic  as declare v_id type of dm_ids = null; declare v_key1 dm_sign; declare v_key2 dm_sign; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_OPER_RETAIL_REALIZATION'); if (v_id is null) then begin v_stt = 'select o.id from optypes o where o.m_qty_res=:x and o.m_cost_out=:y'; v_key1 = -1; v_key2 = 1; execute statement (v_stt) ( x := :v_key1, y := :v_key2 ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'OPTYPES', 'm_qty_res=-1 and m_cost_out=1' ); end rdb$set_context('USER_SESSION', 'FN_OPER_RETAIL_REALIZATION', v_id); end return v_id; end ^ create or alter function fn_oper_pay_to_supplier returns int deterministic  as declare v_id type of dm_ids = null; declare v_key dm_sign; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_OPER_PAY_TO_SUPPLIER'); if (v_id is null) then begin v_stt = 'select o.id from optypes o where o.m_supp_debt=:x'; v_key = -1; execute statement (v_stt) ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'OPTYPES', 'm_qty_res=-1 and m_cost_out=1' ); end rdb$set_context('USER_SESSION', 'FN_OPER_PAY_TO_SUPPLIER', v_id); end return v_id; end ^ create or alter function fn_oper_pay_from_customer returns int deterministic  as declare v_id type of dm_ids = null; declare v_key dm_sign; declare v_stt varchar(255); begin v_id=rdb$get_context('USER_SESSION', 'FN_OPER_PAY_FROM_CUSTOMER'); if (v_id is null) then begin v_stt = 'select o.id from optypes o where o.m_cust_debt=:x'; v_key = -1; execute statement (v_stt) ( x := :v_key ) into v_id; if (v_id is null) then begin exception ex_record_not_found using( 'OPTYPES', 'm_qty_res=-1 and m_cost_out=1' ); end rdb$set_context('USER_SESSION', 'FN_OPER_PAY_FROM_CUSTOMER', v_id); end return v_id; end ^ create or alter function fn_mcode_for_oper(a_oper_id dm_ids) returns dm_mcode deterministic as declare v_mnemonic_code type of dm_mcode; begin v_mnemonic_code = rdb$get_context('USER_SESSION','OPER_MCODE_'||:a_oper_id); if (v_mnemonic_code is null) then begin select o.mcode from optypes o where o.id = :a_oper_id into v_mnemonic_code; rdb$set_context('USER_SESSION','OPER_MCODE_'||:a_oper_id, v_mnemonic_code); end return v_mnemonic_code; end ^ create or alter function fn_get_stack( a_halt_due_to_error smallint default 0 ) returns dm_stack as declare v_call_stack dm_stack; declare function fn_internal_stack_disabled returns boolean deterministic as begin return ( coalesce(rdb$get_context('USER_SESSION','ENABLE_MON_QUERY'),0) = 0 ); end declare v_line dm_stack; declare v_this dm_dbobj = 'fn_get_stack'; begin v_call_stack=''; if ( fn_remote_process() NOT containing 'IBExpert' and a_halt_due_to_error = 0 and fn_internal_stack_disabled() ) then exit; for with recursive r as ( select 1 call_level, c.mon$statement_id as stt_id, c.mon$call_id as call_id, c.mon$object_name as obj_name, c.mon$object_type as obj_type, c.mon$source_line as src_row, c.mon$source_column as src_col from mon$call_stack c where c.mon$caller_id is null UNION ALL select r.call_level+1, c.mon$statement_id, c.mon$call_id, c.mon$object_name, c.mon$object_type, c.mon$source_line, c.mon$source_column from mon$call_stack c join r on c.mon$caller_id = r.call_id ) ,b as( select h.call_level, h.obj_name, h.obj_type, h.src_row, h.src_col from r h join mon$statements s on s.mon$statement_id = h.stt_id where s.mon$attachment_id = current_connection ) select obj_name, obj_type, src_row, src_col, call_level from b order by call_level as cursor c do begin v_line = trim(c.obj_name)||'('||c.src_row||':'||c.src_col||') ==> '; if ( char_length(v_call_stack) + char_length(v_line) >= 512 ) then exit; if ( v_call_stack NOT containing v_line and v_line NOT containing v_this||'(' ) then v_call_stack = v_call_stack || v_line; end if ( v_call_stack > '' ) then v_call_stack = substring( v_call_stack from 1 for char_length(v_call_stack)-5 ); return v_call_stack; end ^ create or alter procedure sp_halt_on_error( a_char char(1) default '1', a_gdscode bigint default null, a_trn_id bigint default null ) as declare v_curr_trn bigint; begin if ( fn_remote_process() NOT containing 'IBExpert' and NOT exists( select * from ext_stoptest ) ) then begin v_curr_trn = coalesce(a_trn_id, current_transaction); in autonomous transaction do begin insert into ext_stoptest values( :a_char || ascii_char(10)); end in autonomous transaction do begin insert into perf_log(unit, fb_gdscode, ip, trn_id, dts_end, elapsed_ms, stack, exc_unit ) values('sp_halt_on_error', :a_gdscode, fn_remote_address(), :v_curr_trn, 'now', -1, fn_get_stack(), :a_char ); end end end ^ create or alter procedure sp_flush_tmpperf_in_auton_tx( a_starter dm_unit, a_context_rows_cnt int, a_gdscode int default null ) as declare i smallint; declare v_id dm_ids; declare v_curr_tx int; declare v_exc_unit type of column perf_log.exc_unit; declare v_stack dm_stack; declare v_dbkey dm_dbkey; declare v_remote_addr varchar(15); begin v_curr_tx = current_transaction; v_remote_addr = fn_remote_address(); in autonomous transaction do begin insert into perf_log(unit, dts_beg, trn_id, ip) values( 't$perf-abend:' || :a_starter, 'now', :v_curr_tx, :v_remote_addr ) returning rdb$db_key into v_dbkey; i=0; while (i < a_context_rows_cnt) do begin v_exc_unit =  rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_XUNI'); if ( v_exc_unit = '#' ) then v_stack = fn_get_stack( fn_halt_sign(a_gdscode) ); else v_stack = null; insert into perf_log( id, unit, fb_gdscode, info, exc_unit, exc_info, dts_beg, dts_end, elapsed_ms, aux1, aux2, trn_id, ip, stack ) values( rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_ID'), rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_UNIT'), rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_GDS'), rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_INFO'), :v_exc_unit, rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_XNFO'), rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_BEG'), rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_END'), rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_MS'), rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_AUX1'), rdb$get_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_AUX2'), :v_curr_tx, :v_remote_addr, :v_stack ); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_ID', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_UNIT', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_GDS', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_INFO', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_XUNI', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_XNFO', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_BEG', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_END', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_MS', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_AUX1', null); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :i ||'_AUX2', null); i = i + 1; end update perf_log g set info = 'gds='|| :a_gdscode||', autonomous Tx: ' ||:i||' rows', dts_end = 'now', elapsed_ms = datediff( millisecond from dts_beg to cast('now' as timestamp) ), aux1 = :i where g.rdb$db_key = :v_dbkey; end end ^ create or alter procedure sp_flush_perf_log_on_abend( a_starter dm_unit, a_unit dm_unit, a_gdscode int default null, a_info dm_info default null, a_exc_info dm_info default null, a_aux1 dm_aux default null, a_aux2 dm_aux default null ) as declare v_cnt smallint; declare v_dts timestamp; declare v_info dm_info = ''; declare v_ctx_lim smallint; declare c_max_context_var_cnt int = 1000; declare c_std_user_exc int = 335544517; declare c_gen_inc_step_pf int = 20; declare v_gen_inc_iter_pf int; declare v_gen_inc_last_pf dm_ids; declare v_pf_new_id dm_ids; begin if ( rdb$get_context('USER_TRANSACTION', 'DONE_FLUSH_PERF_LOG_ON_ABEND') is NOT null ) then exit; v_ctx_lim = cast( rdb$get_context('USER_SESSION', 'CTX_LIMIT_FOR_FLUSH_PERF_LOG') as smallint ); if ( v_ctx_lim is null ) then begin select :c_max_context_var_cnt - sum(c) from ( select count(*) c from settings s where s.working_mode in( 'COMMON', rdb$get_context('USER_SESSION','WORKING_MODE') ) union all select count(*) from optypes union all select count(*) from doc_states union all select count(*) from rules_for_qdistr union all select count(*) from rules_for_pdistr ) into v_ctx_lim; v_ctx_lim = cast( (0.8 * v_ctx_lim) / 12.0 as smallint); rdb$set_context('USER_SESSION', 'CTX_LIMIT_FOR_FLUSH_PERF_LOG', v_ctx_lim); end c_gen_inc_step_pf = v_ctx_lim; v_gen_inc_iter_pf = c_gen_inc_step_pf; v_cnt = 0; v_dts = 'now'; for select unit ,coalesce( fb_gdscode, :a_gdscode, :c_std_user_exc ) as fb_gdscode ,info ,exc_unit ,iif( exc_unit is not null, coalesce( exc_info, :a_exc_info), null ) as exc_info ,dts_beg ,coalesce(dts_end, :v_dts) as dts_end ,iif(unit = :a_unit, coalesce(aux1, :a_aux1), aux1) as aux1 ,iif(unit = :a_unit, coalesce(aux2, :a_aux2), aux2) as aux2 from tmp$perf_log g as cursor c do begin if ( v_cnt < v_ctx_lim ) then begin v_info = coalesce(c.info, ''); if (c.unit = a_unit and c.exc_unit is NOT null ) then v_info = left(v_info || trim(iif( v_info>'', '; ', '')) || coalesce(a_info,''), 255); if ( v_gen_inc_iter_pf = c_gen_inc_step_pf ) then begin v_gen_inc_iter_pf = 1; v_gen_inc_last_pf = gen_id( g_perf_log, :c_gen_inc_step_pf ); end v_pf_new_id = v_gen_inc_last_pf - ( c_gen_inc_step_pf - v_gen_inc_iter_pf ); v_gen_inc_iter_pf = v_gen_inc_iter_pf + 1; rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_ID', v_pf_new_id); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_UNIT', c.unit); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_GDS', c.fb_gdscode ); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_INFO', v_info); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_XUNI', c.exc_unit); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_XNFO', c.exc_info); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_BEG', c.dts_beg); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_END', c.dts_end); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_MS', datediff(millisecond from c.dts_beg to c.dts_end)); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_AUX1', c.aux1); rdb$set_context('USER_SESSION', 'PERF_LOG_'|| :v_cnt ||'_AUX2', c.aux2); v_cnt = v_cnt + 1; end else begin execute procedure sp_flush_tmpperf_in_auton_tx(a_starter, v_cnt, a_gdscode); v_cnt = 0; end end if (v_cnt > 0) then begin execute procedure sp_flush_tmpperf_in_auton_tx( a_starter, v_cnt, a_gdscode); end rdb$set_context('USER_TRANSACTION', 'DONE_FLUSH_PERF_LOG_ON_ABEND','1'); end ^ create or alter procedure srv_fill_mon(a_rowset bigint default null) returns(rows_added int) as begin suspend; end ^ create or alter procedure srv_fill_tmp_mon( a_rowset dm_ids, a_ignore_system_tables smallint default 1, a_unit dm_unit default null, a_info dm_info default null, a_gdscode int default null ) returns( rows_added int ) as begin suspend; end ^ create or alter procedure srv_log_mon_for_traced_units( a_unit dm_unit, a_gdscode integer default null, a_info dm_info default null ) as declare v_rowset bigint; declare v_dummy bigint; begin if ( rdb$get_context('SYSTEM','ENGINE_VERSION') starting with '3.' and fn_remote_process() containing 'IBExpert' and  rdb$get_context('USER_SESSION','TRACED_UNITS') containing ','||a_unit||',' ) then begin v_rowset = rdb$get_context('USER_SESSION','MON_ROWSET_'||a_unit); if ( v_rowset is null  ) then begin v_rowset = gen_id(g_common,1); rdb$set_context('USER_SESSION','MON_ROWSET_'||a_unit, v_rowset); in autonomous transaction do select count(*) from srv_fill_tmp_mon ( :v_rowset ,1 ,:a_unit ) into v_dummy; end else begin rdb$set_context('USER_SESSION','MON_ROWSET_'||a_unit, null); in autonomous transaction do begin select count(*) from srv_fill_tmp_mon (:v_rowset ,1 ,:a_unit ,:a_info ,:a_gdscode ) into v_dummy; select count(*) from srv_fill_mon( :v_rowset ) into v_dummy; end end end end ^ create or alter procedure sp_add_perf_log ( a_is_unit_beginning dm_sign, a_unit dm_unit, a_gdscode integer default null, a_info dm_info default null, a_aux1 dm_aux default null, a_aux2 dm_aux default null ) as declare v_curr_tx bigint; declare v_dts timestamp; declare v_save_dts_beg timestamp; declare v_save_dts_end timestamp; declare v_save_gtt_cnt int; declare v_id dm_ids; declare v_unit dm_unit; declare v_info dm_info; declare c_gen_inc_step_pf int = 20; declare v_gen_inc_iter_pf int; declare v_gen_inc_last_pf dm_ids; declare v_pf_new_id dm_ids; begin v_curr_tx = current_transaction; v_dts = cast('now' as timestamp); execute procedure srv_log_mon_for_traced_units( a_unit, a_gdscode, a_info ); if ( not exists(select * from tmp$perf_log) ) then begin rdb$set_context('USER_SESSION','LOG_PERF_STARTED_BY', a_unit); a_is_unit_beginning = 1; end if ( a_is_unit_beginning = 1 ) then begin insert into tmp$perf_log( unit, info, ip, trn_id, dts_beg ) values( :a_unit, :a_info, fn_remote_address(), :v_curr_tx, :v_dts ); rdb$set_context('USER_TRANSACTION','TPLOG_LAST_UNIT', a_unit); rdb$set_context('USER_TRANSACTION','TPLOG_LAST_BEG', v_dts); rdb$set_context('USER_TRANSACTION','TPLOG_LAST_INFO', v_info); end else begin update tmp$perf_log t set info = left(coalesce( info, '' ) || coalesce( trim(iif( info>'', '; ', '') || :a_info), ''), 255), dts_end = :v_dts, elapsed_ms = datediff(millisecond from dts_beg to :v_dts), aux1 = :a_aux1, aux2 = :a_aux2 where t.unit = :a_unit and t.trn_id = :v_curr_tx and dts_end is NULL ; if ( a_unit = rdb$get_context('USER_SESSION','LOG_PERF_STARTED_BY') ) then begin v_gen_inc_iter_pf = c_gen_inc_step_pf; v_save_dts_beg = 'now'; v_save_gtt_cnt = 0; for select unit ,exc_unit ,fb_gdscode ,trn_id ,att_id ,elapsed_ms ,info ,exc_info ,stack ,ip ,dts_beg ,dts_end ,aux1 ,aux2 from tmp$perf_log g as cursor ct do begin if ( v_gen_inc_iter_pf = c_gen_inc_step_pf ) then begin v_gen_inc_iter_pf = 1; v_gen_inc_last_pf = gen_id( g_perf_log, :c_gen_inc_step_pf ); end v_pf_new_id = v_gen_inc_last_pf - ( c_gen_inc_step_pf - v_gen_inc_iter_pf ); v_gen_inc_iter_pf = v_gen_inc_iter_pf + 1; insert into perf_log( id ,unit, exc_unit ,fb_gdscode, trn_id, att_id, elapsed_ms ,info, exc_info, stack ,ip, dts_beg, dts_end ,aux1, aux2 ) values ( :v_pf_new_id ,ct.unit, ct.exc_unit ,ct.fb_gdscode, ct.trn_id, ct.att_id, ct.elapsed_ms ,ct.info, ct.exc_info, ct.stack ,ct.ip, ct.dts_beg, ct.dts_end ,ct.aux1, ct.aux2 ); v_save_gtt_cnt = v_save_gtt_cnt + 1; delete from tmp$perf_log where current of ct; end v_save_dts_end = 'now'; insert into perf_log( id, unit, info, dts_beg, dts_end, elapsed_ms, ip, aux1) values( iif( :v_gen_inc_iter_pf < :c_gen_inc_step_pf, :v_pf_new_id+1, gen_id( g_perf_log, 1 )  ), 't$perf-norm:'||:a_unit, 'ok saved '||:v_save_gtt_cnt||' rows', :v_save_dts_beg, :v_save_dts_end, datediff( millisecond from :v_save_dts_beg to :v_save_dts_end ), fn_remote_address(), :v_save_gtt_cnt ); end end end ^ create or alter procedure sp_upd_in_perf_log( a_unit dm_unit, a_gdscode int default null, a_info dm_info default null ) as begin update tmp$perf_log t set t.fb_gdscode = coalesce(t.fb_gdscode, :a_gdscode), t.info = coalesce( t.info, '' ) || coalesce( trim(iif( t.info>'', '; ', '') || :a_info), '') where t.unit = :a_unit and t.trn_id = current_transaction and t.dts_end is NULL and coalesce(t.info,'') NOT containing coalesce(trim(:a_info),''); end ^ create or alter procedure zdump4dbg( a_doc_list_id bigint default null, a_doc_data_id bigint default null, a_ware_id bigint default null ) as begin end ^ create or alter procedure sp_add_to_abend_log( a_exc_info dm_info, a_gdscode int default null, a_info dm_info default null, a_caller dm_unit default null, a_halt_due_to_error smallint default 0 ) as declare v_last_unit dm_unit; declare v_last_info dm_info; declare v_last_beg timestamp; declare v_last_end timestamp; begin if ( a_gdscode is NOT null and nullif(a_exc_info, '') is null ) then begin select coalesce(f.fb_mnemona, 'no-mnemona') from fb_errors f where f.fb_gdscode = :a_gdscode into a_exc_info; end v_last_unit = rdb$get_context('USER_TRANSACTION','TPLOG_LAST_UNIT'); if ( a_caller = v_last_unit ) then begin v_last_beg = rdb$get_context('USER_TRANSACTION','TPLOG_LAST_BEG'); v_last_end = cast('now' as timestamp); v_last_info = rdb$get_context('USER_TRANSACTION','TPLOG_LAST_INFO'); update tmp$perf_log t set fb_gdscode = :a_gdscode, info = :a_info, exc_unit = '#', dts_end = :v_last_end, elapsed_ms = datediff(millisecond from :v_last_beg to :v_last_end) where t.unit = rdb$get_context('USER_TRANSACTION','TPLOG_LAST_UNIT') and t.trn_id = current_transaction and dts_end is NULL; if ( row_count = 0 ) then insert into tmp$perf_log( unit ,fb_gdscode ,info ,exc_unit ,dts_beg ,dts_end ,elapsed_ms ,trn_id ) values ( :a_caller ,:a_gdscode ,:a_info ,'#' ,:v_last_beg ,:v_last_end ,datediff(millisecond from :v_last_beg to :v_last_end) ,current_transaction ); rdb$set_context('USER_TRANSACTION','TPLOG_LAST_UNIT', null); execute procedure sp_flush_perf_log_on_abend( rdb$get_context('USER_SESSION','LOG_PERF_STARTED_BY'), a_caller, a_gdscode, a_info, a_exc_info ); end if ( a_halt_due_to_error = 1 ) then begin execute procedure sp_halt_on_error('1', a_gdscode); if ( fn_halt_sign(a_gdscode)=1 ) then begin execute procedure zdump4dbg; end end end ^ set term ;^ commit; set term ^; create or alter procedure sp_check_ctx( ctx_nmspace_01 dm_ctxns, ctx_varname_01 dm_ctxnv, ctx_nmspace_02 dm_ctxns = '', ctx_varname_02 dm_ctxnv = '', ctx_nmspace_03 dm_ctxns = '', ctx_varname_03 dm_ctxnv = '', ctx_nmspace_04 dm_ctxns = '', ctx_varname_04 dm_ctxnv = '', ctx_nmspace_05 dm_ctxns = '', ctx_varname_05 dm_ctxnv = '', ctx_nmspace_06 dm_ctxns = '', ctx_varname_06 dm_ctxnv = '', ctx_nmspace_07 dm_ctxns = '', ctx_varname_07 dm_ctxnv = '', ctx_nmspace_08 dm_ctxns = '', ctx_varname_08 dm_ctxnv = '', ctx_nmspace_09 dm_ctxns = '', ctx_varname_09 dm_ctxnv = '', ctx_nmspace_10 dm_ctxns = '', ctx_varname_10 dm_ctxnv = '' ) as declare msg varchar(512) = ''; begin if (ctx_nmspace_01>'' and rdb$get_context( upper(ctx_nmspace_01), upper(ctx_varname_01) ) is null  ) then msg = msg||upper(ctx_nmspace_01)||':'||coalesce(upper(ctx_varname_01),'''null'''); if (ctx_nmspace_02>'' and rdb$get_context( upper(ctx_nmspace_02), upper(ctx_varname_02) ) is null  ) then msg = msg||iif(msg='', '', '; ')||upper(ctx_nmspace_02)||':'||coalesce(upper(ctx_varname_02),'''null'''); if (ctx_nmspace_03>'' and rdb$get_context( upper(ctx_nmspace_03), upper(ctx_varname_03) ) is null  ) then msg = msg||iif(msg='', '', '; ')||upper(ctx_nmspace_03)||':'||coalesce(upper(ctx_varname_03),'''null'''); if (ctx_nmspace_04>'' and rdb$get_context( upper(ctx_nmspace_04), upper(ctx_varname_04) ) is null  ) then msg = msg||iif(msg='', '', '; ')||upper(ctx_nmspace_04)||':'||coalesce(upper(ctx_varname_04),'''null'''); if (ctx_nmspace_05>'' and rdb$get_context( upper(ctx_nmspace_05), upper(ctx_varname_05) ) is null  ) then msg = msg||iif(msg='', '', '; ')||upper(ctx_nmspace_05)||':'||coalesce(upper(ctx_varname_05),'''null'''); if (ctx_nmspace_06>'' and rdb$get_context( upper(ctx_nmspace_06), upper(ctx_varname_06) ) is null  ) then msg = msg||iif(msg='', '', '; ')||upper(ctx_nmspace_06)||':'||coalesce(upper(ctx_varname_06),'''null'''); if (ctx_nmspace_07>'' and rdb$get_context( upper(ctx_nmspace_07), upper(ctx_varname_07) ) is null  ) then msg = msg||iif(msg='', '', '; ')||upper(ctx_nmspace_07)||':'||coalesce(upper(ctx_varname_07),'''null'''); if (ctx_nmspace_08>'' and rdb$get_context( upper(ctx_nmspace_08), upper(ctx_varname_08) ) is null  ) then msg = msg||iif(msg='', '', '; ')||upper(ctx_nmspace_08)||':'||coalesce(upper(ctx_varname_08),'''null'''); if (ctx_nmspace_09>'' and rdb$get_context( upper(ctx_nmspace_09), upper(ctx_varname_09) ) is null  ) then msg = msg||iif(msg='', '', '; ')||upper(ctx_nmspace_09)||':'||coalesce(upper(ctx_varname_09),'''null'''); if (ctx_nmspace_10>'' and rdb$get_context( upper(ctx_nmspace_10), upper(ctx_varname_10) ) is null  ) then msg = msg||iif(msg='', '', '; ')||upper(ctx_nmspace_10)||':'||coalesce(upper(ctx_varname_10),'''null'''); if (msg<>'') then begin execute procedure sp_add_to_abend_log( left( msg, 255 ), null, '', 'sp_check_ctx' ); exception ex_context_var_not_found using( msg ); end end ^ set term ;^ commit; set term ^; create or alter procedure sp_check_nowait_or_timeout as declare msg varchar(255); declare function fn_internal() returns int deterministic as begin return rdb$get_context('SYSTEM', 'LOCK_TIMEOUT'); end begin if ( fn_remote_process() containing 'IBExpert' ) then exit; if  ( fn_internal() < 0 ) then begin msg = 'NO WAIT or LOCK_TIMEOUT required!'; execute procedure sp_add_to_abend_log( msg, null, null, 'sp_check_nowait_or_timeout' ); exception ex_nowait_or_timeout_required; end end ^ set term ;^ commit; set term ^; create or alter procedure sp_check_to_stop_work as declare v_dts_end timestamp; begin if ( fn_remote_process() containing 'IBExpert' ) then exit; if ( rdb$get_context('USER_SESSION','PERF_WATCH_END') is null ) then begin select p.dts_end from perf_log p where p.unit = 'perf_watch_interval' and p.info containing 'active' order by dts_beg + 0 desc rows 1 into v_dts_end; rdb$set_context('USER_SESSION','PERF_WATCH_END', coalesce(v_dts_end, dateadd(3 hour to current_timestamp) ) ); end else begin v_dts_end = rdb$get_context('USER_SESSION','PERF_WATCH_END'); end if (  cast('now' as timestamp) > v_dts_end ) then begin execute procedure sp_halt_on_error('2', -1); in autonomous transaction do begin update perf_log p set p.info = 'closed' where p.unit = 'perf_watch_interval'; when any do begin end end exception ex_test_cancellation; end else if (exists( select * from ext_stoptest )) then exception ex_test_cancellation; end ^ create or alter procedure sp_init_ctx as declare v_name type of dm_name; declare v_context type of column settings.context; declare v_value type of dm_setting_value; declare v_counter int = 0; declare msg varchar(255); begin if (rdb$get_context('USER_SESSION','WORKING_MODE') is null) then begin rdb$set_context( 'USER_SESSION', 'WORKING_MODE', (select s.svalue from settings s where s.working_mode = 'INIT' and s.mcode = 'WORKING_MODE') ); end if ( rdb$get_context('USER_SESSION','WORKING_MODE') is not null and exists (select * from settings s where s.working_mode = rdb$get_context('USER_SESSION','WORKING_MODE') ) ) then begin for select upper(s.mcode), upper(s.context), s.svalue from settings s where s.context in('USER_SESSION','USER_TRANSACTION') and ( s.working_mode = rdb$get_context('USER_SESSION','WORKING_MODE') and s.init_on = 'connect' or s.working_mode = 'COMMON' ) into v_name, v_context, v_value do begin rdb$set_context(v_context, v_name, v_value); v_counter = v_counter + 1; end end if (v_counter = 0 and exists (select * from settings s) ) then begin msg = 'Context variable ''WORKING_MODE'' is invalid.'; execute procedure sp_add_to_abend_log( msg, null, null, 'sp_init_ctx' ); exception ex_bad_working_mode_value using ( coalesce( '>'||rdb$get_context('USER_SESSION','WORKING_MODE')||'<', '<null>') ); end end ^ create or alter procedure z_remember_view_usage ( a_view_for_search dm_dbobj, a_view_for_min_id dm_dbobj default null, a_view_for_max_id dm_dbobj default null ) as declare i smallint; declare v_ctxn dm_ctxnv; declare v_name dm_dbobj; begin end ^ create or alter function fn_get_random_id ( a_view_for_search dm_dbobj, a_view_for_min_id dm_dbobj default null, a_view_for_max_id dm_dbobj default null, a_raise_exc dm_sign default 1, a_can_skip_order_clause dm_sign default 0, a_find_using_desc_index dm_sign default 0 ) returns bigint as declare i smallint; declare v_stt varchar(255); declare id_min double precision; declare id_max double precision; declare v_rows int; declare id_random bigint; declare id_selected bigint = null; declare msg dm_info; declare v_info dm_info; declare v_this dm_dbobj = 'fn_get_random_id'; declare v_ctxn dm_ctxnv; declare v_name dm_dbobj; declare fn_internal_max_rows_usage int; begin v_this = trim(a_view_for_search); fn_internal_max_rows_usage = cast( rdb$get_context('USER_SESSION','RANDOM_SEEK_VIA_ROWS_LIMIT') as int); execute procedure z_remember_view_usage(a_view_for_search, a_view_for_min_id, a_view_for_max_id); a_view_for_min_id = coalesce( a_view_for_min_id, a_view_for_search ); a_view_for_max_id = coalesce( a_view_for_max_id, a_view_for_min_id, a_view_for_search ); if ( rdb$get_context('USER_TRANSACTION', upper(:a_view_for_min_id)||'_ID_MIN' ) is null or rdb$get_context('USER_TRANSACTION', upper(:a_view_for_max_id)||'_ID_MAX' ) is null ) then begin execute procedure sp_add_perf_log(1, a_view_for_min_id ); v_stt='select min(id)-0.5 from '|| a_view_for_min_id; execute statement (:v_stt) into id_min; execute procedure sp_add_perf_log(0, a_view_for_min_id, null, 'id_min='||coalesce(id_min,'<?>') ); if ( id_min is NOT null ) then begin execute procedure sp_add_perf_log(1, a_view_for_max_id ); v_stt='select max(id)+0.5 from '|| a_view_for_max_id; execute statement (:v_stt) into id_max; execute procedure sp_add_perf_log(0, a_view_for_max_id, null, 'id_max='||coalesce(id_max,'<?>') ); if ( id_max is NOT null  ) then begin rdb$set_context('USER_TRANSACTION', upper(:a_view_for_min_id)||'_ID_MIN', :id_min); rdb$set_context('USER_TRANSACTION', upper(:a_view_for_max_id)||'_ID_MAX', :id_max); if ( id_max - id_min < fn_internal_max_rows_usage ) then begin execute statement 'select count(*) from '||a_view_for_search into v_rows; rdb$set_context('USER_TRANSACTION', upper(:a_view_for_search)||'_COUNT', v_rows ); end end end end else begin id_min=cast( rdb$get_context('USER_TRANSACTION', upper(:a_view_for_min_id)||'_ID_MIN' ) as double precision); id_max=cast( rdb$get_context('USER_TRANSACTION', upper(:a_view_for_max_id)||'_ID_MAX' ) as double precision); v_rows=cast( rdb$get_context('USER_TRANSACTION', upper(:a_view_for_search)||'_COUNT') as int); end if ( id_max - id_min < fn_internal_max_rows_usage ) then begin v_stt='select id from '||a_view_for_search||' rows :x to :y'; id_random = ceiling( rand() * (v_rows) ); execute statement (:v_stt) (x := id_random, y := id_random) into id_selected; end else begin v_stt='select id from ' ||a_view_for_search ||iif(a_find_using_desc_index = 0, ' where id >= :x', ' where id <= :x'); if ( a_can_skip_order_clause = 0 ) then v_stt = v_stt || iif(a_find_using_desc_index = 0, ' order by id     ', ' order by id desc'); v_stt = v_stt || ' rows 1'; id_random = cast( id_min + rand() * (id_max - id_min) as bigint); execute statement (:v_stt) (x := id_random) into id_selected; end if ( id_selected is null and coalesce(a_raise_exc, 1) = 1 ) then begin v_info = 'view: '||:a_view_for_search; if ( id_min is NOT null ) then v_info = v_info || ', id_min=' || id_min || ', id_max='||id_max; else v_info = v_info || ' - EMPTY'; v_info = v_info ||', id_rnd='||coalesce(id_random,'<null>'); exception ex_can_not_select_random_id; end return id_selected; when any do begin execute procedure sp_add_to_abend_log( v_stt, gdscode, v_info, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_lock_selected_doc( doc_list_id type of dm_ids, a_view_for_search dm_dbobj, a_selected_doc_id type of dm_ids default null ) as declare v_dbkey dm_dbkey = null; declare v_id dm_ids; declare v_stt varchar(255); declare v_exc_info dm_info; declare v_info dm_info; declare v_this dm_dbobj = 'sp_lock_selected_doc'; begin v_info = 'doc_id='||coalesce(doc_list_id, '<?>')||', src='||a_view_for_search; execute procedure sp_add_perf_log(1, v_this, null, v_info); v_stt = 'select rdb$db_key from doc_list' ||' where ' ||' id = :x' ||' and ( :y is null' ||' or' ||' exists( select id from '||a_view_for_search||' v where v.id = :x )' ||')'; execute statement (v_stt) ( x := :doc_list_id, y := :a_selected_doc_id ) into v_dbkey; if ( v_dbkey is null ) then begin exception ex_no_doc_found_for_handling using( a_view_for_search, :doc_list_id ); end rdb$set_context('USER_SESSION','ADD_INFO','doc='||v_id||': try to lock'); select id from doc_list h where h.rdb$db_key = :v_dbkey for update with lock into v_id; rdb$set_context('USER_SESSION','ADD_INFO','doc='||v_id||': captured Ok'); execute procedure sp_add_perf_log(0, v_this); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_this ); exception; end end ^ create or alter procedure sp_cache_rules_for_distr( a_table dm_dbobj ) returns( mode dm_name, snd_optype_id  bigint, rcv_optype_id  bigint, rows_to_multiply int ) as declare v_ctx_prefix type of dm_ctxnv; declare v_stt varchar(255); declare i int; declare v_mode dm_name; declare v_snd_optype_id type of dm_ids; declare v_rcv_optype_id type of dm_ids; declare v_rows_to_multiply int; begin if ( upper(coalesce(a_table,'')) not in ( upper('QDISTR'), upper('PDISTR') ) ) then exception ex_bad_argument using( coalesce(a_table,'<null>'), 'sp_cache_rules_for_distr' ); v_ctx_prefix = 'MEM_TABLE_'||upper(a_table)||'_'; v_stt='select mode, snd_optype_id, rcv_optype_id' || iif( upper(a_table)=upper('QDISTR'),', storno_sub',', rows_to_multiply ' ) ||' from rules_for_'||a_table; if ( rdb$get_context('USER_SESSION', v_ctx_prefix||'CNT') is null ) then begin i = 1; for execute statement( v_stt ) into v_mode, v_snd_optype_id, v_rcv_optype_id, v_rows_to_multiply do begin rdb$set_context( 'USER_SESSION' ,v_ctx_prefix||i ,rpad( v_mode ,80,' ') || coalesce( cast(v_snd_optype_id as char(18)), rpad('', 18,' ') ) || coalesce( cast(v_rcv_optype_id as char(18)), rpad('', 18,' ') ) || coalesce( cast(v_rows_to_multiply as char(10)), rpad('', 10,' ') ) ); rdb$set_context('USER_SESSION', v_ctx_prefix||'CNT', i); i = i+1; end end i = 1; while ( i <= cast(rdb$get_context('USER_SESSION', v_ctx_prefix||'CNT') as int) ) do begin mode = trim( substring( rdb$get_context('USER_SESSION', v_ctx_prefix||i) from 1 for 80 ) ); snd_optype_id = cast( nullif(trim(substring( rdb$get_context('USER_SESSION', v_ctx_prefix||i) from 81 for 18 )), '') as dm_ids); rcv_optype_id = cast( nullif(trim(substring( rdb$get_context('USER_SESSION', v_ctx_prefix||i) from 99 for 18 )), '') as dm_ids); rows_to_multiply = cast( nullif(trim(substring( rdb$get_context('USER_SESSION', v_ctx_prefix||i) from 117 for 10 )), '') as int); suspend; i = i+1; end end ^ create or alter procedure sp_rules_for_qdistr returns( mode dm_name, snd_optype_id  bigint, rcv_optype_id  bigint, storno_sub smallint ) as begin for select p.mode,p.snd_optype_id, p.rcv_optype_id, p.rows_to_multiply from sp_cache_rules_for_distr('QDISTR') p into mode, snd_optype_id, rcv_optype_id, storno_sub do suspend; end ^ create or alter procedure sp_rules_for_pdistr returns( snd_optype_id  bigint, rcv_optype_id  bigint, rows_to_multiply int ) as begin for select p.snd_optype_id, p.rcv_optype_id, p.rows_to_multiply from sp_cache_rules_for_distr('PDISTR') p into snd_optype_id, rcv_optype_id, rows_to_multiply do suspend; end ^ create or alter view v_our_firm as select 1 id from rdb$database ^ create or alter procedure sp_multiply_rows_for_qdistr( a_doc_list_id dm_ids, a_optype_id dm_ids, a_clo_for_our_firm dm_ids, a_qty_sum dm_qty ) as declare c_gen_inc_step_qd int = 100; declare v_gen_inc_iter_qd int; declare v_gen_inc_last_qd dm_ids; declare v_doc_data_id dm_ids; declare v_ware_id dm_ids; declare v_qty_for_distr dm_qty; declare v_purchase_for_distr type of dm_cost; declare v_retail_for_distr type of dm_cost; declare v_rcv_optype_id type of dm_ids; declare n_rows_to_add int; declare v_qty_for_one_row type of dm_qty; declare v_qty_acc type of dm_qty; declare v_purchase_acc type of dm_cost; declare v_retail_acc type of dm_cost; declare v_dbkey dm_dbkey; declare v_info dm_info; declare v_this dm_dbobj = 'sp_multiply_rows_for_qdistr'; begin v_info = 'dh='||a_doc_list_id||', q_sum='||a_qty_sum; execute procedure sp_add_perf_log(1, v_this, null, v_info); v_gen_inc_iter_qd = 1; c_gen_inc_step_qd = (1 + a_qty_sum) * iif(a_clo_for_our_firm=1, 1, 2) + 1; v_gen_inc_last_qd = gen_id( g_qdistr, :c_gen_inc_step_qd ); for select r.rcv_optype_id, c.snd_id, c.id as ware_id, c.qty, c.cost_purchase, c.cost_retail from rules_for_qdistr r cross join tmp$shopping_cart c where r.snd_optype_id = :a_optype_id and ( :a_clo_for_our_firm = 0 or :a_clo_for_our_firm = 1 and r.rcv_optype_id <> 3300 ) into v_rcv_optype_id, v_doc_data_id, v_ware_id, v_qty_for_distr, v_purchase_for_distr, v_retail_for_distr do begin v_qty_acc = 0; v_purchase_acc = 0; v_retail_acc = 0; n_rows_to_add = ceiling( v_qty_for_distr ); while( n_rows_to_add > 0 ) do begin v_qty_for_one_row = iif( n_rows_to_add > v_qty_for_distr, n_rows_to_add - v_qty_for_distr, 1 ); insert into qdistr( id, doc_id, ware_id, snd_optype_id, rcv_optype_id, snd_id, snd_qty, snd_purchase, snd_retail) values( :v_gen_inc_last_qd - ( :c_gen_inc_step_qd - :v_gen_inc_iter_qd ), :a_doc_list_id, :v_ware_id, :a_optype_id, :v_rcv_optype_id, :v_doc_data_id, :v_qty_for_one_row, :v_purchase_for_distr * :v_qty_for_one_row / :v_qty_for_distr, :v_retail_for_distr * :v_qty_for_one_row / :v_qty_for_distr ) returning rdb$db_key, :v_qty_acc + snd_qty, :v_purchase_acc + snd_purchase, :v_retail_acc + snd_retail into v_dbkey, :v_qty_acc, :v_purchase_acc, :v_retail_acc ; n_rows_to_add = n_rows_to_add - 1; v_gen_inc_iter_qd = v_gen_inc_iter_qd + 1; if ( n_rows_to_add = 0 and ( v_qty_acc <> v_qty_for_distr or v_purchase_acc <> v_purchase_for_distr or v_retail_acc <> v_retail_for_distr ) ) then update qdistr q set q.snd_qty = q.snd_qty + ( :v_qty_for_distr - :v_qty_acc ), q.snd_purchase = q.snd_purchase + ( :v_purchase_for_distr - :v_purchase_acc ), q.snd_retail = q.snd_retail + ( :v_retail_for_distr - :v_retail_acc ) where q.rdb$db_key = :v_dbkey; else if ( v_gen_inc_iter_qd = c_gen_inc_step_qd ) then begin v_gen_inc_iter_qd = 1; v_gen_inc_last_qd = gen_id( g_qdistr, :c_gen_inc_step_qd ); end end end execute procedure sp_add_perf_log(0, v_this); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_multiply_rows_for_pdistr( a_doc_list_id dm_ids, a_agent_id dm_ids, a_optype_id dm_ids, a_cost_for_distr type of dm_cost ) as declare v_rcv_optype_id type of dm_ids; declare n_rows_to_add int; declare v_dbkey dm_dbkey; declare v_cost_acc type of dm_cost; declare v_cost_for_one_row type of dm_cost; declare v_cost_div int; declare v_id dm_ids; declare v_key type of dm_unit; declare v_info dm_info; declare v_this dm_dbobj = 'sp_multiply_rows_for_pdistr'; declare function fn_internal_min_cost_4_split returns int deterministic as begin return cast(rdb$get_context('USER_SESSION', 'C_MIN_COST_TO_BE_SPLITTED' ) as int); end begin v_info = 'dh='||a_doc_list_id||', op='||a_optype_id||', $='||a_cost_for_distr; execute procedure sp_add_perf_log(1, v_this, null, v_info); for select r.rcv_optype_id, iif( :a_cost_for_distr < fn_internal_min_cost_4_split(), 1, r.rows_to_multiply ) from sp_rules_for_pdistr r where r.snd_optype_id = :a_optype_id into v_rcv_optype_id, n_rows_to_add do begin v_cost_acc = 0; v_cost_div = round( a_cost_for_distr / n_rows_to_add, -2 ); while( v_cost_acc < a_cost_for_distr ) do begin v_cost_for_one_row = iif( a_cost_for_distr > v_cost_div, v_cost_div, a_cost_for_distr ); insert into pdistr( agent_id, snd_optype_id, snd_id, snd_cost, rcv_optype_id ) values( :a_agent_id, :a_optype_id, :a_doc_list_id, :v_cost_for_one_row, :v_rcv_optype_id ) returning rdb$db_key, :v_cost_acc + snd_cost into v_dbkey, :v_cost_acc ; if ( v_cost_acc > a_cost_for_distr ) then update pdistr p set p.snd_cost = p.snd_cost + ( :a_cost_for_distr - :v_cost_acc ) where p.rdb$db_key = :v_dbkey; end end execute procedure sp_add_perf_log(0, v_this); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_make_cost_storno( a_doc_id dm_ids, a_optype_id dm_ids, a_agent_id dm_ids, a_cost_diff dm_cost ) as declare v_pass smallint; declare not_storned_cost type of dm_cost; declare v_storned_cost type of dm_cost; declare v_storned_acc type of dm_cost; declare v_storned_doc_optype_id type of dm_ids; declare v_this dm_dbobj = 'sp_make_cost_storno'; declare v_rows int = 0; declare v_lock int = 0; declare v_skip int = 0; declare v_sign dm_sign; begin execute procedure sp_add_perf_log(1, v_this); v_storned_acc = 0; v_pass = 1; v_sign = iif( bin_and(current_transaction, 1)=0, 1, -1); while ( v_pass <= 2 ) do begin select r.snd_optype_id from sp_rules_for_pdistr r where iif( :v_pass = 1, r.rcv_optype_id, r.snd_optype_id ) = :a_optype_id into v_storned_doc_optype_id; not_storned_cost = iif( v_pass=1, :a_cost_diff, v_storned_acc); if ( not_storned_cost <= 0 ) then leave; for select p.rdb$db_key as dbkey, p.id, p.agent_id, p.snd_optype_id, p.snd_id, p.snd_cost as cost_to_be_storned, p.rcv_optype_id, :a_doc_id as rcv_id from pdistr p where p.agent_id = :a_agent_id and p.snd_optype_id = :v_storned_doc_optype_id order by p.snd_id+0 ,:v_sign * p.id as cursor c do begin v_rows = v_rows + 1; update pdistr set id = id where current of c; v_lock = v_lock + 1; v_storned_cost = minvalue( :not_storned_cost, c.cost_to_be_storned ); if ( v_pass = 1 ) then begin insert into pstorned( agent_id, snd_optype_id, snd_id, snd_cost, rcv_optype_id, rcv_id, rcv_cost ) values( c.agent_id, c.snd_optype_id, c.snd_id, :v_storned_cost, c.rcv_optype_id, c.rcv_id, :v_storned_cost ); end if ( c.cost_to_be_storned = v_storned_cost ) then delete from pdistr p where current of c; else update pdistr p set p.snd_cost = p.snd_cost - :v_storned_cost where current of c; not_storned_cost = not_storned_cost - v_storned_cost; if ( v_pass = 1 ) then v_storned_acc = v_storned_acc + v_storned_cost; if ( not_storned_cost <= 0 ) then leave; when any do begin if ( fn_is_lock_trouble( gdscode ) ) then v_skip = v_skip + 1; else exception; end end v_pass = v_pass + 1; end execute procedure sp_add_perf_log( 0, v_this, null, 'dh='||coalesce(:a_doc_id,'<?>') ||', pd ('||iif(:v_sign=1,'asc','dec')||'): capt='||:v_lock||', skip='||:v_skip||', scan='||:v_rows ); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||a_doc_id, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_kill_cost_storno( a_deleted_or_cancelled_doc_id dm_ids ) as declare agent_id dm_ids; declare snd_optype_id dm_ids; declare snd_id dm_ids; declare storned_cost dm_cost; declare rcv_optype_id dm_ids; declare v_msg dm_info; declare v_this dm_dbobj = 'sp_kill_cost_storno'; declare cs cursor for ( select s.agent_id, iif(:a_deleted_or_cancelled_doc_id = s.rcv_id, s.snd_optype_id, s.rcv_optype_id) as snd_optype_id, iif(:a_deleted_or_cancelled_doc_id = s.rcv_id, s.snd_id, s.rcv_id) as snd_id, iif(:a_deleted_or_cancelled_doc_id = s.rcv_id, s.rcv_cost, s.snd_cost) as storned_cost, iif(:a_deleted_or_cancelled_doc_id = s.rcv_id, s.rcv_optype_id, s.snd_optype_id) as rcv_optype_id from pstorned s where :a_deleted_or_cancelled_doc_id in (s.rcv_id, s.snd_id) ); begin execute procedure sp_add_perf_log(1, v_this); open cs; while (1=1) do begin fetch cs into agent_id, snd_optype_id, snd_id, storned_cost, rcv_optype_id; if ( row_count = 0) then leave; delete from pstorned where current of cs; insert into pdistr ( agent_id,   snd_optype_id,   snd_id,   snd_cost,       rcv_optype_id ) values( :agent_id, :snd_optype_id,  :snd_id,  :storned_cost,   :rcv_optype_id ); end close cs; delete from pdistr p where p.snd_id = :a_deleted_or_cancelled_doc_id; execute procedure sp_add_perf_log(0, v_this, null, 'doc_id='||a_deleted_or_cancelled_doc_id); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_msg, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure srv_log_dups_qd_qs( a_unit dm_dbobj, a_gdscode int, a_inserting_table dm_dbobj, a_inserting_id type of dm_ids, a_inserting_info dm_info ) as declare v_curr_tx bigint; declare v_get_stt varchar(512); declare v_put_stt varchar(512); declare v_doc_id dm_ids; declare v_ware_id dm_ids; declare v_snd_optype_id dm_ids; declare v_snd_id dm_ids; declare v_snd_qty dm_qty; declare v_rcv_optype_id dm_ids; declare v_rcv_id dm_ids; declare v_rcv_qty dm_qty; declare v_snd_purchase dm_cost; declare v_snd_retail dm_cost; declare v_rcv_purchase dm_cost; declare v_rcv_retail dm_cost; declare v_trn_id dm_ids; declare v_dts timestamp; begin v_curr_tx = current_transaction; v_get_stt = 'select doc_id, ware_id, snd_optype_id, snd_id, snd_qty,' ||'rcv_optype_id, rcv_id, rcv_qty, snd_purchase, snd_retail,' ||'rcv_purchase,rcv_retail,trn_id,dts' ||' from '|| a_inserting_table ||' q' ||' where q.id = :x'; v_put_stt = 'insert into ' || iif( upper(a_inserting_table)=upper('QDISTR'), 'ZQdistr', 'ZQStorned' ) ||'( id, doc_id, ware_id, snd_optype_id, snd_id, snd_qty,' ||'  rcv_optype_id, rcv_id, rcv_qty, snd_purchase, snd_retail,' ||'  rcv_purchase, rcv_retail, trn_id, dts, dump_att, dump_trn' ||') values ' ||'(:id,:doc_id,:ware_id,:snd_optype_id,:snd_id,:snd_qty,' ||' :rcv_optype_id,:rcv_id,:rcv_qty,:snd_purchase,:snd_retail,' ||' :rcv_purchase,:rcv_retail,:trn_id,:dts,:dump_att,:dump_trn' ||')'; execute statement (v_get_stt) ( x := a_inserting_id ) into v_doc_id, v_ware_id, v_snd_optype_id, v_snd_id, v_snd_qty, v_rcv_optype_id, v_rcv_id, v_rcv_qty, v_snd_purchase, v_snd_retail, v_rcv_purchase, v_rcv_retail, v_trn_id, v_dts; in autonomous transaction do begin insert into perf_log( unit, exc_unit, fb_gdscode, trn_id, info, stack ) values ( :a_unit, 'U', :a_gdscode, :v_curr_tx, :a_inserting_info, fn_get_stack( 1 ) ); execute statement ( v_put_stt ) ( id  := a_inserting_id, doc_id := v_doc_id, ware_id := v_ware_id, snd_optype_id := v_snd_optype_id, snd_id := v_snd_id, snd_qty := v_snd_qty, rcv_optype_id := v_rcv_optype_id, rcv_id := v_rcv_id, rcv_qty := v_rcv_qty, snd_purchase := v_snd_purchase, snd_retail := v_snd_retail, rcv_purchase := v_rcv_purchase, rcv_retail := v_rcv_retail, trn_id := v_trn_id, dts := v_dts, dump_att := current_connection, dump_trn := v_curr_tx ); end end ^ create or alter procedure sp_kill_qstorno_ret_qs2qd( a_doc_id dm_ids, a_old_optype dm_ids, a_deleting_doc dm_sign ) as declare c_gen_inc_step_nt int = 100; declare v_gen_inc_iter_nt int; declare v_gen_inc_last_nt dm_ids; declare v_this dm_dbobj = 'sp_kill_qstorno_ret_qs2qd'; declare v_call dm_dbobj; declare v_info dm_info; declare v_suffix dm_info; declare i int  = 0; declare k int  = 0; declare v_dd_id dm_ids; declare v_id dm_ids; declare v_doc_id dm_ids; declare v_doc_optype dm_ids; declare v_dd_ware_id dm_ids; declare v_dd_qty dm_qty; declare v_dd_cost dm_qty; declare v_doc_pref dm_mcode; declare v_snd_optype_id dm_ids; declare v_snd_id dm_ids; declare v_snd_qty dm_qty; declare v_rcv_optype_id dm_ids; declare v_rcv_id dm_ids; declare v_rcv_qty dm_qty; declare v_snd_purchase dm_cost; declare v_snd_retail dm_cost; declare v_rcv_purchase dm_cost; declare v_rcv_retail dm_cost; declare v_log_cursor dm_dbobj; declare v_ret_cursor dm_dbobj; declare v_oper_retail_realization dm_ids; declare v_old_rcv_optype type of dm_ids; declare c_dd_rows_for_doc cursor for ( select d.id, d.ware_id, d.qty, d.cost_purchase from doc_data d where d.doc_id = :a_doc_id ); declare c_qd_rows_for_doc cursor for ( select id from qdistr q where q.snd_optype_id = :a_old_optype and q.rcv_optype_id is not distinct from :v_old_rcv_optype and q.snd_id = :v_dd_id ); declare c_ret_qs2qd_by_rcv cursor for ( select qs.id ,qs.doc_id ,qs.snd_optype_id ,qs.snd_id ,qs.snd_qty ,qs.rcv_optype_id ,null as rcv_id ,null as rcv_qty ,qs.snd_purchase ,qs.snd_retail ,null as rcv_purchase ,null as rcv_retail from qstorned qs where qs.rcv_id = :v_dd_id ); declare c_ret_qs2qd_by_snd cursor for ( select qs.id ,qs.doc_id ,qs.snd_optype_id ,qs.snd_id ,qs.snd_qty ,qs.rcv_optype_id ,null as rcv_id ,null as rcv_qty ,qs.snd_purchase ,qs.snd_retail ,null as rcv_purchase ,null as rcv_retail from qstorned qs where qs.snd_id = :v_dd_id ); begin v_call = v_this; execute procedure sp_add_perf_log(1, v_call,null); v_oper_retail_realization = fn_oper_retail_realization(); v_doc_pref = fn_mcode_for_oper(a_old_optype); select r.rcv_optype_id from rules_for_qdistr r where r.snd_optype_id = :a_old_optype and coalesce(r.storno_sub,1) = 1 into v_old_rcv_optype; v_gen_inc_iter_nt = 1; v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); v_ret_cursor = iif(a_old_optype <> fn_oper_retail_realization(), 'c_ret_qs2qd_by_rcv', 'c_ret_qs2qd_by_snd'); open c_dd_rows_for_doc; while (1=1) do begin fetch c_dd_rows_for_doc into v_dd_id, v_dd_ware_id, v_dd_qty, v_dd_cost; if ( row_count = 0 ) then leave; if ( a_deleting_doc = 1 ) then begin v_log_cursor = 'c_qd_rows_for_doc'; open c_qd_rows_for_doc; while (1=1) do begin fetch c_qd_rows_for_doc into v_id; if ( row_count = 0 ) then leave; i = i+1; delete from qdistr where current of c_qd_rows_for_doc; end close c_qd_rows_for_doc; end if ( a_old_optype <> v_oper_retail_realization ) then open c_ret_qs2qd_by_rcv; else open c_ret_qs2qd_by_snd; v_log_cursor = v_ret_cursor; while (1=1) do begin if ( a_old_optype <> v_oper_retail_realization ) then fetch c_ret_qs2qd_by_rcv into v_id ,v_doc_id ,v_snd_optype_id ,v_snd_id ,v_snd_qty ,v_rcv_optype_id ,v_rcv_id ,v_rcv_qty ,v_snd_purchase ,v_snd_retail ,v_rcv_purchase ,v_rcv_retail; else fetch c_ret_qs2qd_by_snd into v_id ,v_doc_id ,v_snd_optype_id ,v_snd_id ,v_snd_qty ,v_rcv_optype_id ,v_rcv_id ,v_rcv_qty ,v_snd_purchase ,v_snd_retail ,v_rcv_purchase ,v_rcv_retail; if ( row_count = 0 ) then leave; i = i+1; v_suffix = ', id=' || :v_id || ', doc_id=' || :v_doc_id; v_call = v_this || ':try_del_qstorned'; v_info = v_ret_cursor || ': try DELETE in qStorned' || ' where ' || iif(v_ret_cursor = 'c_ret_qs2qd_by_rcv', 'rcv_id =', 'snd_id =') || :v_dd_id || v_suffix ; if ( a_old_optype <> v_oper_retail_realization ) then delete from qstorned where current of c_ret_qs2qd_by_rcv; else delete from qstorned where current of c_ret_qs2qd_by_snd; v_info = v_ret_cursor || ': try INSERT in qDistr' || v_suffix; v_call = v_this || ':try_ins_qdistr'; insert into qdistr( id, doc_id, ware_id, snd_optype_id, snd_id, snd_qty, rcv_optype_id, rcv_id, rcv_qty, snd_purchase, snd_retail, rcv_purchase, rcv_retail ) values( :v_id ,:v_doc_id ,:v_dd_ware_id ,:v_snd_optype_id ,:v_snd_id ,:v_snd_qty ,:v_rcv_optype_id ,:v_rcv_id ,:v_rcv_qty ,:v_snd_purchase ,:v_snd_retail ,:v_rcv_purchase ,:v_rcv_retail ); when any do begin if ( fn_is_uniqueness_trouble(gdscode) ) then execute procedure srv_log_dups_qd_qs( :v_call, gdscode, 'qdistr', :v_id, :v_info ); exception; end end if ( a_old_optype <> v_oper_retail_realization ) then close c_ret_qs2qd_by_rcv; else close c_ret_qs2qd_by_snd; insert into invnt_turnover_log( id ,ware_id ,qty_diff ,cost_diff ,doc_list_id ,doc_pref ,doc_data_id ,optype_id ) values ( :v_gen_inc_last_nt - ( :c_gen_inc_step_nt - :v_gen_inc_iter_nt ) ,:v_dd_ware_id ,-(:v_dd_qty) ,-(:v_dd_cost) ,:a_doc_id ,:v_doc_pref ,:v_dd_id ,:a_old_optype ); v_gen_inc_iter_nt = v_gen_inc_iter_nt + 1; if ( v_gen_inc_iter_nt = c_gen_inc_step_nt ) then begin v_gen_inc_iter_nt = 1; v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); end if ( a_deleting_doc = 1 ) then delete from doc_data where current of c_dd_rows_for_doc; end close c_dd_rows_for_doc; v_info = 'qs->qd: doc='||a_doc_id||', op='||a_old_optype ||', ret_rows='||i ||', cur='||v_ret_cursor ; v_call = v_this; execute procedure sp_add_perf_log(0, v_call,null,v_info); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_call, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_kill_qstorno_mov_qd2qs( a_doc_id dm_ids, a_old_optype dm_ids, a_new_optype dm_ids ) as declare c_gen_inc_step_nt int = 100; declare v_gen_inc_iter_nt int; declare v_gen_inc_last_nt dm_ids; declare v_this dm_dbobj = 'sp_kill_qstorno_mov_qd2qs'; declare v_info dm_info; declare v_curr_tx bigint; declare i int  = 0; declare v_dd_id dm_ids; declare v_dd_ware_id dm_qty; declare v_dd_qty dm_qty; declare v_dd_cost dm_qty; declare v_doc_pref dm_mcode; declare v_old_rcv_optype type of dm_ids; declare v_storno_sub smallint; declare v_id dm_ids; declare v_doc_id dm_ids; declare v_doc_optype dm_ids; declare v_ware_id dm_ids; declare v_snd_optype_id dm_ids; declare v_snd_id dm_ids; declare v_snd_qty dm_qty; declare v_rcv_optype_id dm_ids; declare v_rcv_id dm_ids; declare v_rcv_qty dm_qty; declare v_snd_purchase dm_cost; declare v_snd_retail dm_cost; declare v_rcv_purchase dm_cost; declare v_rcv_retail dm_cost; declare c_mov_from_qd2qs cursor for ( select qd.id ,qd.doc_id ,qd.ware_id ,qd.snd_optype_id ,qd.snd_id ,qd.snd_qty ,qd.rcv_optype_id ,qd.rcv_id ,qd.rcv_qty ,qd.snd_purchase ,qd.snd_retail ,qd.rcv_purchase ,qd.rcv_retail from qdistr qd where qd.snd_optype_id = :a_old_optype and qd.rcv_optype_id is not distinct from :v_old_rcv_optype and qd.snd_id = :v_dd_id ); begin execute procedure sp_add_perf_log(1, v_this); v_doc_pref = fn_mcode_for_oper(a_new_optype); v_gen_inc_iter_nt = 1; v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); for select d.id, r.rcv_optype_id, r.storno_sub, d.ware_id, d.qty,  d.cost_purchase from doc_data d cross join rules_for_qdistr r where d.doc_id = :a_doc_id and r.snd_optype_id = :a_old_optype into v_dd_id, v_old_rcv_optype, v_storno_sub, v_dd_ware_id, v_dd_qty, v_dd_cost do begin if ( coalesce(v_storno_sub,1) = 1 ) then begin insert into invnt_turnover_log( id ,ware_id ,qty_diff ,cost_diff ,doc_list_id ,doc_pref ,doc_data_id ,optype_id ) values ( :v_gen_inc_last_nt - ( :c_gen_inc_step_nt - :v_gen_inc_iter_nt ) ,:v_dd_ware_id ,:v_dd_qty ,:v_dd_cost ,:a_doc_id ,:v_doc_pref ,:v_dd_id ,:a_new_optype ); v_gen_inc_iter_nt = v_gen_inc_iter_nt + 1; if ( v_gen_inc_iter_nt = c_gen_inc_step_nt ) then begin v_gen_inc_iter_nt = 1; v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); end end open c_mov_from_qd2qs; while (1=1) do begin fetch c_mov_from_qd2qs into v_id ,v_doc_id ,v_ware_id ,v_snd_optype_id ,v_snd_id ,v_snd_qty ,v_rcv_optype_id ,v_rcv_id ,v_rcv_qty ,v_snd_purchase ,v_snd_retail ,v_rcv_purchase ,v_rcv_retail; if ( row_count = 0 ) then leave; i = i + 1; delete from qdistr where current of c_mov_from_qd2qs; v_info = 'qd->qs, c_mov_from_qd2qs: try ins qStorned.id='||:v_id; insert into qstorned( id, doc_id, ware_id, snd_optype_id, snd_id, snd_qty, rcv_optype_id, rcv_id, rcv_qty, snd_purchase, snd_retail, rcv_purchase, rcv_retail ) values( :v_id, :v_doc_id, :v_ware_id, :v_snd_optype_id, :v_snd_id, :v_snd_qty, :v_rcv_optype_id, :v_rcv_id, :v_rcv_qty, :v_snd_purchase, :v_snd_retail, :v_rcv_purchase, :v_rcv_retail ); when any do begin if ( fn_is_uniqueness_trouble(gdscode) ) then execute procedure srv_log_dups_qd_qs( :v_this, gdscode, 'qstorned', :v_id, :v_info ); exception; end end close c_mov_from_qd2qs; end v_info = 'qd->qs, doc='||a_doc_id||', rows='||i; execute procedure sp_add_perf_log(0, v_this,null,v_info); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'qs->qd, doc='||a_doc_id||': try ins qs.id='||coalesce(v_id,'<?>')||', v_dd_id='||coalesce(v_dd_id,'<?>'||', old_op='||a_old_optype ), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_kill_qstorno_handle_qd4dd ( a_doc_id dm_ids, a_old_optype dm_ids, a_new_optype dm_ids) as declare c_gen_inc_step_nt int = 100; declare v_gen_inc_iter_nt int; declare v_gen_inc_last_nt dm_ids; declare v_this dm_dbobj = 'sp_kill_qstorno_handle_qd4dd'; declare v_info dm_info; declare v_id dm_ids; declare v_snd_id dm_ids; declare v_dd_rows int  = 0; declare v_dd_qsum int = 0; declare v_del_sign dm_sign; declare v_qd_rows int = 0; declare v_qs_rows int = 0; declare v_dd_id dm_ids; declare v_dd_ware_id dm_qty; declare v_dd_qty dm_qty; declare v_dd_cost dm_qty; declare v_doc_pref dm_mcode; declare v_log_mult dm_sign; declare v_log_oper dm_ids; declare v_rcv_optype_id type of dm_ids; declare v_storno_sub smallint; declare c_qd_rows_for_doc cursor for ( select q.id, q.snd_id from qdistr q where q.snd_optype_id = :a_old_optype and q.rcv_optype_id is not distinct from :v_rcv_optype_id and q.snd_id = :v_dd_id ); declare c_qs_rows_for_doc cursor for ( select qs.id, qs.snd_id from qstorned qs where qs.snd_id = :v_dd_id ); begin v_info = iif( a_new_optype = fn_oper_cancel_customer_order(), 'DEL', 'UPD' ) || ' in qdistr, doc='||a_doc_id || ', old_op='||a_old_optype || iif( a_new_optype <> fn_oper_cancel_customer_order(), ', new_op='||a_new_optype, ''); execute procedure sp_add_perf_log(1, v_this, null, v_info); v_log_oper = iif( a_new_optype = fn_oper_invoice_get(), fn_oper_invoice_add(), a_new_optype); v_log_mult = iif( a_new_optype = fn_oper_invoice_get(), -1, 1); v_doc_pref = fn_mcode_for_oper(v_log_oper); v_del_sign = iif(a_new_optype = fn_oper_cancel_customer_order(), 1, 0); v_gen_inc_iter_nt = 1; v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); for select r.rcv_optype_id, r.storno_sub from rules_for_qdistr r where r.snd_optype_id = :a_old_optype into v_rcv_optype_id, v_storno_sub do begin for select d.id, d.ware_id, d.qty, d.cost_purchase from doc_data d where d.doc_id = :a_doc_id into v_dd_id, v_dd_ware_id, v_dd_qty, v_dd_cost do begin v_dd_rows = v_dd_rows + 1; v_dd_qsum = v_dd_qsum + v_dd_qty; if ( coalesce(v_storno_sub,1) = 1 ) then begin insert into invnt_turnover_log( id ,ware_id ,qty_diff ,cost_diff ,doc_list_id ,doc_pref ,doc_data_id ,optype_id ) values ( :v_gen_inc_last_nt - ( :c_gen_inc_step_nt - :v_gen_inc_iter_nt ) ,:v_dd_ware_id ,:v_log_mult * :v_dd_qty ,:v_log_mult * :v_dd_cost ,:a_doc_id ,:v_doc_pref ,:v_dd_id ,:v_log_oper ); v_gen_inc_iter_nt = v_gen_inc_iter_nt + 1; if ( v_gen_inc_iter_nt = c_gen_inc_step_nt ) then begin v_gen_inc_iter_nt = 1; v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); end end open c_qd_rows_for_doc; while (1=1) do begin fetch c_qd_rows_for_doc into v_id, v_snd_id; if ( row_count = 0 ) then leave; v_qd_rows = v_qd_rows+1; if ( v_del_sign = 1 ) then begin delete from qdistr q where current of c_qd_rows_for_doc; end else update qdistr q set q.snd_optype_id = :a_new_optype, q.trn_id = current_transaction, q.dts = 'now' where current of c_qd_rows_for_doc; end close c_qd_rows_for_doc; if ( v_del_sign = 1 ) then begin open c_qs_rows_for_doc; while (1=1) do begin fetch c_qs_rows_for_doc into v_id, v_snd_id; if ( row_count = 0 ) then leave; v_qs_rows = v_qs_rows+1; delete from qstorned where current of c_qs_rows_for_doc; end close c_qs_rows_for_doc; end end end execute procedure sp_add_perf_log(0, v_this, null, 'dd_qsum='||v_dd_qsum||', rows: dd='||v_dd_rows||', qd='||v_qd_rows||', qs='||v_qs_rows ); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_kill_qty_storno ( a_doc_id dm_ids, a_old_optype dm_ids, a_new_optype dm_ids, a_updating dm_sign, a_deleting dm_sign) as declare v_this dm_dbobj = 'sp_kill_qty_storno'; declare v_info dm_info; declare v_dbkey dm_dbkey; begin if ( NOT (a_deleting = 1 or a_updating = 1 and a_new_optype is distinct from a_old_optype) ) then exit; v_info = 'dh='|| a_doc_id ||' '||iif(a_updating=1,'UPD','DEL') ||iif(a_updating=1, ' old_op='||a_old_optype||' new_op='||a_new_optype, ' op='||a_old_optype); execute procedure sp_add_perf_log(1, v_this,null, v_info); if ( a_updating = 1 and a_new_optype is distinct from a_old_optype ) then begin if ( a_new_optype = fn_oper_cancel_customer_order() ) then begin execute procedure sp_kill_qstorno_handle_qd4dd( :a_doc_id, :a_old_optype, fn_oper_cancel_customer_order() ); end else if ( a_old_optype = fn_oper_retail_realization() and a_new_optype = fn_oper_retail_reserve() ) then execute procedure sp_kill_qstorno_ret_qs2qd( :a_doc_id, :a_old_optype, :a_deleting ); else if ( a_old_optype = fn_oper_retail_reserve() and a_new_optype = fn_oper_retail_realization() ) then execute procedure sp_kill_qstorno_mov_qd2qs( :a_doc_id, :a_old_optype, :a_new_optype); else execute procedure sp_kill_qstorno_handle_qd4dd( :a_doc_id, :a_old_optype, :a_new_optype ); end if ( a_deleting = 1 ) then begin execute procedure sp_kill_qstorno_ret_qs2qd( :a_doc_id, :a_old_optype, :a_deleting ); end execute procedure sp_add_perf_log(0, v_this); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure srv_find_qd_qs_mism( a_doc_list_id type of dm_ids, a_optype_id type of dm_ids, a_after_deleting_doc dm_sign ) as declare v_this dm_dbobj = 'srv_find_qd_qs_mism'; declare v_gdscode int; declare v_dd_mismatch_id bigint; declare v_dd_mismatch_qty dm_qty; declare v_qd_qs_orphan_src dm_dbobj; declare v_qd_qs_orphan_doc dm_ids; declare v_qd_qs_orphan_id dm_ids; declare v_qd_qs_orphan_sid dm_ids; declare v_qd_sum dm_qty; declare v_qs_sum dm_qty; declare v_dummy1 bigint; declare v_dummy2 bigint; declare v_info dm_info = ''; declare c_chk_violation_code int = 335544558; declare v_curr_tx bigint; declare v_dh_id dm_ids; declare v_dd_id dm_ids; declare v_ware_id dm_ids; declare v_dd_optype_id dm_ids; declare v_dd_qty dm_qty; declare v_all_qty_sum dm_qty; declare v_all_qd_sum dm_qty; declare v_all_qs_sum dm_qty; declare v_rcv_optype_id dm_ids; declare v_rows_handled int; declare c_qd_qs_orphans cursor for ( select r.doc_data_id, r.ware_id from tmp$result_set r where r.doc_id = :a_doc_list_id ); declare c_dd_qty_match_qd_qs_counts cursor for ( select f.dd_id, f.ware_id, f.dd_qty, f.qd_cnt, f.qs_cnt from ( select e.dd_id, e.ware_id, e.qty as dd_qty, e.qd_cnt, coalesce(sum(qs.snd_qty),0) as qs_cnt from ( select d.dd_id, d.ware_id, d.qty, coalesce(sum(qd.snd_qty),0) qd_cnt from ( select d.id as dd_id, d.ware_id, d.qty from doc_data d where d.doc_id  = :a_doc_list_id ) d left join qdistr qd on qd.snd_optype_id = iif(:a_optype_id=3400, 3300, :a_optype_id) and qd.rcv_optype_id is not distinct from :v_rcv_optype_id and qd.snd_id = d.dd_id group by d.dd_id, d.ware_id, d.qty ) e left join qstorned qs on (:a_optype_id <> 1100 and e.qty >= e.qd_cnt or :a_optype_id = 1100 and e.qd_cnt = 0) and qs.snd_id = e.dd_id group by e.dd_id, e.ware_id, e.qty, e.qd_cnt ) f ); begin v_info = 'dh='||a_doc_list_id||', op='||a_optype_id; execute procedure sp_add_perf_log(1, v_this); v_dd_mismatch_id = null; select r.rcv_optype_id from rules_for_qdistr r where r.snd_optype_id = :a_optype_id and coalesce(r.storno_sub,1)=1 into v_rcv_optype_id; if ( a_after_deleting_doc = 1 ) then begin select h.id from doc_list h where h.id = :a_doc_list_id into v_dh_id; if ( v_dh_id is NOT null or not exists(select * from tmp$result_set)  ) then exception ex_bad_argument using('a_after_deleting_doc', v_this) ; v_rows_handled = 0; open c_qd_qs_orphans; while ( v_dh_id is null ) do begin fetch c_qd_qs_orphans into v_dd_id, v_ware_id; if ( row_count = 0 ) then leave; v_rows_handled = v_rows_handled + 1; select first 1 'qdistr' as src, qd.doc_id, qd.snd_id, qd.id from qdistr qd where qd.snd_optype_id = :a_optype_id and qd.rcv_optype_id is not distinct from :v_rcv_optype_id and qd.snd_id = :v_dd_id into v_qd_qs_orphan_src, v_qd_qs_orphan_doc, v_qd_qs_orphan_sid, v_qd_qs_orphan_id; if ( v_qd_qs_orphan_id is null ) then select first 1 'qstorned' as src, qs.doc_id, qs.snd_id, qs.id from qstorned qs where qs.snd_id = :v_dd_id into v_qd_qs_orphan_src, v_qd_qs_orphan_doc, v_qd_qs_orphan_sid, v_qd_qs_orphan_id; if ( v_qd_qs_orphan_id is NOT null ) then begin v_info = trim(v_info) || ': orphan '||v_qd_qs_orphan_src||'.id='||v_qd_qs_orphan_id || ' for deleted doc='||v_qd_qs_orphan_doc || ', snd_id='||v_qd_qs_orphan_sid || ', ware='||v_ware_id; leave; end end close c_qd_qs_orphans; if ( v_qd_qs_orphan_id is null ) then v_info = trim(v_info)||': no data in qd+qs for deleted '||v_rows_handled||' rows'; end else begin v_all_qty_sum = 0; v_all_qd_sum = 0; v_all_qs_sum = 0; v_rows_handled = 0; open c_dd_qty_match_qd_qs_counts; while ( 1 = 1 ) do begin fetch c_dd_qty_match_qd_qs_counts into v_dd_id, v_ware_id, v_dd_qty, v_qd_sum, v_qs_sum; if (row_count = 0) then leave; v_rows_handled = v_rows_handled + v_qd_sum + v_qs_sum; if ( a_optype_id <> 1100 and v_dd_qty < v_qd_sum or a_optype_id = 1100 and v_qd_sum + v_qs_sum > 0 ) then begin v_dd_mismatch_id = v_dd_id; v_dd_mismatch_qty = v_dd_qty; leave; end v_all_qty_sum = v_all_qty_sum + v_dd_qty; v_all_qd_sum = v_all_qd_sum + v_qd_sum; v_all_qs_sum = v_all_qs_sum + v_qs_sum; end close c_dd_qty_match_qd_qs_counts; if ( v_dd_mismatch_id is NOT null ) then begin v_info=trim(v_info) || ': dd='||v_dd_mismatch_id || ', ware='||v_ware_id || ', rc='||v_rows_handled || ', qty='||cast(v_dd_mismatch_qty as int); if ( a_optype_id <> 1100 ) then v_info = v_info || ' - mism_count: qd_cnt='||cast(v_qd_sum as int) || iif( v_qs_sum >=0, ', qs_cnt='||cast(v_qs_sum as int), ', qs_cnt=n/a'); else v_info = v_info || ' - no_removal: qd_cnt='||cast(v_qd_sum as int) || iif( v_qs_sum >=0, ', qs_cnt='||cast(v_qs_sum as int), ', qs_cnt=n/a'); end else v_info = trim(v_info) ||', sum_qty='||cast(v_all_qty_sum as int) ||', cnt_qds='||cast((v_all_qd_sum + v_all_qs_sum) as int) ||', rc='||v_rows_handled; end if ( a_after_deleting_doc = 0 and v_dd_mismatch_id is NOT null or a_after_deleting_doc = 1 and v_qd_qs_orphan_id is NOT null ) then begin execute procedure zdump4dbg(:a_doc_list_id); if ( a_after_deleting_doc = 1) then exception ex_orphans_qd_qs_found using( a_doc_list_id, v_qd_qs_orphan_sid, v_qd_qs_orphan_src, v_qd_qs_orphan_id ); else exception ex_mism_doc_data_qd_qs using( v_dd_mismatch_id, v_dd_mismatch_qty, v_qd_sum, v_qs_sum ); end execute procedure sp_add_perf_log(0, v_this, null, 'ok, '||v_info); when any do begin v_gdscode = iif( :v_dd_mismatch_id is null, gdscode, :c_chk_violation_code); execute procedure sp_add_to_abend_log( '', :v_gdscode, 'MISMATCH, '||v_info, v_this, fn_halt_sign(:v_gdscode) ); exception; end end ^ create or alter procedure sp_add_money_log( a_doc_id dm_ids, a_old_mult dm_sign, a_old_agent_id dm_ids, a_old_op dm_ids, a_old_purchase type of dm_cost, a_old_retail type of dm_cost, a_new_mult dm_sign, a_new_agent_id dm_ids, a_new_op dm_ids, a_new_purchase type of dm_cost, a_new_retail type of dm_cost ) as begin if ( a_old_mult <> 0 ) then insert into money_turnover_log ( doc_id, agent_id, optype_id, cost_purchase, cost_retail ) values( :a_doc_id, :a_old_agent_id, :a_old_op, -:a_old_purchase, -:a_old_retail ); if ( a_new_mult <> 0  ) then insert into money_turnover_log ( doc_id, agent_id, optype_id, cost_purchase, cost_retail ) values( :a_doc_id, :a_new_agent_id, :a_new_op, :a_new_purchase, :a_new_retail ); end ^ create or alter procedure sp_lock_dependent_docs( a_base_doc_id dm_ids, a_base_doc_oper_id dm_ids default null ) as declare v_rcv_optype_id dm_ids; declare v_dependend_doc_id dm_ids; declare v_dependend_doc_state dm_ids; declare v_catch_bitset bigint; declare v_dbkey dm_dbkey; declare v_info dm_info; declare v_list dm_info; declare v_this dm_dbobj = 'sp_lock_dependent_docs'; begin v_info = 'base_doc='||a_base_doc_id; execute procedure sp_add_perf_log(1, v_this, null, v_info); if ( a_base_doc_oper_id is null ) then select h.optype_id from doc_list h where h.id = :a_base_doc_id into a_base_doc_oper_id; v_rcv_optype_id = decode(a_base_doc_oper_id, fn_oper_invoice_add(),  fn_oper_retail_reserve(), fn_oper_order_for_supplier(), fn_oper_invoice_get(), null ); delete from tmp$dep_docs d where d.base_doc_id = :a_base_doc_id; for select x.dependend_doc_id, h.state_id, h.rdb$db_key from ( select q.rcv_doc_id dependend_doc_id from qstorned q where q.doc_id = :a_base_doc_id and q.snd_optype_id = :a_base_doc_oper_id and q.rcv_optype_id = :v_rcv_optype_id group by 1 ) x join doc_list h on x.dependend_doc_id = h.id into v_dependend_doc_id, v_dependend_doc_state, v_dbkey do begin v_info = 'try lock dependent doc_id='||v_dependend_doc_id; select h.rdb$db_key from doc_list h where h.rdb$db_key = :v_dbkey for update with lock into v_dbkey; begin insert into tmp$dep_docs( base_doc_id, dependend_doc_id, dependend_doc_state) values( :a_base_doc_id, :v_dependend_doc_id, :v_dependend_doc_state ); when any do begin if ( NOT fn_is_uniqueness_trouble(gdscode) ) then exception; end end end v_catch_bitset = cast(rdb$get_context('USER_SESSION','QMISM_VERIFY_BITSET') as bigint); if ( bin_and( v_catch_bitset, 7 ) > 0 ) then begin v_list=left( ( select list(d.dependend_doc_id) from tmp$dep_docs d where d.base_doc_id=:a_base_doc_id ), 255-char_length(v_info)-15); v_info = 'depDocsLst='|| coalesce(nullif(v_list,''),'<empty>'); end else begin v_info = 'depDocsCnt='||( select count(*) from tmp$dep_docs d where d.base_doc_id=:a_base_doc_id ); end execute procedure sp_add_perf_log(0, v_this, null, v_info ); when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_get_clo_for_invoice( a_selected_doc_id dm_ids ) returns ( clo_doc_id type of dm_ids, clo_agent_id type of dm_ids ) as begin suspend; end ^ set term ;^ commit; set term ^; create or alter procedure srv_check_neg_remainders( a_doc_list_id dm_ids, a_optype_id dm_ids ) as declare v_id bigint; declare v_catch_bitset bigint; declare v_curr_tx bigint; declare c_chk_violation_code int = 335544558; declare v_msg dm_info = ''; declare v_info dm_info = ''; declare v_this dm_dbobj = 'srv_check_neg_remainders'; begin v_catch_bitset = cast(rdb$get_context('USER_SESSION','QMISM_VERIFY_BITSET') as bigint); if ( bin_and( v_catch_bitset, 2 ) = 0 ) then exit; execute procedure sp_add_perf_log(1, v_this); v_msg ='dh='||:a_doc_list_id || ', op='||fn_mcode_for_oper( :a_optype_id ); v_id = null; select first 1 n.ware_id ,:v_msg || ', w='||n.ware_id||', dd='||n.dd_id || ', neg:' || trim( trailing from iif( n.qty_ord<0,' q_ord='||n.qty_ord,'' ) ) || trim( trailing from iif( n.qty_sup<0,' q_sup='||n.qty_sup,'' ) ) || trim( trailing from iif( n.qty_avl<0,' q_avl='||n.qty_avl,'' ) ) || trim( trailing from iif( n.qty_res<0,' q_res='||n.qty_res,'' ) ) || trim( trailing from iif( n.qty_inc<0,' q_inc='||n.qty_inc,'' ) ) || trim( trailing from iif( n.qty_out<0,' q_out='||n.qty_out,'' ) ) || trim( trailing from iif( n.qty_clo<0,' q_clo='||n.qty_clo,'' ) ) || trim( trailing from iif( n.qty_clr<0,' q_clr='||n.qty_clr,'' ) ) || trim( trailing from iif( n.qty_acn<0,' q_acn='||n.qty_acn,'' ) ) || trim( trailing from iif( n.cost_acn<0,' $_acn='||n.cost_acn,'' ) ) from ( select ng.ware_id ,min(ng.doc_data_id) as dd_id ,sum(o.m_qty_clo * ng.qty_diff) qty_clo ,sum(o.m_qty_clr * ng.qty_diff) qty_clr ,sum(o.m_qty_ord * ng.qty_diff) qty_ord ,sum(o.m_qty_sup * ng.qty_diff) qty_sup ,sum(o.m_qty_avl * ng.qty_diff) qty_avl ,sum(o.m_qty_res * ng.qty_diff) qty_res ,sum(o.m_cost_inc * ng.qty_diff) qty_inc ,sum(o.m_cost_out * ng.qty_diff) qty_out ,sum(o.m_cost_inc * ng.cost_diff) cost_inc ,sum(o.m_cost_out * ng.cost_diff) cost_out ,sum(o.m_qty_avl * ng.qty_diff) + sum(o.m_qty_res * ng.qty_diff) qty_acn ,sum(o.m_cost_inc * ng.cost_diff) - sum(o.m_cost_out * ng.cost_diff) cost_acn from invnt_turnover_log ng join optypes o on ng.optype_id=o.id join doc_data d on ng.ware_id = d.ware_id where d.doc_id = :a_doc_list_id group by ng.ware_id ) n where n.qty_ord<0 or n.qty_sup<0 or n.qty_avl<0 or n.qty_res<0 or n.qty_inc<0 or n.qty_out<0 or n.qty_clo<0 or n.qty_clr<0 or n.qty_acn<0 or n.cost_acn<0 into v_id, v_info; if ( v_id is not null) then begin v_curr_tx = current_transaction; in autonomous transaction do begin insert into perf_log( unit, exc_unit, fb_gdscode, trn_id, info, exc_info, stack, dump_trn ) values ( :v_this, '!', :c_chk_violation_code, :v_curr_tx, :v_info, :v_info, :v_this, current_transaction ); execute procedure sp_halt_on_error('5', :c_chk_violation_code, :v_curr_tx); end execute procedure sp_add_to_abend_log( 'ex_neg_remainders_encountered', :c_chk_violation_code, v_info, v_this, 1 ); execute procedure zdump4dbg; exception ex_neg_remainders_encountered using( v_id, v_info ); end execute procedure sp_add_perf_log(0, v_this,null, 'ok, '||v_msg); when any do begin exception; end end ^ set term ;^ commit; create or alter view v_cancel_client_order as select h.id from doc_list h where h.optype_id = 1000 ; create or alter view v_cancel_supplier_order as select h.id from doc_list h where h.optype_id = 1200 ; create or alter view v_cancel_supplier_invoice as select h.id from doc_list h where h.optype_id = 2000 ; create or alter view v_add_invoice_to_stock as select h.id from doc_list h where h.optype_id = 2000 ; create or alter view v_cancel_adding_invoice as select h.id from doc_list h where h.optype_id = 2100 ; create or alter view v_cancel_customer_reserve as select h.id from doc_list h where h.optype_id = 3300 ; create or alter view v_reserve_write_off as select h.id, h.agent_id, h.state_id, h.dts_open, h.dts_clos, h.cost_retail from doc_list h where h.optype_id = 3300 ; create or alter view v_cancel_write_off as select h.id from doc_list h where h.optype_id = 3400 ; create or alter view v_cancel_payment_to_supplier as select h.id, h.agent_id, h.cost_purchase from doc_list h where h.optype_id = 4000 ; create or alter view v_cancel_customer_prepayment as select h.id, h.agent_id, h.cost_retail from doc_list h where h.optype_id = 5000 ; create or alter view v_all_customers as select a.id from agents a where a.is_customer=1 ; create or alter view v_all_suppliers as select a.id from agents a where a.is_supplier=1 ; create or alter view v_our_firm as select a.id from agents a where a.is_our_firm=1 ; create or alter view v_all_wares as select a.id from wares a where not exists(select * from tmp$shopping_cart c where c.id = a.id order by c.id) ; create or alter view v_random_find_avl_res as select w.id from wares w where not exists(select * from tmp$shopping_cart c where c.id = w.id order by c.id) and exists( select * from qdistr q where q.ware_id = w.id and q.snd_optype_id = 2100 and q.rcv_optype_id = 3300 order by ware_id, snd_optype_id, rcv_optype_id ); create or alter view v_any_id_avl_res as select x.ware_id from qdistr x where x.snd_optype_id = 2100 and x.rcv_optype_id = 3300 order by ware_id, snd_optype_id, rcv_optype_id rows 1 ; create or alter view v_min_id_avl_res as select w.id from wares w where exists( select * from qdistr q where q.ware_id = w.id and q.snd_optype_id = 2100 and q.rcv_optype_id = 3300 order by ware_id, snd_optype_id, rcv_optype_id ) order by w.id asc rows 1 ; create or alter view v_max_id_avl_res as select w.id from wares w where exists( select * from qdistr q where q.ware_id = w.id and q.snd_optype_id = 2100 and q.rcv_optype_id = 3300 order by ware_id, snd_optype_id, rcv_optype_id ) order by w.id desc rows 1 ; create or alter view v_random_find_clo_ord as select w.id from wares w where not exists(select * from tmp$shopping_cart c where c.id = w.id order by c.id) and exists( select * from qdistr q where q.ware_id = w.id and q.snd_optype_id = 1000 and q.rcv_optype_id = 1200 order by ware_id, snd_optype_id, rcv_optype_id ); create or alter view v_any_id_clo_ord as select x.ware_id from qdistr x where x.snd_optype_id = 1000 and x.rcv_optype_id = 1200 order by ware_id, snd_optype_id, rcv_optype_id rows 1 ; create or alter view v_min_id_clo_ord as select w.id from wares w where exists( select * from qdistr q where q.ware_id = w.id and q.snd_optype_id = 1000 and q.rcv_optype_id = 1200 order by ware_id, snd_optype_id, rcv_optype_id ) order by w.id asc rows 1 ; create or alter view v_max_id_clo_ord as select w.id from wares w where exists( select * from qdistr q where q.ware_id = w.id and q.snd_optype_id = 1000 and q.rcv_optype_id = 1200 order by ware_id, snd_optype_id, rcv_optype_id ) order by w.id desc rows 1 ; create or alter view v_random_find_ord_sup as select w.id from wares w where not exists(select * from tmp$shopping_cart c where c.id = w.id order by c.id) and exists( select * from qdistr q where q.ware_id = w.id and q.snd_optype_id = 1200 and q.rcv_optype_id = 2000 order by ware_id, snd_optype_id, rcv_optype_id ); create or alter view v_any_id_ord_sup as select x.ware_id from qdistr x where x.snd_optype_id = 1200 and x.rcv_optype_id = 2000 order by ware_id, snd_optype_id, rcv_optype_id rows 1 ; create or alter view v_min_id_ord_sup as select w.id from wares w where exists( select * from qdistr q where q.ware_id = w.id and q.snd_optype_id = 1200 and q.rcv_optype_id = 2000 order by ware_id, snd_optype_id, rcv_optype_id ) order by w.id asc rows 1 ; create or alter view v_max_id_ord_sup as select w.id from wares w where exists( select * from qdistr q where q.ware_id = w.id and q.snd_optype_id = 1200 and q.rcv_optype_id = 2000 order by ware_id, snd_optype_id, rcv_optype_id ) order by w.id desc rows 1 ; create or alter view v_random_find_clo_res as select h.id from doc_list h join doc_data d on h.id = d.doc_id where h.optype_id = 1000 and exists( select * from qdistr q where q.snd_optype_id = 1000 and q.rcv_optype_id = 3300 and q.snd_id = d.id order by q.snd_optype_id desc, q.rcv_optype_id desc, q.snd_id desc ) ; create or alter view v_min_id_clo_res as select h.id from doc_list h join doc_data d on h.id = d.doc_id where h.optype_id = 1000 and exists( select * from qdistr q where q.snd_optype_id = 1000 and q.rcv_optype_id = 3300 and q.snd_id = d.id order by q.snd_optype_id desc, q.rcv_optype_id desc ) order by h.id rows 1 ; create or alter view v_max_id_clo_res as select h.id from doc_list h join doc_data d on h.id = d.doc_id where h.optype_id = 1000 and exists( select * from qdistr q where q.snd_optype_id = 1000 and q.rcv_optype_id = 3300 and q.snd_id = d.id order by q.snd_optype_id desc, q.rcv_optype_id desc, q.snd_id desc ) order by h.id desc rows 1; create or alter view v_random_find_non_paid_invoice as select p.snd_id as id from pdistr p where p.snd_optype_id = 2100 and p.rcv_optype_id = 4000 ; create or alter view v_min_non_paid_invoice as select p.snd_id as id from pdistr p where p.snd_optype_id = 2100 and p.rcv_optype_id = 4000 order by snd_id rows 1 ; create or alter view v_max_non_paid_invoice as select p.snd_id as id from pdistr p where p.snd_optype_id = 2100 and p.rcv_optype_id = 4000 order by p.snd_optype_id desc, p.rcv_optype_id desc, p.snd_id desc rows 1 ; create or alter view v_random_find_non_paid_realizn as select p.snd_id as id from pdistr p where p.snd_optype_id = 3400 and p.rcv_optype_id = 5000 ; create or alter view v_min_non_paid_realizn as select p.snd_id as id from pdistr p where p.snd_optype_id = 3400 and p.rcv_optype_id = 5000 order by snd_id rows 1 ; create or alter view v_max_non_paid_realizn as select p.snd_id as id from pdistr p where p.snd_optype_id = 3400 and p.rcv_optype_id = 5000 order by p.snd_optype_id desc, p.rcv_optype_id desc, p.snd_id desc rows 1 ; create or alter view v_saldo_invnt as select ng.ware_id ,sum(o.m_qty_clo * ng.qty_diff) qty_clo ,sum(o.m_qty_clr * ng.qty_diff) qty_clr ,sum(o.m_qty_ord * ng.qty_diff) qty_ord ,sum(o.m_qty_sup * ng.qty_diff) qty_sup ,sum(o.m_qty_avl * ng.qty_diff) qty_avl ,sum(o.m_qty_res * ng.qty_diff) qty_res ,sum(o.m_cost_inc * ng.qty_diff) qty_inc ,sum(o.m_cost_out * ng.qty_diff) qty_out ,sum(o.m_cost_inc * ng.cost_diff) cost_inc ,sum(o.m_cost_out * ng.cost_diff) cost_out ,sum(o.m_qty_avl * ng.qty_diff) + sum(o.m_qty_res * ng.qty_diff) qty_acn ,sum(o.m_cost_inc * ng.cost_diff) - sum(o.m_cost_out * ng.cost_diff) cost_acn from invnt_turnover_log ng join optypes o on ng.optype_id + 0 = o.id + 0 group by 1 ; commit; create or alter view v_doc_detailed as select h.id doc_id, h.optype_id, o.mcode as oper, h.base_doc_id, d.id doc_data_id, d.ware_id, d.qty, coalesce(d.cost_purchase, h.cost_purchase) cost_purchase, coalesce(d.cost_retail, h.cost_retail) cost_retail, n.qty_clo, n.qty_clr, n.qty_ord, n.qty_sup, n.qty_inc, n.qty_avl, n.qty_res, n.qty_out, n.cost_inc, n.cost_out, n.qty_acn, n.cost_acn, h.state_id, h.agent_id, d.dts_edit, h.dts_open, h.dts_fix, h.dts_clos, s.mcode state from doc_list h join optypes o on h.optype_id = o.id join doc_states s on h.state_id=s.id left join doc_data d on h.id = d.doc_id LEFT join v_saldo_invnt n on d.ware_id=n.ware_id ; create or alter view z_settings_pivot as select iif(s.working_mode=c.svalue,'* '||upper(s.working_mode), lower(s.working_mode) ) as working_mode ,max( iif(mcode = 'C_WARES_MAX_ID', s.svalue, null ) ) as wares_max_id ,max( iif(mcode = 'C_CUSTOMER_DOC_MAX_ROWS', s.svalue, null ) ) as customer_doc_max_rows ,max( iif(mcode = 'C_SUPPLIER_DOC_MAX_ROWS', s.svalue, null ) ) as supplier_doc_max_rows ,max( iif(mcode = 'C_CUSTOMER_DOC_MAX_QTY', s.svalue, null ) ) as customer_doc_max_qty ,max( iif(mcode = 'C_SUPPLIER_DOC_MAX_QTY', s.svalue, null ) ) as supplier_doc_max_qty ,max( iif(mcode = 'C_NUMBER_OF_AGENTS', s.svalue, null ) ) as number_of_agents from settings s left join (select s.svalue from settings s where s.mcode='WORKING_MODE') c on s.working_mode=c.svalue where s.mcode in ( 'C_WARES_MAX_ID' ,'C_CUSTOMER_DOC_MAX_ROWS' ,'C_SUPPLIER_DOC_MAX_ROWS' ,'C_CUSTOMER_DOC_MAX_QTY' ,'C_SUPPLIER_DOC_MAX_QTY' ,'C_NUMBER_OF_AGENTS' ) group by s.working_mode, c.svalue order by iif(s.working_mode starting with 'DEBUG',  0, iif(s.working_mode starting with 'SMALL',  1, iif(s.working_mode starting with 'MEDIUM', 2, iif(s.working_mode starting with 'LARGE',  3, iif(s.working_mode starting with 'HEAVY',  5, null) ) ) ) ) nulls last ,s.working_mode ; create or alter view z_random_bop as select b.sort_prior as id, b.unit, b.info from business_ops b ; create or alter view z_halt_log as select p.id, p.fb_gdscode, p.unit, p.trn_id, p.dump_trn, p.att_id, p.exc_unit, p.info, p.ip, p.dts_beg, e.fb_mnemona, p.exc_info,p.stack from perf_log p join ( select g.trn_id, g.fb_gdscode from perf_log g where g.fb_gdscode in (      0 ,335544347, 335544558 ,335544665, 335544349 ,335544466 ,335544838 ,335544839 ) group by 1,2 ) g on p.trn_id = g.trn_id left join fb_errors e on p.fb_gdscode = e.fb_gdscode order by p.id ; create or alter view z_agents_tunrover_saldo as select m.agent_id, m.doc_id, o.mcode, o.acn_type ,o.m_supp_debt * m.cost_purchase vol_supp ,o.m_cust_debt * m.cost_retail vol_cust ,sum(o.m_supp_debt * m.cost_purchase)over(partition by m.agent_id) sum_supp ,sum(o.m_cust_debt * m.cost_retail  )over(partition by m.agent_id) sum_cust from money_turnover_log m join optypes o on m.optype_id = o.id ; create or alter view z_mon_stat_per_units as select m.unit ,count(*) iter_counts ,avg(m.elapsed_ms) avg_elap_ms ,avg(1000.00 * ( (m.rec_seq_reads + m.rec_idx_reads + m.bkv_reads ) / nullif(m.elapsed_ms,0))  ) avg_rec_reads_sec ,avg(1000.00 * ( (m.rec_inserts + m.rec_updates + m.rec_deletes ) / nullif(m.elapsed_ms,0))  ) avg_rec_dmls_sec ,avg(1000.00 * ( m.rec_backouts / nullif(m.elapsed_ms,0))  ) avg_bkos_sec ,avg(1000.00 * ( m.rec_purges / nullif(m.elapsed_ms,0))  ) avg_purg_sec ,avg(1000.00 * ( m.rec_expunges / nullif(m.elapsed_ms,0))  ) avg_xpng_sec ,avg(1000.00 * ( m.pg_fetches / nullif(m.elapsed_ms,0)) ) avg_fetches_sec ,avg(1000.00 * ( m.pg_marks / nullif(m.elapsed_ms,0)) ) avg_marks_sec ,avg(1000.00 * ( m.pg_reads / nullif(m.elapsed_ms,0)) ) avg_reads_sec ,avg(1000.00 * ( m.pg_writes / nullif(m.elapsed_ms,0)) ) avg_writes_sec ,avg(m.rec_seq_reads) avg_seq ,avg(m.rec_idx_reads) avg_idx ,avg(m.rec_rpt_reads) avg_rpt ,avg(m.bkv_reads) avg_bkv ,avg(m.frg_reads) avg_frg ,avg(m.bkv_per_seq_idx_rpt) avg_bkv_per_rec ,avg(m.frg_per_seq_idx_rpt) avg_frg_per_rec ,avg(m.rec_inserts) avg_ins ,avg(m.rec_updates) avg_upd ,avg(m.rec_deletes) avg_del ,avg(m.rec_backouts) avg_bko ,avg(m.rec_purges) avg_pur ,avg(m.rec_expunges) avg_exp ,avg(m.pg_fetches) avg_fetches ,avg(m.pg_marks) avg_marks ,avg(m.pg_reads) avg_reads ,avg(m.pg_writes) avg_writes ,avg(m.rec_locks) avg_locks ,avg(m.rec_confl) avg_confl ,datediff( minute from min(m.dts) to max(m.dts) ) workload_minutes ,max(m.rec_seq_reads) max_seq ,max(m.rec_idx_reads) max_idx ,max(m.rec_rpt_reads) max_rpt ,max(m.bkv_reads) max_bkv ,max(m.frg_reads) max_frg ,max(m.bkv_per_seq_idx_rpt) max_bkv_per_rec ,max(m.frg_per_seq_idx_rpt) max_frg_per_rec ,max(m.rec_inserts) max_ins ,max(m.rec_updates) max_upd ,max(m.rec_deletes) max_del ,max(m.rec_backouts) max_bko ,max(m.rec_purges) max_pur ,max(m.rec_expunges) max_exp ,max(m.pg_fetches) max_fetches ,max(m.pg_marks) max_marks ,max(m.pg_reads) max_reads ,max(m.pg_writes) max_writes ,max(m.rec_locks) max_locks ,max(m.rec_confl) max_confl from mon_log m group by unit ; create or alter view z_mon_stat_per_tables as select t.table_name ,t.unit ,count(*) iter_counts ,avg(t.rec_seq_reads) avg_seq ,avg(t.rec_idx_reads) avg_idx ,avg(t.rec_rpt_reads) avg_rpt ,avg(t.bkv_reads) avg_bkv ,avg(t.frg_reads) avg_frg ,avg(t.bkv_per_seq_idx_rpt) avg_bkv_per_rec ,avg(t.frg_per_seq_idx_rpt) avg_frg_per_rec ,avg(t.rec_inserts) avg_ins ,avg(t.rec_updates) avg_upd ,avg(t.rec_deletes) avg_del ,avg(t.rec_backouts) avg_bko ,avg(t.rec_purges) avg_pur ,avg(t.rec_expunges) avg_exp ,avg(t.rec_locks) avg_locks ,avg(t.rec_confl) avg_confl ,datediff( minute from min(t.dts) to max(t.dts) ) elapsed_minutes ,max(t.rec_seq_reads) max_seq ,max(t.rec_idx_reads) max_idx ,max(t.rec_rpt_reads) max_rpt ,max(t.bkv_reads) max_bkv ,max(t.frg_reads) max_frg ,max(t.bkv_per_seq_idx_rpt) max_bkv_per_rec ,max(t.frg_per_seq_idx_rpt) max_frg_per_rec ,max(t.rec_inserts) max_ins ,max(t.rec_updates) max_upd ,max(t.rec_deletes) max_del ,max(t.rec_backouts) max_bko ,max(t.rec_purges) max_pur ,max(t.rec_expunges) max_exp ,max(t.rec_locks) max_locks ,max(t.rec_confl) max_confl from mon_log_table_stats t where t.rec_seq_reads + t.rec_idx_reads + t.rec_rpt_reads + t.bkv_reads + t.frg_reads + t.rec_inserts + t.rec_updates + t.rec_deletes + t.rec_backouts + t.rec_purges + t.rec_expunges + t.rec_locks + t.rec_confl > 0 group by t.table_name,t.unit ; commit; set term ^; create or alter trigger money_turnover_log_bi for money_turnover_log active before insert position 0 as begin new.id = coalesce(new.id, gen_id(g_common, 1) ); end ^ create or alter trigger perf_log_bi for perf_log active before insert position 0 as begin new.id = coalesce(new.id, gen_id(g_perf_log, 1) ); end ^ set term ;^ commit; set term ^; create or alter trigger doc_list_biud for doc_list active before insert or update or delete position 0 as declare v_msg dm_info = ''; declare v_info dm_info = ''; declare v_this dm_dbobj = 'doc_list_biud'; declare v_affects_on_inventory_balance smallint; declare v_old_op type of dm_ids; declare v_new_op type of dm_ids; begin if ( inserting ) then new.id = coalesce(new.id, gen_id(g_common,1)); v_info = 'dh='|| iif(not inserting, old.id, new.id) || ', op='||iif(inserting,'INS',iif(updating,'UPD','DEL')) || iif(not inserting, ' old='||old.optype_id, '') || iif(not deleting,  ' new='||new.optype_id, ''); execute procedure sp_add_perf_log( 1, v_this, null, v_info ); if (inserting) then begin new.state_id = coalesce(new.state_id, fn_doc_open_state()); new.acn_type = (select o.acn_type from optypes o where o.id = new.optype_id); v_msg = v_msg || ' new.id='||new.id||', acn_type='||coalesce(new.acn_type,'<?>'); end if ( not deleting ) then begin if ( new.state_id <> fn_doc_open_state() ) then begin new.dts_fix = coalesce(new.dts_fix, 'now'); new.dts_clos = iif( new.state_id in( fn_doc_clos_state(), fn_doc_canc_state() ), 'now', null); end if ( new.state_id = fn_doc_open_state() ) then begin new.dts_fix = null; new.dts_clos = null; end end else v_msg = v_msg || ' doc='||old.id||', op='||old.optype_id; v_old_op=iif(inserting, null, old.optype_id); v_new_op=iif(deleting,  null, new.optype_id); select max(maxvalue(abs(o.m_qty_clo), abs(o.m_qty_clr), abs(o.m_qty_ord), abs(o.m_qty_sup), abs(o.m_qty_avl), abs(o.m_qty_res))) q_mult_abs_max from optypes o where o.id in( :v_old_op, :v_new_op ) into v_affects_on_inventory_balance; if ( v_affects_on_inventory_balance > 0 and (deleting or updating and new.optype_id is distinct from old.optype_id) ) then execute procedure sp_kill_qty_storno( old.id, old.optype_id, iif( deleting, null, new.optype_id), iif( updating, 1, 0), iif( deleting, 1, 0) ); execute procedure sp_add_perf_log(0, v_this,null,v_msg); when any do begin execute procedure sp_add_to_abend_log( 'error in '||v_this, gdscode, v_msg, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter trigger doc_list_aiud for doc_list active after insert or update or delete position 0 as declare v_affects_on_monetary_balance smallint; declare v_affects_on_inventory_balance smallint; declare v_doc_id dm_ids; declare v_old_op type of dm_ids; declare v_new_op type of dm_ids; declare v_old_mult type of dm_sign = null; declare v_new_mult type of dm_sign = null; declare v_affects_on_customer_saldo smallint; declare v_affects_on_supplier_saldo smallint; declare v_oper_changing_cust_saldo type of dm_ids; declare v_oper_changing_supp_saldo type of dm_ids; declare v_cost_diff type of dm_cost; declare v_msg type of dm_info = ''; declare v_this dm_dbobj = 'doc_list_aiud'; declare v_catch_bitset bigint; begin v_affects_on_monetary_balance = 1; v_affects_on_inventory_balance = 1; v_doc_id=iif(deleting, old.id, new.id); v_old_op=iif(inserting, null, old.optype_id); v_new_op=iif(deleting,  null, new.optype_id); v_msg = 'dh='|| iif(not inserting, old.id, new.id) || ', op='||iif(inserting,'INS',iif(updating,'UPD','DEL')) || iif(not inserting, ' old='||old.optype_id, '') || iif(not deleting,  ' new='||new.optype_id, ''); execute procedure sp_add_perf_log( 1, v_this , null, v_msg ); select iif(m_cust_4old<>0, m_cust_4old, m_supp_4old), iif(m_cust_4new<>0, m_cust_4new, m_supp_4new), iif(m_cust_4old<>0, v_old_op, iif(m_cust_4new<>0, v_new_op, 0)) v_oper_changing_cust_saldo, iif(m_supp_4old<>0, v_old_op, iif(m_supp_4new<>0, v_new_op, 0)) v_oper_changing_supp_saldo, iif(m_cust_4old<>0 or m_cust_4new<>0, 1, 0) v_affects_on_customer_saldo, iif(m_supp_4old<>0 or m_supp_4new<>0, 1, 0) v_affects_on_supplier_saldo, q_mult_abs_max from( select max(iif(o.id=:v_old_op, o.m_cust_debt, null)) m_cust_4old, max(iif(o.id=:v_old_op, o.m_supp_debt, null)) m_supp_4old, max(iif(o.id=:v_new_op, o.m_cust_debt, null)) m_cust_4new, max(iif(o.id=:v_new_op, o.m_supp_debt, null)) m_supp_4new, max(iif(o.id=:v_old_op, :v_old_op, null)) v_old_op, max(iif(o.id=:v_new_op, :v_new_op, null)) v_new_op, max(maxvalue(abs(o.m_qty_clo), abs(o.m_qty_clr), abs(o.m_qty_ord), abs(o.m_qty_sup), abs(o.m_qty_avl), abs(o.m_qty_res))) q_mult_abs_max from optypes o where o.id in( :v_old_op, :v_new_op ) ) into v_old_mult, v_new_mult, v_oper_changing_cust_saldo, v_oper_changing_supp_saldo, v_affects_on_customer_saldo, v_affects_on_supplier_saldo, v_affects_on_inventory_balance; if ( v_affects_on_inventory_balance > 0 and ( inserting and new.cost_purchase > 0 or updating and ( new.cost_purchase is distinct from old.cost_purchase or new.optype_id is distinct from old.optype_id ) or deleting ) ) then begin v_catch_bitset = cast(rdb$get_context('USER_SESSION','QMISM_VERIFY_BITSET') as bigint); if ( bin_and( v_catch_bitset, 1 ) <> 0 ) then begin execute procedure srv_find_qd_qs_mism( iif(deleting, old.id, new.id), iif(deleting, :v_old_op, :v_new_op), iif(deleting, 1, 0) ); end if ( bin_and( v_catch_bitset, 2 ) <> 0 ) then begin execute procedure srv_check_neg_remainders(  iif(deleting, old.id, new.id), iif(deleting, :v_old_op, :v_new_op) ); end end if ( coalesce(v_old_mult,0)=0 and coalesce(v_new_mult,0)=0 ) then v_affects_on_monetary_balance = 0; if ( v_affects_on_monetary_balance <> 0 ) then begin if ( new.cost_purchase is distinct from old.cost_purchase or new.cost_retail is distinct from old.cost_retail ) then begin if ( v_oper_changing_cust_saldo <> 0 or v_oper_changing_supp_saldo <> 0 ) then begin if (  inserting or updating ) then begin if ( v_oper_changing_cust_saldo <> 0 ) then v_cost_diff = new.cost_retail - iif(inserting, 0, old.cost_retail); else v_cost_diff = new.cost_purchase - iif(inserting, 0, old.cost_purchase); execute procedure sp_multiply_rows_for_pdistr( new.id, new.agent_id, v_new_op, v_cost_diff ); execute procedure sp_make_cost_storno( new.id, :v_new_op, new.agent_id, :v_cost_diff ); end else begin execute procedure sp_kill_cost_storno( old.id ); end end execute procedure sp_add_money_log( iif(not deleting, new.id, old.id), 0, 0, 0, 0, 0, 1, iif(not deleting, new.agent_id, old.agent_id), iif(not deleting, new.optype_id, old.optype_id), iif(not deleting, new.cost_purchase - coalesce(old.cost_purchase,0), -old.cost_purchase), iif(not deleting, new.cost_retail - coalesce(old.cost_retail,0), - old.cost_retail) ); end else if (updating) then begin if ( new.optype_id is distinct from old.optype_id ) then begin if ( v_oper_changing_cust_saldo <> 0 or v_oper_changing_supp_saldo <> 0  ) then begin if ( v_new_op in (v_oper_changing_cust_saldo, v_oper_changing_supp_saldo) ) then begin v_cost_diff = iif( v_oper_changing_cust_saldo <> 0, new.cost_retail, new.cost_purchase ); execute procedure sp_multiply_rows_for_pdistr( new.id, new.agent_id, v_new_op, v_cost_diff ); execute procedure sp_make_cost_storno( new.id, :v_new_op, new.agent_id, :v_cost_diff ); end else begin execute procedure sp_kill_cost_storno( old.id ); end end execute procedure sp_add_money_log( old.id, v_old_mult, old.agent_id, v_old_op, old.cost_purchase, old.cost_retail, v_new_mult, new.agent_id, v_new_op, new.cost_purchase, new.cost_retail ); end end end execute procedure sp_add_perf_log(0, v_this); when any do begin execute procedure sp_add_to_abend_log( 'error in '||v_this, gdscode, v_msg, v_this, fn_halt_sign(gdscode) ); exception; end end ^ set term ;^ commit; set term ^; create or alter trigger trg_connect active on connect as begin execute procedure sp_init_ctx; if ( rdb$get_context ('SYSTEM', 'NETWORK_PROTOCOL') is null ) then begin insert into perf_log(unit, info ) values( 'trg_connect', 'attach using NON-TCP protocol' ); end end ^ set term ;^ commit; set term ^; create or alter procedure sp_add_doc_list( a_gen_id type of dm_ids, a_optype_id type of dm_ids, a_agent_id type of dm_ids, a_new_state type of dm_ids default null, a_base_doc_id type of dm_ids default null, a_new_cost_purchase type of dm_cost default 0, a_new_cost_retail type of dm_cost default 0 ) returns( id dm_ids, dbkey dm_dbkey ) as begin insert into doc_list( id, optype_id, agent_id, state_id, base_doc_id, cost_purchase, cost_retail ) values( coalesce(:a_gen_id, gen_id(g_common,1)), :a_optype_id, :a_agent_id, :a_new_state, :a_base_doc_id, :a_new_cost_purchase, :a_new_cost_retail ) returning id, rdb$db_key into id, dbkey; rdb$set_context('USER_SESSION','ADD_INFO','doc='||id||': created Ok'); if ( rdb$get_context('USER_TRANSACTION','INIT_DATA_POP') = 1 ) then id = id + 0 * gen_id(g_init_pop, 1); suspend; end ^ create or alter procedure sp_add_doc_data( a_doc_id dm_ids, a_optype_id dm_ids, a_gen_dd_id dm_ids, a_gen_nt_id dm_ids, a_ware_id dm_ids, a_qty type of dm_qty, a_cost_purchase type of dm_cost, a_cost_retail type of dm_cost ) returns( id dm_ids, dbkey dm_dbkey ) as declare v_this dm_dbobj = 'sp_add_doc_data'; begin if ( a_gen_dd_id is NOT null ) then insert into doc_data( id, doc_id, ware_id, qty, cost_purchase, cost_retail, dts_edit) values( :a_gen_dd_id, :a_doc_id, :a_ware_id, :a_qty, :a_cost_purchase, :a_cost_retail, 'now') returning id, rdb$db_key into id, dbkey; else begin update doc_data t set t.qty = t.qty + :a_qty, t.cost_purchase = t.cost_purchase + :a_cost_purchase, t.cost_retail = t.cost_retail + :a_cost_retail, t.dts_edit = 'now' where t.doc_id = :a_doc_id and t.ware_id = :a_ware_id returning t.id, t.rdb$db_key into id, dbkey; if ( row_count = 0 ) then insert into doc_data( doc_id, ware_id, qty, cost_purchase, cost_retail, dts_edit) values( :a_doc_id, :a_ware_id, :a_qty, :a_cost_purchase, :a_cost_retail, 'now') returning id, rdb$db_key into id, dbkey; end if ( :a_qty <> 0 ) then insert into invnt_turnover_log( id ,ware_id ,qty_diff ,cost_diff ,doc_list_id ,doc_pref ,doc_data_id ,optype_id ) values ( :a_gen_nt_id ,:a_ware_id ,:a_qty ,:a_cost_purchase ,:a_doc_id ,fn_mcode_for_oper(:a_optype_id) ,:id ,:a_optype_id ); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'out: id='||coalesce(id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter function fn_get_random_quantity( a_ctx_max_name dm_ctxnv ) returns dm_qty as declare v_min double precision; declare v_max double precision; begin v_min = 0.5; v_max = cast( rdb$get_context('USER_SESSION',a_ctx_max_name) as int) + 0.5; return cast( v_min + rand()* (v_max - v_min)  as int); end ^ create or alter function fn_get_random_cost( a_ctx_min_name dm_ctxnv, a_ctx_max_name dm_ctxnv, a_make_check_before smallint default 1 ) returns dm_cost as declare v_min double precision; declare v_max double precision; begin if (a_make_check_before = 1) then execute procedure sp_check_ctx( 'USER_SESSION',a_ctx_min_name, 'USER_SESSION',a_ctx_max_name ); v_min = cast( rdb$get_context('USER_SESSION',a_ctx_min_name) as int) - 0.5; v_max = cast( rdb$get_context('USER_SESSION',a_ctx_max_name) as int) + 0.5; return cast( v_min + rand()* (v_max - v_min)  as dm_cost); end ^ create or alter function fn_get_random_customer returns bigint as begin return fn_get_random_id('v_all_customers', null, null, 0); end ^ create or alter function fn_get_random_supplier returns bigint as begin return fn_get_random_id('v_all_suppliers', null, null, 0); end ^ create or alter procedure sp_make_qty_storno( a_optype_id dm_ids ,a_agent_id dm_ids ,a_state_id type of dm_ids default null ,a_client_order_id type of dm_ids default null ,a_rows_in_shopcart int default null ,a_qsum_in_shopcart dm_qty default null ) returns ( doc_list_id bigint ) as declare c_gen_inc_step_qd int = 100; declare v_gen_inc_iter_qd int; declare v_gen_inc_last_qd dm_ids; declare c_gen_inc_step_dd int = 20; declare v_gen_inc_iter_dd int; declare v_gen_inc_last_dd dm_ids; declare c_gen_inc_step_nt int = 20; declare v_gen_inc_iter_nt int; declare v_gen_inc_last_nt dm_ids; declare v_inserting_table dm_dbobj; declare v_id type of dm_ids; declare v_curr_tx bigint; declare v_ware_id dm_ids; declare v_dh_new_id bigint; declare v_dd_new_id bigint; declare v_nt_new_id dm_ids; declare v_dd_dbkey dm_dbkey; declare v_dd_clo_id dm_ids; declare v_doc_data_purchase_sum dm_cost; declare v_doc_data_retail_sum dm_cost; declare v_doc_list_purchase_sum dm_cost; declare v_doc_list_retail_sum dm_cost; declare v_doc_list_dbkey dm_dbkey; declare v_rows_added int; declare v_storno_sub smallint; declare v_qty_storned_acc type of dm_qty; declare v_qty_required type of dm_qty; declare v_qty_could_storn type of dm_qty; declare v_snd_optype_id type of dm_ids; declare v_rcv_optype_id type of dm_ids; declare v_next_rcv_op type of dm_ids; declare v_this dm_dbobj = 'sp_make_qty_storno'; declare v_call dm_dbobj; declare v_info dm_info; declare v_rows int = 0; declare v_lock int = 0; declare v_skip int = 0; declare v_dummy bigint; declare v_sign dm_sign; declare v_cq_id dm_ids; declare v_cq_snd_list_id dm_ids; declare v_cq_snd_data_id dm_ids; declare v_cq_snd_qty dm_qty; declare v_cq_snd_purchase dm_cost; declare v_cq_snd_retail dm_cost; declare v_cq_snd_optype_id dm_ids; declare v_cq_rcv_optype_id type of dm_ids; declare v_cq_trn_id dm_ids; declare v_cq_dts timestamp; declare c_shop_cart cursor for ( select id, dd_clo_id, snd_optype_id, rcv_optype_id, qty, storno_sub from ( select c.id, cast(null as dm_ids) as dd_clo_id, c.snd_optype_id, c.rcv_optype_id, c.qty, c.storno_sub from tmp$shopping_cart c UNION ALL select c.id, c.snd_id, r.snd_optype_id, c.rcv_optype_id, c.qty, r.storno_sub from tmp$shopping_cart c INNER join rules_for_qdistr r on :a_client_order_id is NOT null and c.rcv_optype_id +0 = r.rcv_optype_id + 0 and r.storno_sub = 2 ) u order by id, storno_sub ); declare c_make_amount_distr_1 cursor for ( select q.id ,q.doc_id as snd_list_id ,q.snd_id as snd_data_id ,q.snd_qty ,q.snd_purchase ,q.snd_retail ,q.snd_optype_id ,q.rcv_optype_id ,q.trn_id ,q.dts from qdistr q where q.ware_id = :v_ware_id and q.snd_optype_id = :v_snd_optype_id and q.rcv_optype_id = :v_rcv_optype_id and :v_storno_sub = 1 order by q.doc_id + 0 ,:v_sign * q.id ); declare c_make_amount_distr_2 cursor for ( select q.id ,q.doc_id as snd_list_id ,q.snd_id as snd_data_id ,q.snd_qty ,q.snd_purchase ,q.snd_retail ,q.snd_optype_id ,q.rcv_optype_id ,q.trn_id ,q.dts from qdistr q where q.snd_optype_id = :v_snd_optype_id and q.rcv_optype_id = :v_rcv_optype_id and q.snd_id = :v_dd_clo_id and :v_storno_sub = 2 order by q.doc_id + 0 ,:v_sign * q.id ); declare v_internal_qty_storno_mode dm_name; begin select r.rcv_optype_id from rules_for_qdistr r where r.snd_optype_id = :a_optype_id into v_next_rcv_op; v_internal_qty_storno_mode = rdb$get_context('USER_SESSION','QDISTR_HANDLING_MODE'); if (v_internal_qty_storno_mode not in ('DEL_INS', 'UPD_ROW')  ) then exception ex_context_var_not_found using ('QDISTR_HANDLING_MODE'); v_this = v_this || '_mode_' || v_internal_qty_storno_mode; v_call = v_this; v_dh_new_id = gen_id(g_common, 1); v_info = 'op='||a_optype_id ||', next_op='||coalesce(v_next_rcv_op,'<?>') ||coalesce(', clo='||a_client_order_id, ''); execute procedure sp_add_perf_log(1, v_call, null, v_info); v_qty_could_storn = 0; v_rows_added = 0; v_doc_list_purchase_sum = 0; v_doc_list_retail_sum = 0; v_gen_inc_iter_dd = 1; c_gen_inc_step_dd = coalesce( 1 + a_rows_in_shopcart, 20 ); v_gen_inc_last_dd = gen_id( g_doc_data, :c_gen_inc_step_dd ); v_gen_inc_iter_qd = 1; c_gen_inc_step_qd = coalesce( 1 + a_qsum_in_shopcart, 100 ); v_gen_inc_last_qd = gen_id( g_qdistr, :c_gen_inc_step_qd ); v_gen_inc_iter_nt = 1; c_gen_inc_step_nt = coalesce( 1 + a_rows_in_shopcart, 20 ); v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); v_sign = iif( bin_and(current_transaction, 1)=0, 1, -1); open c_shop_cart; while (1=1) do begin fetch c_shop_cart into v_ware_id, v_dd_clo_id, v_snd_optype_id, v_rcv_optype_id, v_qty_required, v_storno_sub; if ( row_count = 0 ) then leave; v_qty_could_storn = iif(v_storno_sub=1,  0, v_qty_could_storn); v_qty_required = iif(v_storno_sub=1,  v_qty_required, v_qty_could_storn); v_dd_dbkey = iif(v_storno_sub=1,  null, v_dd_dbkey); v_dd_new_id = iif(v_storno_sub=1,  null, v_dd_new_id); v_qty_storned_acc = 0; v_doc_data_purchase_sum = 0; v_doc_data_retail_sum = 0; if ( v_storno_sub = 1 ) then open c_make_amount_distr_1; else open c_make_amount_distr_2; while ( :v_qty_storned_acc < :v_qty_required ) do begin if ( v_storno_sub = 1 ) then fetch c_make_amount_distr_1 into v_cq_id,v_cq_snd_list_id,v_cq_snd_data_id ,v_cq_snd_qty,v_cq_snd_purchase,v_cq_snd_retail ,v_cq_snd_optype_id,v_cq_rcv_optype_id ,v_cq_trn_id,v_cq_dts; else fetch c_make_amount_distr_2 into v_cq_id,v_cq_snd_list_id,v_cq_snd_data_id ,v_cq_snd_qty,v_cq_snd_purchase,v_cq_snd_retail ,v_cq_snd_optype_id,v_cq_rcv_optype_id ,v_cq_trn_id,v_cq_dts; if ( row_count = 0 ) then leave; v_info =  'fetch ' ||iif( v_storno_sub = 1, 'c_make_amount_distr_1', 'c_make_amount_distr_2') ||', qd.id='||v_cq_id; v_rows = v_rows + 1; if ( v_storno_sub = 1 ) then begin if ( v_gen_inc_iter_qd >= c_gen_inc_step_qd ) then begin v_gen_inc_iter_qd = 1; v_gen_inc_last_qd = gen_id( g_qdistr, :c_gen_inc_step_qd ); end if ( v_qty_storned_acc = 0 ) then begin if ( v_gen_inc_iter_dd >= c_gen_inc_step_dd ) then begin v_gen_inc_iter_dd = 1; v_gen_inc_last_dd = gen_id( g_doc_data, :c_gen_inc_step_dd ); end v_dd_new_id = v_gen_inc_last_dd - ( c_gen_inc_step_dd - v_gen_inc_iter_dd ); v_gen_inc_iter_dd = v_gen_inc_iter_dd + 1; end end if ( v_internal_qty_storno_mode = 'UPD_ROW' ) then begin if ( v_storno_sub = 1 ) then begin v_inserting_table = 'qdistr'; v_id = v_gen_inc_last_qd - ( c_gen_inc_step_qd - v_gen_inc_iter_qd ); v_call = v_this || ':try_upd_qdsub1'; v_info = v_info || ', try UPD QDistr set id='||v_id; update qdistr q set q.id = :v_id ,q.doc_id = :v_dh_new_id ,q.snd_optype_id = :a_optype_id ,q.rcv_optype_id = :v_next_rcv_op ,q.snd_id = :v_dd_new_id ,q.trn_id = current_transaction ,q.dts = 'now' where current of c_make_amount_distr_1; v_gen_inc_iter_qd = v_gen_inc_iter_qd + 1; end else begin v_call = v_this || ':try_del_qdsub2'; delete from qdistr q where current of c_make_amount_distr_2; end end else if ( v_internal_qty_storno_mode = 'DEL_INS' ) then begin if ( v_storno_sub = 1 ) then begin v_call = v_this || ':try_del_qdsub1'; delete from qdistr q where current of c_make_amount_distr_1; end else begin v_call = v_this || ':try_del_qdsub2'; delete from qdistr q where current of c_make_amount_distr_2; end if ( v_storno_sub = 1 ) then begin v_inserting_table = 'qdistr'; v_id = v_gen_inc_last_qd - ( c_gen_inc_step_qd - v_gen_inc_iter_qd ); v_call = v_this || ':try_ins_qdsub1'; v_info = v_info || ', try INSERT into QDistr id='||v_id; insert into qdistr( id, doc_id, ware_id, snd_optype_id, rcv_optype_id, snd_id, snd_qty, snd_purchase, snd_retail) values( :v_id, :v_dh_new_id, :v_ware_id, :a_optype_id, :v_next_rcv_op, :v_dd_new_id, :v_cq_snd_qty, :v_cq_snd_purchase, :v_cq_snd_retail ); v_gen_inc_iter_qd = v_gen_inc_iter_qd + 1; v_info = v_info || ' - ok'; end end v_inserting_table = 'qstorned'; v_id =  v_cq_id; v_info = v_info||', try INSERT into QStorned: id='||:v_id; v_call = v_this || ':try_ins_qStorn'; insert into qstorned( id, doc_id, ware_id, dts, snd_optype_id, snd_id, snd_qty, rcv_optype_id, rcv_doc_id, rcv_id, snd_purchase, snd_retail ) values ( :v_id ,:v_cq_snd_list_id, :v_ware_id, :v_cq_dts ,:v_cq_snd_optype_id, :v_cq_snd_data_id,:v_cq_snd_qty ,:v_cq_rcv_optype_id ,:v_dh_new_id ,:v_dd_new_id ,:v_cq_snd_purchase,:v_cq_snd_retail ); v_info = v_info || ' - ok'; v_qty_storned_acc = v_qty_storned_acc + v_cq_snd_qty; v_lock = v_lock + 1; if ( v_storno_sub = 1 ) then begin v_qty_could_storn = v_qty_could_storn + v_cq_snd_qty; v_doc_data_purchase_sum = v_doc_data_purchase_sum + v_cq_snd_purchase; v_doc_data_retail_sum = v_doc_data_retail_sum + v_cq_snd_retail; end when any do begin if ( fn_is_lock_trouble(gdscode) ) then v_skip = v_skip + 1; else begin if ( fn_is_uniqueness_trouble(gdscode) ) then execute procedure srv_log_dups_qd_qs( :v_call, gdscode, :v_inserting_table, :v_id, :v_info ); exception; end end end if ( v_storno_sub = 1 ) then close c_make_amount_distr_1; else close c_make_amount_distr_2; if ( v_dd_new_id is not null and v_storno_sub = 1 ) then begin if ( v_qty_storned_acc > 0 ) then begin if (doc_list_id is null) then begin execute procedure sp_add_doc_list( :v_dh_new_id ,:a_optype_id ,:a_agent_id ,:a_state_id ,:a_client_order_id ) returning_values :doc_list_id, :v_doc_list_dbkey; end if ( v_gen_inc_iter_nt = c_gen_inc_step_nt ) then begin v_gen_inc_iter_nt = 1; v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); end v_nt_new_id = v_gen_inc_last_nt - ( c_gen_inc_step_nt - v_gen_inc_iter_nt ); v_gen_inc_iter_nt = v_gen_inc_iter_nt + 1; execute procedure sp_add_doc_data( :v_dh_new_id ,:a_optype_id ,:v_dd_new_id ,:v_nt_new_id ,:v_ware_id ,:v_qty_could_storn ,:v_doc_data_purchase_sum ,:v_doc_data_retail_sum ) returning_values :v_dummy, :v_dd_dbkey; v_rows_added = v_rows_added + 1; v_doc_list_purchase_sum = v_doc_list_purchase_sum + v_doc_data_purchase_sum; v_doc_list_retail_sum = v_doc_list_retail_sum + v_doc_data_retail_sum; end end end close c_shop_cart; if ( :doc_list_id is NOT null and v_rows_added > 0) then begin update doc_list h set h.cost_purchase = :v_doc_list_purchase_sum, h.cost_retail = :v_doc_list_retail_sum, h.dts_fix = iif( :a_state_id = fn_doc_fix_state(), 'now', h.dts_fix) where h.rdb$db_key = :v_doc_list_dbkey; end else begin v_info = fn_mcode_for_oper(a_optype_id) ||iif(a_optype_id = fn_oper_retail_reserve(), ', clo='||coalesce( a_client_order_id, '<null>'), '') ||',  rows in tmp$cart: '||(select count(*) from tmp$shopping_cart); if ( a_client_order_id is null ) then exception ex_cant_find_row_for_qdistr using( a_optype_id, (select count(*) from tmp$shopping_cart) ); end v_call = v_this; execute procedure sp_add_perf_log(0, v_call, null, 'dh='||coalesce(:doc_list_id,'<?>')||', qd ('||iif(:v_sign=1,'asc','dec')||'): capt='||v_lock||', skip='||v_skip||', scan='||v_rows||'; dd: add='||v_rows_added ); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_call, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_split_into_words( a_text dm_name, a_dels varchar(50) default ',.<>/?;:''"[]{}`~!@#$%^&*()-_=+\|/', a_special char(1) default ' ' ) returns ( word dm_name ) as begin for with recursive j as( select s,1 i, substring(s from 1 for 1) del from( select replace(:a_dels,:a_special,'') s from rdb$database ) UNION ALL select s, i+1, substring(s from i+1 for 1) from j where substring(s from i+1 for 1)<>'' ) ,d as( select :a_text s, :a_special sp from rdb$database ) ,e as( select d.s, replace(d.s, j.del, :a_special) s1, j.i, j.del from d join j on j.i=1 UNION ALL select e.s, replace(e.s1, j.del, :a_special) s1, j.i, j.del from e join j on j.i = e.i + 1 ) ,f as( select s1 from e order by i desc rows 1 ) ,r as ( select iif(t.k>0, substring(t.s from t.k+1 ), t.s) s, iif(t.k>0,position( del, substring(t.s from t.k+1 )),-1) k, t.i, t.del, iif(t.k>0,left(t.s, t.k-1),t.s) word from( select f.s1 s, d.sp del, position(d.sp, s1) k, 0 i from f cross join d )t UNION ALL select iif(r.k>0, substring(r.s from r.k+1 ), r.s) s, iif(r.k>0,position(r.del, substring(r.s from r.k+1 )),-1) k, r.i+1, r.del, iif(r.k>0,left(r.s, r.k-1),r.s) word from r where r.k>=0 ) select word from r where word>'' into word do suspend; end ^ create or alter procedure srv_random_unit_choice( a_included_modes dm_info default '', a_included_kinds dm_info default '', a_excluded_modes dm_info default '', a_excluded_kinds dm_info default '' ) returns( unit dm_name, sort_prior int, rnd_weight int, r double precision, c int, n int ) as declare r_max int; declare v_this dm_dbobj = 'srv_random_unit_choice'; declare c_unit_for_mon_query dm_dbobj = 'srv_fill_mon'; declare function fn_internal_enable_mon_query  returns smallint deterministic as begin return ( cast(rdb$get_context('USER_SESSION', 'ENABLE_MON_QUERY') as smallint) ); end begin a_included_modes = coalesce( a_included_modes, ''); a_included_kinds = coalesce( a_included_kinds, ''); a_excluded_modes = coalesce( a_excluded_modes, ''); a_excluded_kinds = coalesce( a_excluded_kinds, ''); r_max = rdb$get_context('USER_SESSION', 'BOP_RND_MAX'); if ( r_max is null ) then begin select max( b.random_selection_weight ) from business_ops b into r_max; rdb$set_context('USER_SESSION', 'BOP_RND_MAX', r_max); end r=rand()*r_max; delete from tmp$perf_log p where p.stack = :v_this; insert into tmp$perf_log(unit, aux1, aux2, stack) select o.unit, o.sort_prior, o.random_selection_weight, :v_this from business_ops o where o.random_selection_weight >= :r and (fn_internal_enable_mon_query() = 1 or o.unit <> :c_unit_for_mon_query) and (:a_included_modes = '' or :a_included_modes||',' containing trim(o.mode)||',' ) and (:a_included_kinds = '' or :a_included_kinds||',' containing trim(o.kind)||',' ) and (:a_excluded_modes = '' or :a_excluded_modes||',' NOT containing trim(o.mode)||',' ) and (:a_excluded_kinds = '' or :a_excluded_kinds||',' NOT containing trim(o.kind)||',' ) ; c = row_count; n = cast( 0.5+rand()*(c+0.5) as int ); n = minvalue(maxvalue(1, n),c); select p.unit, p.aux1, p.aux2 from tmp$perf_log p where p.aux2 >= :r order by rand() rows :n to :n into unit, sort_prior, rnd_weight; delete from tmp$perf_log p where p.stack = :v_this; suspend; end ^ create or alter procedure srv_diag_pay_distr( a_doc_id dm_ids default null ) returns( result varchar(3), ptab varchar(8), ptab_id int, snd_oper dm_mcode, snd_id dm_ids, rcv_oper dm_mcode, rcv_id dm_ids, ptab_cost dm_cost, ptab_sum_cost dm_cost, payment_id dm_ids, payment_cost dm_cost ) as begin for select iif( iif( h.optype_id=fn_oper_pay_from_customer(), h.cost_retail, h.cost_retail) = sum(ps.cost)over( partition by iif(ps.ptab='pdistr',ps.snd_optype_id,ps.rcv_optype_id)), 'ok.','err' ) result ,cast(ps.ptab as varchar(8)) as ptab ,ps.id as ptab_id ,ps.snd_oper ,ps.snd_id as ptab_snd_id ,ps.rcv_oper ,ps.rcv_id as ptab_rcv_id ,ps.cost as ptab_cost ,sum(ps.cost)over( partition by iif(ps.ptab='pdistr',ps.snd_optype_id,ps.rcv_optype_id)) ptab_sum_cost ,h.id as payment_id ,iif( h.optype_id=fn_oper_pay_from_customer(), h.cost_retail, h.cost_retail) as payment_cost from ( select 'pdistr' ptab, pd.trn_id, pd.snd_optype_id, so.mcode as snd_oper, pd.rcv_optype_id, ro.mcode as rcv_oper, pd.id, pd.snd_id, pd.snd_cost cost, cast(null as int) as rcv_id from pdistr pd join optypes so on pd.snd_optype_id=so.id join optypes ro on pd.rcv_optype_id=ro.id where (pd.snd_id = :a_doc_id or :a_doc_id is null) UNION ALL select 'pstorned', ps.trn_id, ps.snd_optype_id, so.mcode as snd_oper, ps.rcv_optype_id, ro.mcode as rcv_oper, ps.id, ps.snd_id, ps.rcv_cost, ps.rcv_id from pstorned ps join optypes so on ps.snd_optype_id=so.id join optypes ro on ps.rcv_optype_id=ro.id where (ps.rcv_id = :a_doc_id or :a_doc_id is null) ) ps join doc_list h on h.id = iif(ps.ptab='pdistr',ps.snd_id,ps.rcv_id) into result ,ptab ,ptab_id ,snd_oper ,snd_id ,rcv_oper ,rcv_id ,ptab_cost ,ptab_sum_cost ,payment_id ,payment_cost do suspend; end ^ set term ;^ set list on; select 'oltp30_DDL.sql finish' as msg, current_timestamp from rdb$database; set list off; commit; set bail on; set autoddl off; set list on; select 'oltp30_sp.sql start' as msg, current_timestamp from rdb$database; set list off; commit; set term ^; execute block as begin begin execute statement 'recreate exception ex_exclusive_required ''At least one concurrent connection detected.'''; when any do begin end end begin execute statement 'recreate exception ex_not_suitable_fb_version ''This script requires at least Firebird 3.x version'''; when any do begin end end end ^ set term ;^ commit; set term ^; execute block as begin if ( rdb$get_context('SYSTEM','ENGINE_VERSION') starting with '2.' ) then begin exception ex_not_suitable_fb_version; end if ( exists( select * from mon$attachments a where a.mon$attachment_id<>current_connection and a.mon$remote_protocol is not null ) ) then begin exception ex_exclusive_required; end end ^ set term ;^ commit; set term ^; create or alter procedure sp_fill_shopping_cart( a_optype_id dm_ids, a_rows2add int default null, a_maxq4row int default null) returns( row_cnt int, qty_sum dm_qty ) as declare v_doc_rows int; declare v_id dm_ids; declare v_ware_id type of dm_ids; declare v_qty dm_qty; declare v_cost_purchase dm_cost; declare v_cost_retail dm_cost; declare v_snd_optype_id dm_ids; declare v_storno_sub smallint; declare v_ctx_max_rows type of dm_ctxnv; declare v_ctx_max_qty type of dm_ctxnv; declare v_stt varchar(255); declare v_pattern type of dm_name; declare v_source_for_random_id dm_dbobj; declare v_source_for_min_id dm_dbobj; declare v_source_for_max_id dm_dbobj; declare v_raise_exc_on_nofind dm_sign; declare v_can_skip_order_clause dm_sign; declare v_find_using_desc_index dm_sign; declare v_this dm_dbobj = 'sp_fill_shopping_cart'; declare v_info dm_info = ''; begin execute procedure sp_add_perf_log(1, v_this); v_ctx_max_rows = iif( a_optype_id in ( fn_oper_order_for_supplier(), fn_oper_invoice_get() ), 'C_SUPPLIER_DOC_MAX_ROWS', 'C_CUSTOMER_DOC_MAX_ROWS' ); v_ctx_max_qty = iif( a_optype_id in ( fn_oper_order_for_supplier(), fn_oper_invoice_get() ), 'C_SUPPLIER_DOC_MAX_QTY', 'C_CUSTOMER_DOC_MAX_QTY' ); v_doc_rows =  coalesce( a_rows2add, fn_get_random_quantity( v_ctx_max_rows ) ) ; v_source_for_random_id = decode( a_optype_id, fn_oper_order_by_customer(),  'v_all_wares', fn_oper_order_for_supplier(), 'v_random_find_clo_ord', fn_oper_invoice_get(),        'v_random_find_ord_sup', fn_oper_retail_reserve(),     'v_random_find_avl_res', 'unknown_source' ); v_source_for_min_id = decode( a_optype_id, fn_oper_order_for_supplier(), 'v_min_id_clo_ord', fn_oper_invoice_get(),        'v_min_id_ord_sup', fn_oper_retail_reserve(),     'v_min_id_avl_res', null ); v_source_for_max_id = decode( a_optype_id, fn_oper_order_for_supplier(), 'v_max_id_clo_ord', fn_oper_invoice_get(),        'v_max_id_ord_sup', fn_oper_retail_reserve(),     'v_max_id_avl_res', null ); v_can_skip_order_clause = 0; v_raise_exc_on_nofind = decode( a_optype_id, fn_oper_order_by_customer(),  0, fn_oper_order_for_supplier(), 0, fn_oper_invoice_get(),        0, fn_oper_retail_reserve(),     0, 1 ); v_find_using_desc_index = decode( a_optype_id, fn_oper_order_for_supplier(), 1, fn_oper_invoice_get(),        1, fn_oper_retail_reserve(),     1, 0 ); select r.snd_optype_id ,r.storno_sub from rules_for_qdistr r where r.rcv_optype_id = :a_optype_id and r.mode containing 'new_doc' into v_snd_optype_id, v_storno_sub; v_info = 'view='||v_source_for_random_id||', rows='||v_doc_rows||', oper='||a_optype_id; delete from tmp$shopping_cart where 1=1; row_cnt = 0; qty_sum = 0; while ( v_doc_rows > 0 ) do begin v_qty = coalesce(a_maxq4row, fn_get_random_quantity( v_ctx_max_qty )); if ( a_optype_id = fn_oper_order_by_customer() ) then begin if ( rdb$get_context('USER_SESSION','ENABLE_FILL_PHRASES')='1' and exists( select * from phrases ) ) then begin select p.pattern from phrases p where p.id = (select fn_get_random_id('phrases',null,null, :v_raise_exc_on_nofind) from rdb$database) into v_pattern; v_stt = 'select id from wares where '||v_pattern||' rows 1'; execute statement(v_stt) into v_ware_id; if ( v_ware_id is null ) then exception ex_record_not_found using ('wares', v_pattern); end else v_ware_id = fn_get_random_id( v_source_for_random_id, null, null, :v_raise_exc_on_nofind ); select round( w.price_purchase + rand() * 300, -2) * :v_qty ,round( w.price_retail + rand() * 300, -2) * :v_qty from wares w where w.id = :v_ware_id into v_cost_purchase, v_cost_retail; end else begin v_ware_id = fn_get_random_id( v_source_for_random_id, v_source_for_min_id, v_source_for_max_id, v_raise_exc_on_nofind, v_can_skip_order_clause, v_find_using_desc_index ); end if ( v_ware_id is not null ) then begin insert into tmp$shopping_cart( id, snd_optype_id, rcv_optype_id, qty, storno_sub, cost_purchase, cost_retail ) values ( :v_ware_id, :v_snd_optype_id, :a_optype_id, :v_qty, :v_storno_sub, :v_cost_purchase, :v_cost_retail ); row_cnt = row_cnt + 1; qty_sum = qty_sum + ceiling( v_qty ); when any do begin if ( fn_is_uniqueness_trouble(gdscode) ) then update tmp$shopping_cart t set t.dup_cnt = t.dup_cnt+1 where t.id = :v_ware_id; else exception; end end v_doc_rows = v_doc_rows -1; end if ( not exists(select * from tmp$shopping_cart) ) then exception ex_no_rows_in_shopping_cart using( v_source_for_random_id ); execute procedure sp_add_perf_log(0, v_this,null, v_info ); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_client_order( dbg int default 0, dbg_rows2add int default null, dbg_maxq4row int default null ) returns ( doc_list_id type of dm_ids, agent_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail type of dm_cost, qty_clo type of dm_qty, qty_clr type of dm_qty, qty_ord type of dm_qty ) as declare c_gen_inc_step_dd int = 20; declare v_gen_inc_iter_dd int; declare v_gen_inc_last_dd dm_ids; declare c_gen_inc_step_nt int = 20; declare v_gen_inc_iter_nt int; declare v_gen_inc_last_nt dm_ids; declare v_oper_order_by_customer dm_ids; declare v_nt_new_id dm_ids; declare v_clo_for_our_firm dm_sign = 0; declare v_rows_added int = 0; declare v_qty_sum dm_qty = 0; declare v_purchase_sum dm_cost; declare v_retail_sum dm_cost; declare v_ibe smallint; declare v_stt varchar(255); declare v_dd_new_id bigint; declare v_dd_dbkey dm_dbkey; declare v_dbkey dm_dbkey; declare v_this dm_dbobj = 'sp_client_order'; declare c_shop_cart cursor for ( select c.id, c.qty, c.cost_purchase, c.cost_retail from tmp$shopping_cart c ); begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); v_oper_order_by_customer = fn_oper_order_by_customer(); if ( rand()*100 <= cast(rdb$get_context('USER_SESSION', 'ORDER_FOR_OUR_FIRM_PERCENT') as int) ) then begin v_clo_for_our_firm = 1; agent_id = fn_get_random_id('v_our_firm', null, null, 0); end else agent_id = fn_get_random_customer(); execute procedure sp_fill_shopping_cart( v_oper_order_by_customer, dbg_rows2add, dbg_maxq4row ) returning_values v_rows_added, v_qty_sum; if (dbg=1) then exit; execute procedure sp_add_doc_list( null, v_oper_order_by_customer, agent_id, fn_doc_fix_state() ) returning_values :doc_list_id, :v_dbkey; v_gen_inc_iter_dd = 1; c_gen_inc_step_dd = 1 + v_rows_added; v_gen_inc_last_dd = gen_id( g_doc_data, :c_gen_inc_step_dd ); v_gen_inc_iter_nt = 1; c_gen_inc_step_nt = 1 + v_rows_added; v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); v_purchase_sum = 0; v_retail_sum = 0; open c_shop_cart; while (1=1) do begin fetch c_shop_cart into ware_id, qty, purchase, retail; if ( row_count = 0 ) then leave; if ( v_gen_inc_iter_dd = c_gen_inc_step_dd ) then begin v_gen_inc_iter_dd = 1; v_gen_inc_last_dd = gen_id( g_doc_data, :c_gen_inc_step_dd ); end v_dd_new_id = v_gen_inc_last_dd - ( c_gen_inc_step_dd - v_gen_inc_iter_dd ); v_gen_inc_iter_dd = v_gen_inc_iter_dd + 1; if ( v_gen_inc_iter_nt = c_gen_inc_step_nt ) then begin v_gen_inc_iter_nt = 1; v_gen_inc_last_nt = gen_id( g_common, :c_gen_inc_step_nt ); end v_nt_new_id = v_gen_inc_last_nt - ( c_gen_inc_step_nt - v_gen_inc_iter_nt ); v_gen_inc_iter_nt = v_gen_inc_iter_nt + 1; execute procedure sp_add_doc_data( doc_list_id, v_oper_order_by_customer, v_dd_new_id, v_nt_new_id, ware_id, qty, purchase, retail ) returning_values v_dd_new_id, v_dd_dbkey; update tmp$shopping_cart c set c.snd_id = :v_dd_new_id where current of c_shop_cart; v_purchase_sum = v_purchase_sum + purchase; v_retail_sum = v_retail_sum + retail; end close c_shop_cart; if (dbg=2) then exit; execute procedure sp_multiply_rows_for_qdistr( doc_list_id, v_oper_order_by_customer, v_clo_for_our_firm, v_qty_sum ); if (dbg=3) then exit; update doc_list h set h.cost_purchase = :v_purchase_sum, h.cost_retail = :v_retail_sum where h.rdb$db_key  = :v_dbkey; execute procedure sp_add_perf_log(0, v_this,null, 'doc_id='||coalesce(doc_list_id,'<null>')||', rows='||v_rows_added ); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); if ( v_ibe = 1 ) then v_stt = 'select v.agent_id, v.doc_data_id, v.ware_id, v.qty, v.cost_purchase, v.cost_retail' ||',v.qty_clo ,v.qty_clr ,v.qty_ord' ||' from v_doc_detailed v where v.doc_id = :x'; else v_stt = 'select h.agent_id, d.id, d.ware_id, d.qty, d.cost_purchase, d.cost_retail' ||',null      ,null      ,null' ||' from doc_data d join doc_list h on d.doc_id = h.id where d.doc_id = :x'; for execute statement(v_stt) ( x := :doc_list_id ) into agent_id ,doc_data_id ,ware_id ,qty ,purchase ,retail ,qty_clo ,qty_clr ,qty_ord do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_cancel_client_order( a_selected_doc_id type of dm_ids default null, dbg int default 0 ) returns ( doc_list_id type of dm_ids, agent_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail type of dm_cost, qty_clo type of dm_qty, qty_clr type of dm_qty, qty_ord type of dm_qty ) as declare v_ibe smallint; declare v_stt varchar(255); declare v_dummy bigint; declare c_raise_exc_when_no_found dm_sign = 1; declare c_can_skip_order_clause dm_sign = 0; declare v_this dm_dbobj = 'sp_cancel_client_order'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); doc_list_id = coalesce( :a_selected_doc_id, fn_get_random_id( 'v_cancel_client_order' ,null ,null ,c_raise_exc_when_no_found ,c_can_skip_order_clause ) ); execute procedure sp_lock_selected_doc( doc_list_id, 'v_cancel_client_order', a_selected_doc_id); update doc_list h set h.optype_id = fn_oper_cancel_customer_order(), h.state_id = fn_doc_canc_state() where h.id = :doc_list_id; execute procedure sp_add_perf_log(0, v_this,null, 'doc_id='||doc_list_id); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); if ( v_ibe = 1 ) then v_stt = 'select v.agent_id, v.doc_data_id, v.ware_id, v.qty, v.cost_purchase, v.cost_retail' ||',v.qty_clo ,v.qty_clr ,v.qty_ord' ||' from v_doc_detailed v where v.doc_id = :x'; else v_stt = 'select h.agent_id, d.id, d.ware_id, d.qty, d.cost_purchase, d.cost_retail' ||',null      ,null      ,null' ||' from doc_data d join doc_list h on d.doc_id = h.id where d.doc_id = :x'; for execute statement(v_stt) ( x := :doc_list_id ) into agent_id ,doc_data_id ,ware_id ,qty ,purchase ,retail ,qty_clo ,qty_clr ,qty_ord do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_supplier_order( dbg int default 0, dbg_rows2add int default null, dbg_maxq4row int default null ) returns ( doc_list_id type of dm_ids, agent_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail type of dm_cost, qty_clo type of dm_qty, qty_ord type of dm_qty ) as declare v_id bigint; declare v_rows_added int; declare v_qty_sum dm_qty; declare v_ibe smallint; declare v_stt varchar(255); declare v_dummy bigint; declare v_this dm_dbobj = 'sp_supplier_order'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); agent_id = fn_get_random_supplier(); execute procedure sp_fill_shopping_cart( fn_oper_order_for_supplier(), dbg_rows2add, dbg_maxq4row ) returning_values v_rows_added, v_qty_sum; if (dbg=1) then exit; execute procedure sp_make_qty_storno( fn_oper_order_for_supplier() ,agent_id ,fn_doc_open_state() ,null ,v_rows_added ,v_qty_sum ) returning_values doc_list_id; execute procedure sp_add_perf_log(0, v_this, null, 'doc_id='||coalesce(doc_list_id,'<null>')); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); if ( v_ibe = 1 ) then v_stt = 'select v.agent_id, v.doc_data_id, v.ware_id, v.qty, v.cost_purchase, v.cost_retail' ||' ,v.qty_clo ,v.qty_ord' ||' from v_doc_detailed v where v.doc_id = :x'; else v_stt = 'select h.agent_id, d.id, d.ware_id, d.qty, d.cost_purchase, d.cost_retail' ||' ,null     ,null' ||' from doc_data d join doc_list h on d.doc_id = h.id where d.doc_id = :x'; for execute statement(v_stt) ( x := :doc_list_id ) into agent_id ,doc_data_id ,ware_id ,qty ,purchase ,retail ,qty_clo ,qty_ord do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_supplier_invoice ( dbg int = 0, dbg_rows2add int default null, dbg_maxq4row int default null ) returns ( doc_list_id type of dm_ids, agent_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail type of dm_cost, qty_clo type of dm_qty, qty_ord type of dm_qty, qty_sup type of dm_qty ) as declare v_rows_added int; declare v_qty_sum dm_qty; declare v_ibe smallint; declare v_stt varchar(255); declare v_this dm_dbobj = 'sp_supplier_invoice'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); agent_id = fn_get_random_supplier(); execute procedure sp_fill_shopping_cart( fn_oper_invoice_get(), dbg_rows2add, dbg_maxq4row ) returning_values v_rows_added, v_qty_sum; if (dbg=1) then exit; execute procedure sp_make_qty_storno( fn_oper_invoice_get() ,agent_id ,fn_doc_open_state() ,null ,v_rows_added ,v_qty_sum ) returning_values doc_list_id; execute procedure sp_add_perf_log(0, v_this, null, 'doc_id='||coalesce(doc_list_id,'<null>')); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); if ( v_ibe = 1 ) then v_stt = 'select v.agent_id, v.doc_data_id, v.ware_id, v.qty, v.cost_purchase, v.cost_retail' ||' ,v.qty_clo ,v.qty_ord ,v.qty_sup' ||' from v_doc_detailed v where v.doc_id = :x'; else v_stt = 'select h.agent_id, d.id, d.ware_id, d.qty, d.cost_purchase, d.cost_retail' ||' ,null     ,null       ,null' ||' from doc_data d join doc_list h on d.doc_id = h.id where d.doc_id = :x'; for execute statement(v_stt) ( x := :doc_list_id ) into agent_id ,doc_data_id ,ware_id ,qty ,purchase ,retail ,qty_clo ,qty_ord ,qty_sup do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_cancel_supplier_invoice( a_selected_doc_id type of dm_ids default null, a_skip_lock_attempt dm_sign default 0 ) returns( doc_list_id type of dm_ids, agent_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail type of dm_cost, qty_clo type of dm_qty, qty_ord type of dm_qty, qty_sup type of dm_qty ) as declare v_dummy bigint; declare v_ibe smallint; declare v_stt varchar(255); declare c_raise_exc_when_no_found dm_sign = 1; declare c_can_skip_order_clause dm_sign = 0; declare v_this dm_dbobj = 'sp_cancel_supplier_invoice'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); doc_list_id = coalesce( :a_selected_doc_id, fn_get_random_id( 'v_cancel_supplier_invoice' ,null ,null ,c_raise_exc_when_no_found ,c_can_skip_order_clause ) ); execute procedure sp_upd_in_perf_log( v_this, null, 'dh='||doc_list_id); if (  NOT (a_selected_doc_id is NOT null and a_skip_lock_attempt = 1) ) then execute procedure sp_lock_selected_doc( doc_list_id, 'v_cancel_supplier_invoice', a_selected_doc_id); delete from tmp$result_set r where r.doc_id = :doc_list_id; insert into tmp$result_set( doc_id, agent_id, doc_data_id, ware_id, qty, cost_purchase, cost_retail) select :doc_list_id, h.agent_id, d.id, d.ware_id, d.qty, d.cost_purchase, d.cost_retail from doc_data d join doc_list h on d.doc_id = h.id where d.doc_id = :doc_list_id; delete from doc_list h where h.id = :doc_list_id; execute procedure sp_add_perf_log(0, v_this, null); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); v_stt = 'select r.doc_id,r.agent_id,r.doc_data_id,r.ware_id,r.qty,r.cost_purchase,r.cost_retail'; if ( v_ibe = 1 ) then v_stt = v_stt || ' ,n.qty_clo ,n.qty_ord ,n.qty_sup'; else v_stt = v_stt || ' ,null     ,null       ,null'; v_stt = v_stt ||' from tmp$result_set r'; if ( v_ibe = 1 ) then v_stt = v_stt || ' left join v_saldo_invnt n on r.ware_id = n.ware_id'; v_stt = v_stt || ' where r.doc_id = :x'; for execute statement (v_stt) ( x := :doc_list_id ) into doc_list_id ,agent_id ,doc_data_id ,ware_id ,qty ,purchase ,retail ,qty_clo ,qty_ord ,qty_sup do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_fill_shopping_cart_clo_res( a_client_order_id dm_ids ) returns ( row_cnt int, qty_sum dm_qty ) as declare v_oper_invoice_add dm_ids; declare v_oper_retail_reserve dm_ids; declare v_oper_order_by_customer dm_ids; declare v_ware_id dm_ids; declare v_dd_id dm_ids; declare v_clo_qty_need_to_reserve dm_qty; declare v_this dm_dbobj = 'sp_fill_shopping_cart_clo_res'; begin execute procedure sp_add_perf_log(1, v_this, null, 'clo='||a_client_order_id); v_oper_invoice_add =  fn_oper_invoice_add(); v_oper_order_by_customer = fn_oper_order_by_customer(); v_oper_retail_reserve = fn_oper_retail_reserve(); qty_sum = 0; for select d.ware_id, d.id as dd_id, sum(q.snd_qty) as clo_qty_need_to_reserve from doc_data d LEFT join qdistr q on q.snd_optype_id = :v_oper_order_by_customer and q.rcv_optype_id = :v_oper_retail_reserve and q.snd_id = d.id where d.doc_id = :a_client_order_id and q.id is not null group by d.ware_id, d.id into v_ware_id, v_dd_id, v_clo_qty_need_to_reserve do begin insert into tmp$shopping_cart( id, snd_id, snd_optype_id, rcv_optype_id, qty, storno_sub ) values ( :v_ware_id, :v_dd_id, :v_oper_invoice_add, :v_oper_retail_reserve, :v_clo_qty_need_to_reserve, 1 ); row_cnt = row_cnt + 1; qty_sum = qty_sum + v_clo_qty_need_to_reserve; end execute procedure sp_add_perf_log(0, v_this, null, 'rc='||row_count ); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'clo='||a_client_order_id, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_customer_reserve( a_client_order_id type of dm_ids default null, dbg integer default 0) returns ( doc_list_id type of dm_ids, client_order_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail type of dm_cost, qty_ord type of dm_qty, qty_avl type of dm_qty, qty_res type of dm_qty ) as declare v_rows_added int; declare v_qty_sum dm_qty; declare v_dbkey dm_dbkey; declare v_agent_id type of dm_ids; declare v_raise_exc_on_nofind dm_sign; declare v_can_skip_order_clause dm_sign; declare v_find_using_desc_index dm_sign; declare v_ibe smallint; declare v_stt varchar(255); declare v_this dm_dbobj = 'sp_customer_reserve'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log( 1, v_this, null, iif( a_client_order_id is null, 'from avaliable remainders', 'for clo_id='||a_client_order_id ) ); if ( a_client_order_id = -1 ) then a_client_order_id = null; else if ( a_client_order_id is null ) then begin v_raise_exc_on_nofind = 0; v_can_skip_order_clause = 0; v_find_using_desc_index = 0; a_client_order_id = fn_get_random_id( 'v_random_find_clo_res', 'v_min_id_clo_res', 'v_max_id_clo_res', v_raise_exc_on_nofind, v_can_skip_order_clause, v_find_using_desc_index ); end v_qty_sum = 0; while (1=1) do begin delete from tmp$shopping_cart where 1=1; if (a_client_order_id is null) then begin execute procedure sp_fill_shopping_cart( fn_oper_retail_reserve() ) returning_values v_rows_added, v_qty_sum; v_agent_id = fn_get_random_customer(); end else begin select h.rdb$db_key, h.agent_id from doc_list h where h.id = :a_client_order_id into v_dbkey, v_agent_id; if (v_dbkey is null) then exception ex_no_doc_found_for_handling using('doc_list', :a_client_order_id); execute procedure sp_fill_shopping_cart_clo_res( :a_client_order_id ) returning_values v_rows_added, v_qty_sum; end if (dbg=1) then leave; if ( v_qty_sum > 0 ) then begin execute procedure sp_make_qty_storno( fn_oper_retail_reserve() ,v_agent_id ,fn_doc_open_state() ,a_client_order_id ,v_rows_added ,v_qty_sum ) returning_values doc_list_id; end leave; end execute procedure sp_add_perf_log(0, v_this, null, coalesce(doc_list_id,'<null>') ); if ( dbg=4 ) then exit; v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); if ( v_ibe = 1 ) then v_stt = 'select v.base_doc_id, v.doc_data_id, v.ware_id, v.qty,v.cost_purchase, v.cost_retail' ||',v.qty_ord ,v.qty_avl ,v.qty_res' ||' from v_doc_detailed v where v.doc_id = :x'; else v_stt = 'select h.base_doc_id, d.id, d.ware_id, d.qty,d.cost_purchase, d.cost_retail' ||',null      ,null      ,null     ' ||' from doc_data d join doc_list h on d.doc_id = h.id where d.doc_id = :x'; for execute statement (v_stt) ( x := :doc_list_id ) into client_order_id ,doc_data_id ,ware_id ,qty ,purchase ,retail ,qty_ord ,qty_avl ,qty_res do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_cancel_customer_reserve( a_selected_doc_id type of dm_ids default null, a_skip_lock_attempt dm_sign default 0 ) returns ( doc_list_id type of dm_ids, client_order_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail type of dm_cost, qty_ord type of dm_qty, qty_avl type of dm_qty, qty_res type of dm_qty ) as declare v_linked_client_order type of dm_ids; declare v_stt varchar(255); declare v_ibe smallint; declare v_dummy bigint; declare c_raise_exc_when_no_found dm_sign = 1; declare c_can_skip_order_clause dm_sign = 0; declare v_this dm_dbobj = 'sp_cancel_customer_reserve'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); doc_list_id = coalesce( :a_selected_doc_id, fn_get_random_id( 'v_cancel_customer_reserve' ,null ,null ,c_raise_exc_when_no_found ,c_can_skip_order_clause ) ); if (  NOT (a_selected_doc_id is NOT null and a_skip_lock_attempt = 1) ) then execute procedure sp_lock_selected_doc( doc_list_id, 'v_cancel_customer_reserve', a_selected_doc_id); select h.base_doc_id from doc_list h where h.id = :doc_list_id into v_linked_client_order; delete from tmp$result_set r where r.doc_id = :doc_list_id; insert into tmp$result_set( doc_id, base_doc_id, doc_data_id, ware_id, qty, cost_purchase, cost_retail ) select :doc_list_id, :v_linked_client_order, d.id, d.ware_id, d.qty, d.cost_purchase, d.cost_retail from doc_data d where d.doc_id = :doc_list_id; delete from doc_list h where h.id = :doc_list_id; execute procedure sp_add_perf_log(0, v_this, null, 'doc_id='||doc_list_id); v_stt = 'select r.doc_id,r.base_doc_id,r.doc_data_id,r.ware_id,r.qty,r.cost_purchase,r.cost_retail'; if ( v_ibe = 1 ) then v_stt = v_stt || ' ,n.qty_ord,       n.qty_avl,       n.qty_res'; else v_stt = v_stt || ' ,null as qty_ord, null as qty_avl, null as qty_res'; v_stt = v_stt ||' from tmp$result_set r'; if ( v_ibe = 1 ) then v_stt = v_stt || ' left join v_saldo_invnt n on r.ware_id = n.ware_id'; v_stt = v_stt || ' where r.doc_id = :x'; for execute statement (v_stt) ( x := :doc_list_id) into doc_list_id ,client_order_id ,doc_data_id ,ware_id ,qty ,purchase ,retail ,qty_ord ,qty_avl ,qty_res do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_cancel_write_off( a_selected_doc_id type of dm_ids default null, a_skip_lock_attempt dm_sign default 0 ) returns ( doc_list_id type of dm_ids, client_order_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail type of dm_cost, qty_avl type of dm_qty, qty_res type of dm_qty, qty_out type of dm_qty ) as declare v_dummy bigint; declare v_ibe smallint; declare v_stt varchar(255); declare v_agent_id type of dm_ids; declare v_linked_client_order type of dm_ids; declare v_this dm_dbobj = 'sp_cancel_write_off'; declare c_raise_exc_when_no_found dm_sign = 1; declare c_can_skip_order_clause dm_sign = 0; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); doc_list_id = coalesce( :a_selected_doc_id, fn_get_random_id( 'v_cancel_write_off' ,null ,null ,c_raise_exc_when_no_found ,c_can_skip_order_clause ) ); if (  NOT (a_selected_doc_id is NOT null and a_skip_lock_attempt = 1) ) then execute procedure sp_lock_selected_doc( doc_list_id, 'v_cancel_write_off', a_selected_doc_id); update doc_list h set h.state_id = fn_doc_open_state(), h.optype_id = fn_oper_retail_reserve(), dts_fix = null, dts_clos = null where h.id = :doc_list_id returning h.base_doc_id into client_order_id; execute procedure sp_add_perf_log(0, v_this, null, 'doc_id='||doc_list_id); v_stt = 'select d.doc_id, d.ware_id, d.qty, d.cost_purchase, d.cost_retail'; if ( v_ibe = 1 ) then v_stt = v_stt || ',d.doc_data_id ,d.qty_avl ,d.qty_res  ,d.qty_out from v_doc_detailed d'; else v_stt = v_stt || ',d.id         ,null      ,null       ,null      from doc_data d'; v_stt = v_stt || ' where d.doc_id = :x'; for execute statement (v_stt) ( x := :doc_list_id ) into doc_list_id ,ware_id ,qty ,purchase ,retail ,doc_data_id ,qty_avl ,qty_res ,qty_out do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_get_clo_for_invoice( a_selected_doc_id dm_ids ) returns ( clo_doc_id type of dm_ids, clo_agent_id type of dm_ids ) as declare v_dbkey dm_dbkey; declare v_qty_acc dm_qty; declare v_qty_sup type of dm_qty; declare v_qty_clo_still_not_reserved dm_qty; declare v_clo_doc_id dm_ids; declare v_clo_agent_id dm_ids; declare v_ware_id dm_ids; declare v_cnt int = 0; declare v_this dm_dbobj = 'sp_get_clo_for_invoice'; declare v_oper_order_by_customer dm_ids; declare v_oper_retail_reserve dm_ids; begin execute procedure sp_add_perf_log(1, v_this); v_oper_order_by_customer =  fn_oper_order_by_customer(); v_oper_retail_reserve = fn_oper_retail_reserve(); delete from tmp$dep_docs d where d.base_doc_id = :a_selected_doc_id; for select d.ware_id, d.qty from doc_data d where d.doc_id = :a_selected_doc_id into v_ware_id, v_qty_sup do begin v_qty_acc = 0; for select x.clo_doc_id, x.clo_qty, h.agent_id from ( select q.doc_id as clo_doc_id, sum(q.snd_qty) as clo_qty from qdistr q where q.ware_id = :v_ware_id and q.snd_optype_id = :v_oper_order_by_customer and q.rcv_optype_id = :v_oper_retail_reserve group by q.doc_id ) x join doc_list h on x.clo_doc_id = h.id and h.optype_id = :v_oper_order_by_customer into v_clo_doc_id, v_qty_clo_still_not_reserved, v_clo_agent_id do begin insert into tmp$dep_docs( base_doc_id, dependend_doc_id, dependend_doc_agent_id, ware_id, base_doc_qty, dependend_doc_qty ) values(:a_selected_doc_id, :v_clo_doc_id, :v_clo_agent_id, :v_ware_id, :v_qty_sup, :v_qty_clo_still_not_reserved ); v_cnt = v_cnt + 1; v_qty_acc = v_qty_acc + v_qty_clo_still_not_reserved; if ( v_qty_acc >= v_qty_sup ) then leave; when any do begin if ( NOT fn_is_uniqueness_trouble(gdscode) ) then exception; end end end execute procedure sp_add_perf_log(0, v_this, null, 'doc_id='||a_selected_doc_id||', clo_cnt='||v_cnt); for select f.dependend_doc_id, f.dependend_doc_agent_id from tmp$dep_docs f where f.base_doc_id = :a_selected_doc_id order by f.dependend_doc_id into clo_doc_id, clo_agent_id do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(a_selected_doc_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_add_invoice_to_stock( a_selected_doc_id type of dm_ids default null, a_cancel_mode dm_sign default 0, a_skip_lock_attempt dm_sign default 0, dbg int default 0 ) returns ( doc_list_id type of dm_ids, agent_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, qty_sup type of dm_qty, qty_avl type of dm_qty, qty_res type of dm_qty, res_ok int, res_err int, res_nul int ) as declare v_dummy bigint; declare v_ibe smallint; declare v_stt varchar(255); declare v_info dm_info; declare v_new_doc_state type of dm_ids; declare v_old_oper_id type of dm_ids; declare v_new_oper_id type of dm_ids; declare v_client_order type of dm_ids; declare v_linked_reserve_id type of dm_ids; declare v_linked_reserve_state type of dm_ids; declare v_view_for_search dm_dbobj; declare v_this dm_dbobj = 'sp_add_invoice_to_stock'; declare c_raise_exc_when_no_found dm_sign = 1; declare c_can_skip_order_clause dm_sign = 0; declare function fn_internal_enable_reserving() returns boolean deterministic as begin return rdb$get_context('USER_SESSION', 'ENABLE_RESERVES_WHEN_ADD_INVOICE')='1'; end begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; if ( a_cancel_mode = 1 ) then v_this = 'sp_cancel_adding_invoice'; execute procedure sp_add_perf_log(1, v_this); execute procedure sp_check_ctx('USER_SESSION', 'ENABLE_RESERVES_WHEN_ADD_INVOICE'); v_new_doc_state = iif( a_cancel_mode = 0, fn_doc_fix_state(),  fn_doc_open_state() ); v_old_oper_id = iif( a_cancel_mode = 0, fn_oper_invoice_get(), fn_oper_invoice_add() ); v_new_oper_id = iif( a_cancel_mode = 0, fn_oper_invoice_add(), fn_oper_invoice_get() ); v_view_for_search = iif( a_cancel_mode = 0, 'v_add_invoice_to_stock', 'v_cancel_adding_invoice' ); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); doc_list_id = coalesce( :a_selected_doc_id, fn_get_random_id( v_view_for_search ,null ,null ,c_raise_exc_when_no_found ,c_can_skip_order_clause ) ); execute procedure sp_upd_in_perf_log(v_this, null, 'doc_id='||doc_list_id); if (  NOT (a_selected_doc_id is NOT null and a_skip_lock_attempt = 1) ) then execute procedure sp_lock_selected_doc( doc_list_id, v_view_for_search, a_selected_doc_id); res_ok = 0; res_err = 0; res_nul = 0; while (1=1) do begin if ( a_cancel_mode = 1 ) then begin execute procedure sp_lock_dependent_docs( :doc_list_id, :v_old_oper_id ); for select d.dependend_doc_id, d.dependend_doc_state from tmp$dep_docs d where d.base_doc_id = :doc_list_id into v_linked_reserve_id, v_linked_reserve_state do begin if ( v_linked_reserve_state <> fn_doc_open_state() ) then select count(*) from sp_cancel_write_off( :v_linked_reserve_id, 1 ) into v_dummy; select count(*) from sp_cancel_customer_reserve(:v_linked_reserve_id, 1 ) into v_dummy; res_ok = res_ok + 1; end end update doc_list h set h.optype_id = :v_new_oper_id, h.state_id = :v_new_doc_state, dts_fix = iif( :a_cancel_mode = 0, 'now', null ) where h.id = :doc_list_id; if (dbg=1) then leave; v_client_order = null; if (a_cancel_mode = 0) then begin if (dbg=3) then leave; if (fn_internal_enable_reserving() ) then begin for select p.clo_doc_id from sp_get_clo_for_invoice( :doc_list_id  ) p where not exists( select * from v_our_firm v where v.id = p.clo_agent_id order by v.id ) into v_client_order do begin select min(doc_list_id) from sp_customer_reserve( :v_client_order, iif(:dbg=4, 2, null) ) into v_linked_reserve_id; if (  v_linked_reserve_id is null ) then res_nul = res_nul + 1; else res_ok = res_ok + 1; when any do begin if ( fn_is_lock_trouble(gdscode) ) then begin execute procedure sp_add_to_abend_log( 'can`t create res', gdscode, 'clo_id='||coalesce(v_client_order, '<null>'), v_this ); res_err = res_err + 1; end else begin execute procedure sp_add_to_abend_log('', gdscode, 'doc_id='||doc_list_id, v_this ); exception; end end end end end leave; end execute procedure sp_add_perf_log(0, v_this, null, 'dh='||doc_list_id, res_ok, res_nul); if (  v_ibe = 1 ) then v_stt = 'select v.agent_id, v.doc_data_id, v.ware_id, v.qty, v.cost_purchase, v.qty_sup, v.qty_avl, v.qty_res' ||' from v_doc_detailed v where v.doc_id = :x'; else v_stt = 'select h.agent_id, d.id,          d.ware_id, d.qty, d.cost_purchase, null,     null,       null ' ||' from doc_data d join doc_list h on d.doc_id = h.id where d.doc_id = :x'; for execute statement (v_stt) ( x := :doc_list_id ) into agent_id ,doc_data_id ,ware_id ,qty ,purchase ,qty_sup ,qty_avl ,qty_res do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_cancel_adding_invoice( a_selected_doc_id type of dm_ids default null, a_skip_lock_attempt dm_sign default 0, dbg int default 0 ) returns ( doc_list_id type of dm_ids, agent_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, qty_sup type of dm_qty, qty_avl type of dm_qty, qty_res type of dm_qty, res_ok int, res_err int ) as declare v_dummy bigint; declare v_ibe smallint; declare v_stt varchar(255); declare v_this dm_dbobj = 'sp_cancel_adding_invoice'; begin select min(doc_list_id), min(res_ok), min(res_err) from sp_add_invoice_to_stock( :a_selected_doc_id, 1, :a_skip_lock_attempt, :dbg ) into doc_list_id, res_ok, res_err; v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); if ( v_ibe = 1 ) then v_stt = 'select v.agent_id, v.doc_data_id, v.ware_id, v.qty, v.cost_purchase, v.qty_sup, v.qty_avl, v.qty_res' ||' from v_doc_detailed v where v.doc_id = :x'; else v_stt = 'select h.agent_id, d.id,          d.ware_id, d.qty, d.cost_purchase, null,      null,      null' ||' from doc_data d join doc_list h on d.doc_id = h.id where d.doc_id = :x'; for execute statement (v_stt) ( x := :doc_list_id ) into agent_id ,doc_data_id ,ware_id ,qty ,purchase ,qty_sup ,qty_avl ,qty_res do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_cancel_supplier_order( a_selected_doc_id type of dm_ids default null) returns ( doc_list_id type of dm_ids, agent_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail type of dm_cost, qty_clo type of dm_qty, qty_ord type of dm_qty ) as declare v_dummy bigint; declare v_ibe smallint; declare v_stt varchar(255); declare v_info dm_info = ''; declare v_linked_invoice_id bigint; declare v_linked_invoice_state bigint; declare v_linked_reserve_id bigint; declare v_linked_reserve_state bigint; declare v_this dm_dbobj = 'sp_cancel_supplier_order'; declare c_raise_exc_when_no_found dm_sign = 1; declare c_can_skip_order_clause dm_sign = 0; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); doc_list_id = coalesce( :a_selected_doc_id, fn_get_random_id( 'v_cancel_supplier_order' ,null ,null ,c_raise_exc_when_no_found ,c_can_skip_order_clause ) ); v_info = 'dh='||doc_list_id; execute procedure sp_lock_selected_doc( doc_list_id, 'v_cancel_supplier_order', a_selected_doc_id); execute procedure sp_lock_dependent_docs( :doc_list_id, fn_oper_order_for_supplier() ); for select d.dependend_doc_id as linked_invoice_id from tmp$dep_docs d where d.base_doc_id = :doc_list_id order by d.base_doc_id+0 into v_linked_invoice_id do begin execute procedure sp_lock_dependent_docs(:v_linked_invoice_id, fn_oper_invoice_add()); end for select d.dependend_doc_id, d.dependend_doc_state from tmp$dep_docs d where d.base_doc_id <> :doc_list_id group by 1,2 into v_linked_reserve_id, v_linked_reserve_state do begin if ( v_linked_reserve_state <> fn_doc_open_state() ) then select count(*) from sp_cancel_write_off( :v_linked_reserve_id, 1 ) into v_dummy; select count(*) from sp_cancel_customer_reserve(:v_linked_reserve_id, 1 ) into v_dummy; end for select d.dependend_doc_id, d.dependend_doc_state from tmp$dep_docs d where d.base_doc_id = :doc_list_id into v_linked_invoice_id, v_linked_invoice_state do begin if ( v_linked_invoice_state <> fn_doc_open_state() ) then select count(*) from sp_cancel_adding_invoice( :v_linked_invoice_id, 1 ) into v_dummy; select count(*) from sp_cancel_supplier_invoice( :v_linked_invoice_id, 1 ) into v_dummy; end delete from tmp$result_set r where r.doc_id = :doc_list_id; insert into tmp$result_set( doc_id, agent_id, doc_data_id, ware_id, qty, cost_purchase, cost_retail) select :doc_list_id, h.agent_id, d.id, d.ware_id, d.qty, d.cost_purchase, d.cost_retail from doc_data d join doc_list h on d.doc_id = h.id where d.doc_id = :doc_list_id; delete from doc_list h where h.id = :doc_list_id; execute procedure sp_add_perf_log(0, v_this,null, v_info); v_stt = 'select r.agent_id,r.doc_data_id,r.ware_id,r.qty,r.cost_purchase,r.cost_retail'; if ( v_ibe = 1 ) then v_stt = v_stt ||' ,n.qty_clo,n.qty_ord' ||' from tmp$result_set r left join v_saldo_invnt n on r.ware_id = n.ware_id'; else v_stt = v_stt ||' ,null     ,null from tmp$result_set r'; v_stt = v_stt || ' where r.doc_id = :x'; for execute statement (v_stt) ( x := :doc_list_id ) into agent_id ,doc_data_id ,ware_id ,qty ,purchase ,retail ,qty_clo ,qty_ord do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, v_info, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_reserve_write_off(a_selected_doc_id type of dm_ids default null) returns ( doc_list_id type of dm_ids, client_order_id type of dm_ids, doc_data_id type of dm_ids, ware_id type of dm_ids, qty type of dm_qty, purchase type of dm_cost, retail  type of dm_cost, qty_avl type of dm_qty, qty_res type of dm_qty, qty_out type of dm_qty ) as declare v_linked_client_order type of dm_ids; declare v_ibe smallint; declare v_stt varchar(255); declare v_dummy bigint; declare v_this dm_dbobj = 'sp_reserve_write_off'; declare c_raise_exc_when_no_found dm_sign = 1; declare c_can_skip_order_clause dm_sign = 0; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); v_ibe = iif( fn_remote_process() containing 'IBExpert', 1, 0); doc_list_id = coalesce( :a_selected_doc_id, fn_get_random_id( 'v_reserve_write_off' ,null ,null ,c_raise_exc_when_no_found ,c_can_skip_order_clause ) ); execute procedure sp_lock_selected_doc( doc_list_id, 'v_reserve_write_off', a_selected_doc_id); update doc_list h set h.state_id = fn_doc_fix_state(), h.optype_id = fn_oper_retail_realization() where h.id = :doc_list_id returning h.base_doc_id into client_order_id; execute procedure sp_add_perf_log(0, v_this, null, 'doc_id='||doc_list_id); if ( v_ibe = 1 ) then v_stt = 'select v.doc_data_id,v.ware_id,v.qty,v.cost_purchase,v.cost_retail' ||',v.qty_avl,v.qty_res,v.qty_out' ||' from v_doc_detailed v where v.doc_id = :x'; else v_stt = 'select d.id,d.ware_id,d.qty,d.cost_purchase,d.cost_retail' ||',null     ,null     ,null' ||' from doc_data d where d.doc_id = :x'; for execute statement (v_stt) ( x := :doc_list_id ) into doc_data_id ,ware_id ,qty ,purchase ,retail ,qty_avl ,qty_res ,qty_out do suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_payment_common( a_payment_oper dm_ids, a_selected_doc_id type of dm_ids default null, a_total_pay type of dm_cost default null ) returns ( source_doc_id type of dm_ids, agent_id type of dm_ids, current_pay_sum type of dm_cost ) as declare v_stt varchar(255); declare v_source_for_random_id dm_dbobj; declare v_source_for_min_id dm_dbobj; declare v_source_for_max_id dm_dbobj; declare v_can_skip_order_clause smallint; declare v_find_using_desc_index dm_sign; declare view_to_search_agent dm_dbobj; declare v_non_paid_total type of dm_cost; declare v_round_to smallint; declare v_id bigint; declare v_dummy bigint; declare v_this dm_dbobj = 'sp_payment_common'; begin execute procedure sp_add_perf_log(1, v_this,null); v_source_for_random_id = decode( a_payment_oper, fn_oper_pay_from_customer(), 'v_random_find_non_paid_realizn', fn_oper_pay_to_supplier(),   'v_random_find_non_paid_invoice', 'unknown_source' ); v_source_for_min_id = decode( a_payment_oper, fn_oper_pay_from_customer(), 'v_min_non_paid_realizn', fn_oper_pay_to_supplier(),   'v_min_non_paid_invoice', null ); v_source_for_max_id = decode( a_payment_oper, fn_oper_pay_from_customer(), 'v_max_non_paid_realizn', fn_oper_pay_to_supplier(),   'v_max_non_paid_invoice', null ); v_can_skip_order_clause = decode( a_payment_oper, fn_oper_pay_from_customer(), 1, fn_oper_pay_to_supplier(),   1, 0 ); v_find_using_desc_index = decode( a_payment_oper, fn_oper_pay_from_customer(), 1, fn_oper_pay_to_supplier(),   1, 0 ); view_to_search_agent = iif( a_payment_oper = fn_oper_pay_from_customer(), 'v_all_customers', 'v_all_suppliers'); v_round_to = iif( a_payment_oper = fn_oper_pay_from_customer(), -2, -3); if ( :a_selected_doc_id is null ) then begin source_doc_id = fn_get_random_id( v_source_for_random_id, v_source_for_min_id, v_source_for_max_id, 0, v_can_skip_order_clause, v_find_using_desc_index ); if ( source_doc_id is not null ) then begin select agent_id from doc_list h where h.id = :source_doc_id into agent_id; end end else select :a_selected_doc_id, h.agent_id from doc_list h where h.id = :a_selected_doc_id into source_doc_id, agent_id; if ( source_doc_id is not null ) then begin select h.agent_id from doc_list h where h.id = :a_selected_doc_id into agent_id; if ( agent_id is null ) then exception ex_no_doc_found_for_handling using('doc_list', a_selected_doc_id); if ( a_total_pay is null ) then begin select sum( p.snd_cost ) from pdistr p where p.snd_id = :source_doc_id into v_non_paid_total; current_pay_sum = round( v_non_paid_total, v_round_to ); if (current_pay_sum < v_non_paid_total) then begin current_pay_sum = current_pay_sum + power(10, abs(v_round_to)); end end else current_pay_sum = a_total_pay; end else begin agent_id = fn_get_random_id( view_to_search_agent, null, null, 0 ); if ( a_total_pay is null ) then begin if (a_payment_oper = fn_oper_pay_from_customer() ) then current_pay_sum = round(fn_get_random_cost('C_PAYMENT_FROM_CLIENT_MIN_TOTAL', 'C_PAYMENT_FROM_CLIENT_MAX_TOTAL'), v_round_to); else current_pay_sum = round(fn_get_random_cost('C_PAYMENT_TO_SUPPLIER_MIN_TOTAL', 'C_PAYMENT_TO_SUPPLIER_MAX_TOTAL'), v_round_to); end else current_pay_sum = a_total_pay; end execute procedure sp_add_perf_log(0, v_this,null,'doc_id='||coalesce(source_doc_id, '<null>') ); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(source_doc_id, '<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_pay_from_customer( a_selected_doc_id type of dm_ids default null, a_total_pay type of dm_cost default null, dbg int default 0 ) returns ( agent_id type of dm_ids, prepayment_id type of dm_ids, realization_id type of dm_ids, current_pay_sum type of dm_cost ) as declare v_dbkey dm_dbkey; declare v_this dm_dbobj = 'sp_pay_from_customer'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); execute procedure sp_payment_common( fn_oper_pay_from_customer(), a_selected_doc_id, a_total_pay ) returning_values realization_id, agent_id, current_pay_sum; execute procedure sp_add_doc_list( null, fn_oper_pay_from_customer(), agent_id, null, null, 0, current_pay_sum ) returning_values :prepayment_id, :v_dbkey; execute procedure sp_add_perf_log(0, v_this, null, 'payment_id='||prepayment_id); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(prepayment_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_cancel_pay_from_customer( a_selected_doc_id type of dm_ids default null ) returns ( doc_list_id type of dm_ids, agent_id type of dm_ids, prepayment_sum type of dm_cost ) as declare v_dummy bigint; declare c_raise_exc_when_no_found dm_sign = 1; declare c_can_skip_order_clause dm_sign = 0; declare v_this dm_dbobj = 'sp_cancel_pay_from_customer'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); doc_list_id = coalesce( :a_selected_doc_id, fn_get_random_id( 'v_cancel_customer_prepayment' ,null ,null ,c_raise_exc_when_no_found ,c_can_skip_order_clause ) ); execute procedure sp_lock_selected_doc( doc_list_id, 'v_cancel_customer_prepayment', a_selected_doc_id); select agent_id, cost_retail from doc_list h where h.id = :doc_list_id into agent_id, prepayment_sum; delete from doc_list h where h.id = :doc_list_id; execute procedure sp_add_perf_log(0, v_this, null, 'doc_id='||doc_list_id); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_pay_to_supplier( a_selected_doc_id type of dm_ids default null, a_total_pay type of dm_cost default null, dbg int default 0 ) returns ( agent_id type of dm_ids, prepayment_id type of dm_ids, invoice_id type of dm_ids, current_pay_sum type of dm_cost ) as declare v_dbkey dm_dbkey; declare v_round_to smallint; declare v_id type of dm_ids; declare v_this dm_dbobj = 'sp_pay_to_supplier'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); execute procedure sp_payment_common( fn_oper_pay_to_supplier(), a_selected_doc_id, a_total_pay ) returning_values invoice_id, agent_id, current_pay_sum; execute procedure sp_add_doc_list( null, fn_oper_pay_to_supplier(), agent_id, null, null, current_pay_sum, 0 ) returning_values :prepayment_id, :v_dbkey; execute procedure sp_add_perf_log(0, v_this, null, 'payment_id='||prepayment_id); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(prepayment_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure sp_cancel_pay_to_supplier( a_selected_doc_id type of dm_ids default null ) returns ( doc_list_id type of dm_ids, agent_id type of dm_ids, prepayment_sum type of dm_cost ) as declare v_dummy bigint; declare v_this dm_dbobj = 'sp_cancel_pay_to_supplier'; declare c_raise_exc_when_no_found dm_sign = 1; declare c_can_skip_order_clause dm_sign = 0; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; execute procedure sp_add_perf_log(1, v_this); doc_list_id = coalesce( :a_selected_doc_id, fn_get_random_id( 'v_cancel_payment_to_supplier' ,null ,null ,c_raise_exc_when_no_found ,c_can_skip_order_clause ) ); execute procedure sp_lock_selected_doc( doc_list_id, 'v_cancel_payment_to_supplier', a_selected_doc_id); select agent_id, cost_purchase from doc_list h where h.id = :doc_list_id into agent_id, prepayment_sum; delete from doc_list h where h.id = :doc_list_id; execute procedure sp_add_perf_log(0, v_this, null, 'doc_id='||doc_list_id); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'doc_id='||coalesce(doc_list_id,'<null>'), v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure srv_make_invnt_saldo( a_selected_ware_id type of dm_ids default null ) returns ( msg dm_info, ins_rows int, upd_rows int, del_rows int ) as declare v_semaphore_id type of dm_ids; declare v_deferred_to_next_time boolean = false; declare v_gdscode int = null; declare v_catch_bitset bigint; declare v_exc_on_chk_violation smallint; declare v_this dm_dbobj = 'srv_make_invnt_saldo'; declare s_qty_clo type of dm_qty; declare s_qty_clr type of dm_qty; declare s_qty_ord type of dm_qty; declare s_qty_sup type of dm_qty; declare s_qty_avl type of dm_qty; declare s_qty_res type of dm_qty; declare s_qty_inc type of dm_qty; declare s_qty_out type of dm_qty; declare s_cost_inc type of dm_cost; declare s_cost_out type of dm_cost; declare v_rc int; declare v_err_msg dm_info; declare v_neg_info dm_info; declare c_chk_violation_code int = 335544558; begin v_catch_bitset = cast(rdb$get_context('USER_SESSION','QMISM_VERIFY_BITSET') as bigint); if ( bin_and( v_catch_bitset, 2 ) = 2 ) then exit; execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; if ( not fn_is_snapshot() ) then exception ex_snapshot_isolation_required; begin v_semaphore_id = null; select id from semaphores s where s.task = :v_this with lock into v_semaphore_id; if (v_semaphore_id is null) then exception ex_record_not_found using('semaphores', v_this); when any do begin if ( fn_is_lock_trouble(gdscode) ) then begin v_deferred_to_next_time = true; select e.fb_mnemona from fb_errors e where e.fb_gdscode = gdscode into msg; v_gdscode = gdscode; del_rows = -gdscode; end else exception; end end if ( v_deferred_to_next_time ) then begin suspend; exit; end execute procedure sp_add_perf_log(1, v_this); ins_rows = 0; upd_rows = 0; del_rows = 0; v_neg_info = ''; v_exc_on_chk_violation = iif( rdb$get_context('USER_SESSION', 'HALT_TEST_ON_ERRORS') containing ',CK,', 1, 0); for select ware_id, qty_clo, qty_clr, qty_ord, qty_sup, qty_avl, qty_res, qty_inc, qty_out, cost_inc, cost_out from v_saldo_invnt sn as cursor cn do begin s_qty_clo=0; s_qty_clr=0; s_qty_ord=0; s_qty_sup=0; s_qty_avl=0; s_qty_res=0; s_qty_inc=0; s_qty_out=0; s_cost_inc=0; s_cost_out=0; select qty_clo, qty_clr, qty_ord, qty_sup, qty_avl, qty_res, qty_inc, qty_out, cost_inc, cost_out from invnt_saldo t where t.id = cn.ware_id into s_qty_clo, s_qty_clr, s_qty_ord, s_qty_sup ,s_qty_avl, s_qty_res, s_qty_inc,s_qty_out ,s_cost_inc, s_cost_out; v_rc = row_count; s_qty_clo = s_qty_clo + cn.qty_clo; s_qty_clr = s_qty_clr + cn.qty_clr; s_qty_ord = s_qty_ord + cn.qty_ord; s_qty_sup = s_qty_sup + cn.qty_sup; s_qty_avl = s_qty_avl + cn.qty_avl; s_qty_res = s_qty_res + cn.qty_res; s_qty_inc = s_qty_inc + cn.qty_inc; s_qty_out = s_qty_out + cn.qty_out; s_cost_inc = s_cost_inc + cn.cost_inc; s_cost_out = s_cost_out + cn.cost_out; v_err_msg=''; if ( s_qty_clo < 0 ) then v_err_msg = v_err_msg||' clo='||s_qty_clo; if ( s_qty_clr < 0 ) then v_err_msg = v_err_msg||' clr='||s_qty_clr; if ( s_qty_ord < 0 ) then v_err_msg = v_err_msg||' ord='||s_qty_ord; if ( s_qty_sup < 0 ) then v_err_msg = v_err_msg||' sup='||s_qty_sup; if ( s_qty_avl < 0 ) then v_err_msg = v_err_msg||' avl='||s_qty_avl; if ( s_qty_res < 0 ) then v_err_msg = v_err_msg||' res='||s_qty_res; if ( s_qty_inc < 0 ) then v_err_msg = v_err_msg||' inc='||s_qty_inc; if ( s_qty_out < 0 ) then v_err_msg = v_err_msg||' out='||s_qty_out; if ( s_cost_inc < 0 ) then v_err_msg = v_err_msg||' $inc='||s_cost_inc; if ( s_cost_out < 0 ) then v_err_msg = v_err_msg||' $out='||s_cost_out; if ( v_err_msg >  '' and v_neg_info = '' ) then v_neg_info = 'ware='||cn.ware_id||v_err_msg; if ( v_neg_info > '' ) then begin rdb$set_context( 'USER_SESSION','ADD_INFO', v_neg_info ); msg = v_neg_info||'; '||msg; execute procedure sp_upd_in_perf_log( v_this, c_chk_violation_code, msg ); end if ( v_err_msg = '' or v_exc_on_chk_violation = 1 ) then begin update or insert into invnt_saldo( id ,qty_clo,qty_clr,qty_ord,qty_sup ,qty_avl,qty_res,qty_inc,qty_out ,cost_inc,cost_out ) values ( cn.ware_id ,:s_qty_clo,:s_qty_clr,:s_qty_ord,:s_qty_sup ,:s_qty_avl,:s_qty_res,:s_qty_inc,:s_qty_out ,:s_cost_inc,:s_cost_out ) matching(id); delete from invnt_turnover_log ng where ng.ware_id = cn.ware_id; del_rows = del_rows + row_count; ins_rows = ins_rows + iif( v_rc=0, 1, 0 ); upd_rows = upd_rows + iif( v_rc=0, 0, 1 ); end end msg = 'i='||ins_rows||', u='||upd_rows||', d='||del_rows; if ( v_neg_info = '' ) then rdb$set_context('USER_SESSION','ADD_INFO', msg); execute procedure sp_add_perf_log(0, v_this, v_gdscode, msg ); suspend; when any do begin execute procedure sp_add_to_abend_log( msg, gdscode, v_neg_info, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure srv_make_money_saldo( a_selected_agent_id type of dm_ids default null ) returns ( msg dm_info, ins_rows int, upd_rows int, del_rows int ) as declare v_semaphore_id type of dm_ids; declare v_deferred_to_next_time boolean = false; declare v_gdscode int = null; declare v_dbkey dm_dbkey; declare agent_id type of dm_ids; declare m_cust_debt dm_sign; declare m_supp_debt dm_sign; declare cost_purchase type of dm_cost; declare cost_retail type of dm_cost; declare v_dts_beg timestamp; declare v_dummy bigint; declare v_this dm_dbobj = 'srv_make_money_saldo'; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; if ( not fn_is_snapshot() ) then exception ex_snapshot_isolation_required; begin v_semaphore_id = null; select id from semaphores s where s.task = :v_this with lock into v_semaphore_id; if (v_semaphore_id is null) then exception ex_record_not_found using('semaphores', v_this); when any do begin if ( fn_is_lock_trouble(gdscode) ) then begin v_deferred_to_next_time = true; select e.fb_mnemona from fb_errors e where e.fb_gdscode = gdscode into msg; v_gdscode = gdscode; end else exception; end end if ( v_deferred_to_next_time ) then begin suspend; exit; end execute procedure sp_add_perf_log(1, v_this); ins_rows = 0; upd_rows = 0; del_rows = 0; v_dts_beg = 'now'; for select m.rdb$db_key, m.agent_id, o.m_supp_debt, o.m_cust_debt, m.cost_purchase, m.cost_retail from money_turnover_log m join optypes o on m.optype_id = o.id into v_dbkey, agent_id, m_supp_debt, m_cust_debt, cost_purchase, cost_retail do begin delete from money_turnover_log m where m.rdb$db_key = :v_dbkey; del_rows = del_rows + 1; update money_saldo set cost_purchase = cost_purchase + :m_supp_debt * :cost_purchase, cost_retail = cost_retail + :m_cust_debt * :cost_retail where agent_id = :agent_id; if ( row_count = 0 ) then begin insert into money_saldo( agent_id, cost_purchase, cost_retail ) values( :agent_id, :m_supp_debt * :cost_purchase, :m_cust_debt * :cost_retail); ins_rows = ins_rows + 1; end else upd_rows = upd_rows + 1; end msg = 'i='||ins_rows||', u='||upd_rows||', d='||del_rows ||', ms='||datediff(millisecond from v_dts_beg to cast('now' as timestamp) ); rdb$set_context('USER_SESSION','ADD_INFO', msg); execute procedure sp_add_perf_log(0, v_this, v_gdscode, msg ); suspend; when any do begin execute procedure sp_add_to_abend_log( '', gdscode, 'agent_id='||agent_id, v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure srv_recalc_idx_stat returns( tab_name dm_dbobj, idx_name dm_dbobj, elapsed_ms int ) as declare v_semaphore_id type of dm_ids; declare v_deferred_to_next_time boolean = false; declare v_dummy bigint; declare idx_stat_befo double precision; declare v_gdscode int = null; declare v_this dm_dbobj = 'srv_recalc_idx_stat'; declare v_start timestamp; begin execute procedure sp_check_to_stop_work; execute procedure sp_check_nowait_or_timeout; begin v_semaphore_id = null; select id from semaphores s where s.task = :v_this with lock into v_semaphore_id; if (v_semaphore_id is null) then exception ex_record_not_found using('semaphores', v_this); when any do begin if ( fn_is_lock_trouble(gdscode) ) then begin v_deferred_to_next_time = true; v_gdscode = gdscode; end else exception; end end execute procedure sp_add_perf_log(1, v_this); if ( v_deferred_to_next_time ) then begin tab_name='semaphore_locked'; idx_name='deferred, gds='||v_gdscode; suspend; end else begin for select ri.rdb$relation_name, ri.rdb$index_name, ri.rdb$statistics from rdb$indices ri where coalesce(ri.rdb$system_flag,0)=0 and ri.rdb$relation_name in ( 'DOC_DATA', 'DOC_LIST', 'QDISTR', 'QSTORNED', 'PDISTR', 'PSTORNED') order by ri.rdb$relation_name, ri.rdb$index_name into tab_name, idx_name, idx_stat_befo do begin execute procedure sp_check_to_stop_work; execute procedure sp_add_perf_log(1, v_this||'_'||idx_name); v_start='now'; execute statement( 'set statistics index '||idx_name ); execute procedure sp_add_perf_log(0, v_this||'_'||idx_name,null,tab_name, idx_stat_befo); suspend; end end execute procedure sp_add_perf_log(0, v_this, v_gdscode); when any do begin execute procedure sp_add_to_abend_log('', gdscode, null, v_this ); exception; end end ^ create or alter procedure srv_mon_perf_total( a_last_hours smallint default 3, a_last_mins smallint default 0) returns ( business_action dm_info, job_beg varchar(16), job_end varchar(16), avg_times_per_minute numeric(12,2), avg_elapsed_ms int, successful_times_done int ) as declare v_all_minutes int; declare v_succ_all_times int; declare v_this dm_dbobj = 'srv_mon_perf_total'; begin a_last_hours = abs( a_last_hours ); a_last_mins = iif( a_last_mins between 0 and 59, a_last_mins, 0 ); delete from tmp$perf_log p  where p.stack = :v_this; insert into tmp$perf_log(unit, info, id, dts_beg, dts_end, aux1, aux2, stack) with a as( select maxvalue( x.last_job_start_dts, y.last_job_finish_dts ) as last_job_start_dts from ( select p.dts_beg as last_job_start_dts from perf_log p where p.unit = 'perf_watch_interval' order by dts_beg desc rows 1 ) x join ( select dateadd( -abs( :a_last_hours * 60 + :a_last_mins ) minute to p.dts_beg) as last_job_finish_dts from perf_log p where exists(select 1 from business_ops b where b.unit=p.unit order by b.unit) order by p.dts_beg desc rows 1 ) y on 1=1 ) ,p as( select g.unit ,min( g.dts_beg ) report_beg ,max( g.dts_end  ) report_end ,count(*) successful_times_done ,avg(g.elapsed_ms) successful_avg_ms from perf_log g join business_ops b on b.unit=g.unit join a on g.dts_beg >= a.last_job_start_dts where g.fb_gdscode is null group by g.unit ) select b.unit, b.info, b.sort_prior, p.report_beg, p.report_end, p.successful_times_done, p.successful_avg_ms, :v_this from business_ops b left join p on b.unit = p.unit; select nullif(datediff( minute from min_beg to max_end ),0), succ_all_times, left(cast(min_beg as varchar(24)),16), left(cast(max_end as varchar(24)),16) from ( select min(p.dts_beg) min_beg, max(p.dts_end) max_end, sum(p.aux1) succ_all_times from tmp$perf_log p where p.stack = :v_this ) into v_all_minutes, v_succ_all_times, job_beg, job_end; for select business_action ,avg_times_per_minute ,avg_elapsed_ms ,successful_times_done from ( select 0 as sort_prior ,'*** OVERALL *** for '|| :v_all_minutes ||' minutes: ' as business_action ,1.00*sum( aux1 ) / :v_all_minutes as avg_times_per_minute ,avg(aux2) as avg_elapsed_ms ,sum(aux1) as successful_times_done from tmp$perf_log p where p.stack = :v_this UNION ALL select p.id as sort_prior ,p.info as business_action ,1.00 * aux1 / maxvalue( 1, datediff( minute from p.dts_beg to p.dts_end ) ) as avg_times_per_minute ,aux2 as avg_elapsed_ms ,aux1 as successful_times_done from tmp$perf_log p where p.stack = :v_this ) x order by x.sort_prior into business_action ,avg_times_per_minute ,avg_elapsed_ms ,successful_times_done do suspend; delete from tmp$perf_log p  where p.stack = :v_this; end ^ create or alter procedure srv_mon_perf_dynamic( a_intervals_number smallint default 10, a_last_hours smallint default 3, a_last_mins smallint default 0) returns ( business_action dm_info ,interval_no smallint ,cnt_ok_per_minute int ,cnt_all int ,cnt_ok int ,cnt_err int ,err_prc numeric(12,2) ,ok_avg_ms int ,interval_beg timestamp ,interval_end timestamp ) as declare v_this dm_dbobj = 'srv_mon_perf_dynamic'; begin a_intervals_number = iif( a_intervals_number <= 0, 10, a_intervals_number); a_last_hours = abs( a_last_hours ); a_last_mins = iif( a_last_mins between 0 and 59, a_last_mins, 0 ); delete from tmp$perf_log p where p.stack = :v_this; insert into tmp$perf_log( unit ,info ,id ,dts_beg ,dts_end ,aux1 ,aux2 ,elapsed_ms ,stack ) with i as( select -abs( :a_last_hours * 60 + :a_last_mins ) as scan_bak_minutes ,:a_intervals_number as intervals_number from rdb$database ) ,a as( select maxvalue( x.last_added_watch_row_dts, y.first_measured_start_dts ) as first_job_start_dts ,y.last_job_finish_dts ,y.intervals_number from ( select p.dts_beg as last_added_watch_row_dts from perf_log p where p.unit = 'perf_watch_interval' order by dts_beg desc rows 1 ) x join ( select dateadd( i.scan_bak_minutes minute to p.dts_beg) as first_measured_start_dts ,p.dts_beg as last_job_finish_dts ,i.intervals_number from perf_log p join i on 1=1 where exists(select 1 from business_ops b where b.unit=p.unit order by b.unit) order by p.dts_beg desc rows 1 ) y on 1=1 ) ,d as( select a.first_job_start_dts ,a.last_job_finish_dts ,1+datediff(second from a.first_job_start_dts to a.last_job_finish_dts) / a.intervals_number as sec_for_one_interval from a ) ,p as( select g.unit ,b.info ,1+cast(datediff(second from d.first_job_start_dts to g.dts_beg) / d.sec_for_one_interval as int) as interval_no ,count(*) cnt_all ,count( iif( g.fb_gdscode is null, 1, null ) ) cnt_ok ,count( iif( g.fb_gdscode is NOT null, 1, null ) ) cnt_err ,100.00 * count( nullif(g.fb_gdscode,0) ) / count(*) err_prc ,avg(  iif( g.fb_gdscode is null, g.elapsed_ms, null ) ) ok_avg_ms ,min(d.first_job_start_dts) as first_job_start_dts ,min(d.sec_for_one_interval) as sec_for_one_interval from perf_log g join business_ops b on b.unit = g.unit join d on g.dts_beg >= d.first_job_start_dts group by 1,2,3 ) ,q as( select unit ,info ,interval_no ,dateadd( (interval_no-1) * sec_for_one_interval+1 second to first_job_start_dts ) as interval_beg ,dateadd( interval_no * sec_for_one_interval second to first_job_start_dts ) as interval_end ,cnt_all ,cnt_ok ,cnt_err ,err_prc ,ok_avg_ms from p ) select unit ,info ,interval_no ,interval_beg ,interval_end ,cnt_ok ,cnt_err ,ok_avg_ms ,:v_this from q; for select business_action ,interval_no ,cnt_ok_per_minute ,cnt_all ,cnt_ok ,cnt_err ,err_prc ,ok_avg_ms ,interval_beg ,interval_end from ( select 0 as sort_prior ,'interval #'||lpad(id, 4, ' ')||', overall' as business_action ,id as interval_no ,min(dts_beg) as interval_beg ,min(dts_end) as interval_end ,round(sum(aux1) / nullif(datediff(minute from min(dts_beg) to min(dts_end)),0), 0) cnt_ok_per_minute ,sum(aux1 + aux2) as cnt_all ,sum(aux1) as cnt_ok ,sum(aux2) as cnt_err ,100 * sum(aux2) / sum(aux1 + aux2) as err_prc ,cast(null as int) as ok_avg_ms from tmp$perf_log p where p.stack = :v_this group by id UNION ALL select 1 as sort_prior ,info as business_action ,id as interval_no ,dts_beg as interval_beg ,dts_end as interval_end ,aux1 / nullif(datediff(minute from dts_beg to dts_end),0) cnt_ok_per_minute ,aux1 + aux2 as cnt_all ,aux1 as cnt_ok ,aux2 as cnt_err ,100 * aux2 / (aux1 + aux2) as err_prc ,elapsed_ms as ok_avg_ms from tmp$perf_log p where p.stack = :v_this ) order by sort_prior, business_action, interval_no into business_action ,interval_no ,cnt_ok_per_minute ,cnt_all ,cnt_ok ,cnt_err ,err_prc ,ok_avg_ms ,interval_beg ,interval_end do suspend; end ^ create or alter procedure srv_mon_perf_detailed ( a_last_hours smallint default 3, a_last_mins smallint default 0, a_show_detl smallint default 0) returns ( unit type of dm_unit, cnt_all integer, cnt_ok integer, cnt_err integer, err_prc numeric(6,2), ok_min_ms integer, ok_max_ms integer, ok_avg_ms integer, cnt_lk_confl integer, cnt_user_exc integer, cnt_chk_viol integer, cnt_unq_viol integer, cnt_fk_viol integer, cnt_stack_trc integer, cnt_zero_gds integer, cnt_other_exc integer, dts_beg timestamp, dts_end timestamp ) as begin a_last_hours = abs( coalesce(a_last_hours, 3) ); a_last_mins = coalesce(a_last_mins, 0); a_last_mins = iif( a_last_mins between 0 and 59, a_last_mins, 0 ); delete from tmp$perf_mon where 1=1; insert into tmp$perf_mon( dts_beg ,dts_end ,unit ,cnt_all ,cnt_ok ,cnt_err ,err_prc ,ok_min_ms ,ok_max_ms ,ok_avg_ms ,cnt_chk_viol ,cnt_unq_viol ,cnt_fk_viol ,cnt_lk_confl ,cnt_user_exc ,cnt_stack_trc ,cnt_zero_gds ,cnt_other_exc ) with a as( select maxvalue( x.last_job_start_dts, y.last_job_finish_dts ) as last_job_start_dts from ( select p.dts_beg as last_job_start_dts from perf_log p where p.unit = 'perf_watch_interval' order by dts_beg desc rows 1 ) x join ( select dateadd( -abs( :a_last_hours * 60 + :a_last_mins ) minute to p.dts_beg) as last_job_finish_dts from perf_log p where exists(select 1 from business_ops b where b.unit=p.unit order by b.unit) order by p.dts_beg desc rows 1 ) y on 1=1 ) ,r as( select min(p.dts_beg) report_beg, max(dts_end) report_end from perf_log p join a on p.dts_beg >= a.last_job_start_dts ) ,c as ( select r.report_beg ,r.report_end ,pg.unit ,count(*) cnt_all ,count( iif( nullif(pg.fb_gdscode,0) is null, 1, null) ) cnt_ok ,count( nullif(pg.fb_gdscode,0) ) cnt_err ,100.00 * count( nullif(pg.fb_gdscode,0) ) / count(*) err_prc ,min( iif( nullif(pg.fb_gdscode,0) is null, pg.elapsed_ms, null) ) ok_min_ms ,max( iif( nullif(pg.fb_gdscode,0) is null, pg.elapsed_ms, null) ) ok_max_ms ,avg( iif( nullif(pg.fb_gdscode,0) is null, pg.elapsed_ms, null) ) ok_avg_ms ,count( iif(pg.fb_gdscode in( 335544347, 335544558 ), 1, null ) ) cnt_chk_viol ,count( iif(pg.fb_gdscode in( 335544665, 335544349 ), 1, null ) ) cnt_unq_viol ,count( iif(pg.fb_gdscode in( 335544466, 335544838, 335544839 ), 1, null ) ) cnt_fk_viol ,count( iif(pg.fb_gdscode in( 335544345, 335544878, 335544336, 335544451 ), 1, null ) ) cnt_lk_confl ,count( iif(pg.fb_gdscode = 335544517, 1, null) ) cnt_user_exc ,count( iif(pg.fb_gdscode = 335544842, 1, null) ) cnt_stack_trc ,count( iif(pg.fb_gdscode = 0, 1, null) ) cnt_zero_gds ,count( iif( pg.fb_gdscode in ( 335544347, 335544558, 335544665, 335544349, 335544466, 335544838, 335544839, 335544345, 335544878, 335544336, 335544451, 335544517, 335544842, 0 ) ,null ,pg.fb_gdscode ) ) cnt_other_exc from perf_log pg join r on pg.dts_beg between r.report_beg and r.report_end where pg.elapsed_ms >= 0 and pg.unit not starting with 'srv_recalc_idx_stat_' group by r.report_beg ,r.report_end ,pg.unit ) select * from c; insert into tmp$perf_mon( rollup_level ,unit ,cnt_all ,cnt_ok ,cnt_err ,err_prc ,ok_min_ms ,ok_max_ms ,ok_avg_ms ,cnt_chk_viol ,cnt_unq_viol ,cnt_fk_viol ,cnt_lk_confl ,cnt_user_exc ,cnt_stack_trc ,cnt_zero_gds ,cnt_other_exc ,dts_beg ,dts_end ) select 1 ,unit ,sum(cnt_all) ,sum(cnt_ok) ,sum(cnt_err) ,100.00 * sum(cnt_err) / sum(cnt_all) ,min(ok_min_ms) ,max(ok_max_ms) ,max(ok_avg_ms) ,sum( cnt_chk_viol ) cnt_chk_viol ,sum( cnt_unq_viol ) cnt_unq_viol ,sum( cnt_fk_viol ) cnt_fk_viol ,sum( cnt_lk_confl ) cnt_lk_confl ,sum( cnt_user_exc ) cnt_user_exc ,sum( cnt_stack_trc ) cnt_stack_trc ,sum( cnt_zero_gds ) cnt_zero_gds ,sum( cnt_other_exc ) cnt_other_exc ,max( dts_beg ) ,max( dts_end ) from tmp$perf_mon group by unit; if ( :a_show_detl = 0 ) then delete from tmp$perf_mon m where m.rollup_level is null; for select unit, cnt_all, cnt_ok, cnt_err, err_prc, ok_min_ms, ok_max_ms, ok_avg_ms ,cnt_chk_viol ,cnt_unq_viol ,cnt_fk_viol ,cnt_lk_confl ,cnt_user_exc ,cnt_stack_trc ,cnt_zero_gds ,cnt_other_exc ,dts_beg ,dts_end from tmp$perf_mon into unit, cnt_all, cnt_ok, cnt_err, err_prc, ok_min_ms, ok_max_ms, ok_avg_ms ,cnt_chk_viol ,cnt_unq_viol ,cnt_fk_viol ,cnt_lk_confl ,cnt_user_exc ,cnt_stack_trc ,cnt_zero_gds ,cnt_other_exc ,dts_beg ,dts_end do suspend; end ^ create or alter procedure srv_mon_business_perf_with_exc ( a_last_hours smallint default 3, a_last_mins smallint default 0) returns ( info dm_info, unit dm_unit, cnt_all integer, cnt_ok integer, cnt_err integer, err_prc numeric(6,2), cnt_chk_viol integer, cnt_unq_viol integer, cnt_lk_confl integer, cnt_user_exc integer, cnt_other_exc integer, dts_beg timestamp, dts_end timestamp ) AS declare v_dummy int; begin a_last_hours = abs( coalesce(a_last_hours, 3) ); a_last_mins = coalesce(a_last_mins, 0); a_last_mins = iif( a_last_mins between 0 and 59, a_last_mins, 0 ); delete from tmp$perf_mon where 1=1; select count(*) from srv_mon_perf_detailed(:a_last_hours, :a_last_mins, 0) into v_dummy; for select o.info,s.unit, s.cnt_all, s.cnt_ok,s.cnt_err,s.err_prc ,s.cnt_chk_viol ,s.cnt_unq_viol ,s.cnt_lk_confl ,s.cnt_user_exc ,s.cnt_other_exc ,s.dts_beg ,s.dts_end from business_ops o left join tmp$perf_mon s on o.unit=s.unit order by o.sort_prior into info ,unit ,cnt_all ,cnt_ok ,cnt_err ,err_prc ,cnt_chk_viol ,cnt_unq_viol ,cnt_lk_confl ,cnt_user_exc ,cnt_other_exc ,dts_beg ,dts_end do suspend; end ^ create or alter procedure srv_mon_exceptions( a_last_hours smallint default 3, a_last_mins smallint default 0) returns ( fb_gdscode int, fb_mnemona type of column fb_errors.fb_mnemona, unit type of dm_unit, cnt int, dts_min timestamp, dts_max timestamp ) as begin a_last_hours = abs( a_last_hours ); a_last_mins = iif( a_last_mins between 0 and 59, a_last_mins, 0 ); for with a as( select maxvalue( x.last_job_start_dts, y.last_job_finish_dts ) as last_job_start_dts from ( select p.dts_beg as last_job_start_dts from perf_log p where p.unit = 'perf_watch_interval' order by dts_beg desc rows 1 ) x join ( select dateadd( -abs( :a_last_hours * 60 + :a_last_mins ) minute to p.dts_beg) as last_job_finish_dts from perf_log p where exists(select 1 from business_ops b where b.unit=p.unit order by b.unit) order by p.dts_beg desc rows 1 ) y on 1=1 ) select p.fb_gdscode, e.fb_mnemona, p.unit, count(*) cnt, min(p.dts_beg) dts_min, max(p.dts_beg) dts_max from perf_log p join a on p.dts_beg >= a.last_job_start_dts join fb_errors e on p.fb_gdscode = e.fb_gdscode where p.fb_gdscode > 0 and p.exc_unit='#' group by 1,2,3 into fb_gdscode, fb_mnemona, unit, cnt, dts_min, dts_max do suspend; end ^ create or alter procedure srv_mon_idx returns ( tab_name dm_dbobj, idx_name dm_dbobj, last_stat double precision, curr_stat double precision, diff_stat double precision, last_done timestamp ) as declare v_last_recalc_trn bigint; begin select p.trn_id from perf_log p where p.unit starting with 'srv_recalc_idx_stat_' order by p.trn_id desc rows 1 into v_last_recalc_trn; for select t.tab_name ,t.idx_name ,t.last_stat ,r.rdb$statistics ,t.last_stat - r.rdb$statistics ,t.last_done from ( select g.info as tab_name ,substring(g.unit from char_length('srv_recalc_idx_stat_')+1 ) as idx_name ,g.aux1 as last_stat ,g.dts_end as last_done from perf_log g where g.trn_id = :v_last_recalc_trn ) t join rdb$indices r on t.idx_name = r.rdb$index_name into tab_name, idx_name, last_stat, curr_stat, diff_stat, last_done do suspend; end ^ create or alter procedure srv_fill_mon( a_rowset bigint default null ) returns( rows_added int ) as declare v_curr_trn bigint; declare v_total_stat_added_rows int = 0; declare v_table_stat_added_rows int = 0; declare v_dummy bigint; declare v_info dm_info; declare v_this dm_dbobj = 'srv_fill_mon'; begin rows_added = -1; if ( fn_remote_process() NOT containing 'IBExpert' and coalesce(rdb$get_context('USER_SESSION', 'ENABLE_MON_QUERY'), 0) = 0 ) then begin rdb$set_context( 'USER_SESSION','MON_INFO', 'mon$_dis!'); suspend; exit; end execute procedure sp_check_to_stop_work; execute procedure sp_add_perf_log(1, v_this); v_curr_trn = current_transaction; if ( a_rowset is NULL  ) then begin in autonomous transaction do begin insert into mon_log( sec, usr, att_id, pg_reads, pg_writes, pg_fetches, pg_marks, rec_inserts, rec_updates, rec_deletes, rec_backouts, rec_purges, rec_expunges, rec_seq_reads, rec_idx_reads, rec_rpt_reads, bkv_reads, frg_reads, rec_locks, rec_waits, rec_confl, mem_used, mem_alloc, stat_id, server_pid, remote_pid, ip, remote_process, dump_trn, unit, add_info ) select datediff(second from current_date-1 to current_timestamp ) sec ,a.mon$user mon_user ,a.mon$attachment_id attach_id ,i.mon$page_reads reads ,i.mon$page_writes writes ,i.mon$page_fetches fetches ,i.mon$page_marks marks ,r.mon$record_inserts ins_cnt ,r.mon$record_updates upd_cnt ,r.mon$record_deletes del_cnt ,r.mon$record_backouts bk_outs ,r.mon$record_purges purges ,r.mon$record_expunges expunges ,r.mon$record_seq_reads seq_reads ,r.mon$record_idx_reads idx_reads ,r.mon$record_rpt_reads ,r.mon$backversion_reads ,r.mon$fragment_reads ,r.mon$record_locks ,r.mon$record_waits ,r.mon$record_conflicts ,u.mon$memory_used used_memory ,u.mon$memory_allocated alloc_by_OS ,a.mon$stat_id       stat_id ,a.mon$server_pid    server_PID ,a.mon$remote_pid    remote_PID ,a.mon$remote_address remote_IP ,right(a.mon$remote_process,30) remote_process ,:v_curr_trn ,:v_this ,'all_attaches' from mon$attachments a left join mon$memory_usage u on a.mon$stat_id=u.mon$stat_id left join mon$io_stats i on a.mon$stat_id=i.mon$stat_id left join mon$record_stats r on a.mon$stat_id=r.mon$stat_id where a.mon$attachment_id<>current_connection order by iif( a.mon$user in ('Garbage Collector', 'Cache Writer'  ) ,1 , iif( a.mon$remote_process containing 'gfix' ,2 ,iif( a.mon$remote_process containing 'nbackup' or a.mon$remote_process containing 'gbak' or a.mon$remote_process containing 'gstat' ,3 ,1000+a.mon$attachment_id ) ) ) ; v_total_stat_added_rows = row_count; end end else begin insert into mon_log( rowset, sec, usr, att_id, trn_id, pg_reads, pg_writes, pg_fetches, pg_marks, rec_inserts, rec_updates, rec_deletes, rec_backouts, rec_purges, rec_expunges, rec_seq_reads, rec_idx_reads, rec_rpt_reads, bkv_reads, frg_reads, rec_locks, rec_waits, rec_confl, mem_used, mem_alloc, stat_id, server_pid, remote_pid, ip, remote_process, dump_trn, unit, add_info, fb_gdscode, elapsed_ms ) select t.rowset ,datediff(second from current_date-1 to current_timestamp ) ,current_user ,current_connection ,max( t.trn_id ) ,sum( t.mult * t.pg_reads) ,sum( t.mult * t.pg_writes) ,sum( t.mult * t.pg_fetches) ,sum( t.mult * t.pg_marks) ,sum( t.mult * t.rec_inserts) ,sum( t.mult * t.rec_updates) ,sum( t.mult * t.rec_deletes) ,sum( t.mult * t.rec_backouts) ,sum( t.mult * t.rec_purges) ,sum( t.mult * t.rec_expunges) ,sum( t.mult * t.rec_seq_reads) ,sum( t.mult * t.rec_idx_reads) ,sum( t.mult * t.rec_rpt_reads) ,sum( t.mult * t.bkv_reads) ,sum( t.mult * t.frg_reads) ,sum( t.mult * t.rec_locks) ,sum( t.mult * t.rec_waits) ,sum( t.mult * t.rec_confl) ,sum( t.mult * t.mem_used) ,sum( t.mult * t.mem_alloc) ,max( t.stat_id ) ,max( t.server_pid ) ,rdb$get_context('SYSTEM', 'CLIENT_PID') ,fn_remote_address() ,right( fn_remote_process(), 30) ,:v_curr_trn ,max(unit) ,max(add_info) ,max(fb_gdscode) ,datediff(millisecond from min(t.dts) to max(t.dts) ) from tmp$mon_log t where t.rowset = :a_rowset group by t.rowset; v_total_stat_added_rows = row_count; delete from tmp$mon_log t where t.rowset = :a_rowset; insert into mon_log_table_stats( rowset ,table_name ,att_id ,table_id ,is_system_table ,rel_type ,unit ,fb_gdscode ,rec_inserts ,rec_updates ,rec_deletes ,rec_backouts ,rec_purges ,rec_expunges ,rec_seq_reads ,rec_idx_reads ,rec_rpt_reads ,bkv_reads ,frg_reads ,rec_locks ,rec_waits ,rec_confl ,trn_id ,stat_id ) select s.rowset ,s.table_name as tab_name ,current_connection as att_id ,max( r.rdb$relation_id ) as tab_id ,max( r.rdb$system_flag ) as sys_flag ,max( r.rdb$relation_type ) as rel_type ,max( s.unit ) ,sum( s.mult * s.fb_gdscode ) ,sum( s.mult * s.rec_inserts ) ,sum( s.mult * s.rec_updates ) ,sum( s.mult * s.rec_deletes ) ,sum( s.mult * s.rec_backouts ) ,sum( s.mult * s.rec_purges ) ,sum( s.mult * s.rec_expunges ) ,sum( s.mult * s.rec_seq_reads ) ,sum( s.mult * s.rec_idx_reads ) ,sum( s.mult * s.rec_rpt_reads ) ,sum( s.mult * s.bkv_reads ) ,sum( s.mult * s.frg_reads ) ,sum( s.mult * s.rec_locks ) ,sum( s.mult * s.rec_waits ) ,sum( s.mult * s.rec_confl ) ,max( s.trn_id ) ,max( s.stat_id ) from tmp$mon_log_table_stats s join rdb$relations r on s.table_name = r.rdb$relation_name where s.rowset = :a_rowset group by s.rowset, s.table_name; v_table_stat_added_rows = row_count; delete from tmp$mon_log_table_stats s where s.rowset = :a_rowset; end rows_added = v_total_stat_added_rows + v_table_stat_added_rows; v_info='rows added: total_stat='||v_total_stat_added_rows||', table_stat='||v_table_stat_added_rows; rdb$set_context( 'USER_SESSION','MON_INFO', v_info ); execute procedure sp_add_perf_log(0, v_this, null, v_info ); suspend; when any do begin rdb$set_context( 'USER_SESSION','MON_INFO', 'gds='||gdscode ); execute procedure sp_add_to_abend_log( '', gdscode, '', v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure srv_fill_tmp_mon( a_rowset dm_ids, a_ignore_system_tables smallint default 1, a_unit dm_unit default null, a_info dm_info default null, a_gdscode int default null ) returns( rows_added int ) as declare v_mult dm_sign; declare v_curr_trn bigint; declare v_this dm_dbobj = 'srv_fill_tmp_mon'; declare v_total_stat_added_rows int; declare v_table_stat_added_rows int; begin rows_added = -1; if ( fn_remote_process() NOT containing 'IBExpert' and coalesce(rdb$get_context('USER_SESSION', 'ENABLE_MON_QUERY'), 0) = 0 ) then begin rdb$set_context( 'USER_SESSION','MON_INFO', 'mon$_dis!'); suspend; exit; end execute procedure sp_check_to_stop_work; execute procedure sp_add_perf_log(1, v_this); v_mult = iif( exists(select * from tmp$mon_log g where g.rowset is not distinct from :a_rowset), 1, -1); v_curr_trn = iif( v_mult = 1, current_transaction, null); insert into tmp$mon_log( pg_reads ,pg_writes ,pg_fetches ,pg_marks ,rec_inserts ,rec_updates ,rec_deletes ,rec_backouts ,rec_purges ,rec_expunges ,rec_seq_reads ,rec_idx_reads ,rec_rpt_reads ,bkv_reads ,frg_reads ,rec_locks ,rec_waits ,rec_confl ,mem_used ,mem_alloc ,stat_id ,server_pid ,rowset ,unit ,add_info ,fb_gdscode ,mult ,trn_id ) select i.mon$page_reads ,i.mon$page_writes ,i.mon$page_fetches ,i.mon$page_marks ,r.mon$record_inserts ,r.mon$record_updates ,r.mon$record_deletes ,r.mon$record_backouts ,r.mon$record_purges ,r.mon$record_expunges ,r.mon$record_seq_reads ,r.mon$record_idx_reads ,r.mon$record_rpt_reads ,r.mon$backversion_reads ,r.mon$fragment_reads ,r.mon$record_locks ,r.mon$record_waits ,r.mon$record_conflicts ,u.mon$memory_used ,u.mon$memory_allocated ,a.mon$stat_id ,a.mon$server_pid ,:a_rowset ,:a_unit ,:a_info ,:a_gdscode ,:v_mult ,:v_curr_trn from mon$attachments a left join mon$memory_usage u on a.mon$stat_id=u.mon$stat_id left join mon$io_stats i on a.mon$stat_id=i.mon$stat_id left join mon$record_stats r on a.mon$stat_id=r.mon$stat_id where a.mon$attachment_id = current_connection; v_total_stat_added_rows = row_count; insert into tmp$mon_log_table_stats( table_name ,rec_inserts ,rec_updates ,rec_deletes ,rec_backouts ,rec_purges ,rec_expunges ,rec_seq_reads ,rec_idx_reads ,rec_rpt_reads ,bkv_reads ,frg_reads ,rec_locks ,rec_waits ,rec_confl ,rowset ,unit ,fb_gdscode ,stat_id ,mult ,trn_id ) select t.mon$table_name ,r.mon$record_inserts ,r.mon$record_updates ,r.mon$record_deletes ,r.mon$record_backouts ,r.mon$record_purges ,r.mon$record_expunges ,r.mon$record_seq_reads ,r.mon$record_idx_reads ,r.mon$record_rpt_reads ,r.mon$backversion_reads ,r.mon$fragment_reads ,r.mon$record_locks ,r.mon$record_waits ,r.mon$record_conflicts ,:a_rowset ,:a_unit ,:a_gdscode ,a.mon$stat_id ,:v_mult ,:v_curr_trn from mon$record_stats r join mon$table_stats t on r.mon$stat_id = t.mon$record_stat_id join mon$attachments a on t.mon$stat_id = a.mon$stat_id where a.mon$attachment_id = current_connection and ( :a_ignore_system_tables = 0 or t.mon$table_name not starting with 'RDB$' ); v_table_stat_added_rows = row_count; execute procedure sp_add_perf_log(0, v_this, null, 'rows added: total_stat='||v_total_stat_added_rows||', table_stat='||v_table_stat_added_rows ); rows_added = v_total_stat_added_rows + v_table_stat_added_rows; suspend; when any do begin rdb$set_context( 'USER_SESSION','MON_INFO', 'gds='||gdscode ); execute procedure sp_add_to_abend_log( '', gdscode, '', v_this, fn_halt_sign(gdscode) ); exception; end end ^ create or alter procedure srv_test_work returns(ret_code int) as declare v_bak int; declare n bigint; declare v_clo_id bigint; declare v_ord_id bigint; declare v_inv_id bigint; declare v_res_id bigint; begin v_bak = rdb$get_context('USER_SESSION', 'ORDER_FOR_OUR_FIRM_PERCENT'); rdb$set_context('USER_SESSION', 'ORDER_FOR_OUR_FIRM_PERCENT',0); select min(p.doc_list_id) from sp_client_order(0,1,1) p into v_clo_id; select count(*) from srv_make_invnt_saldo into n; select min(p.doc_list_id) from sp_supplier_order(0,1,1) p into v_ord_id; select count(*) from srv_make_invnt_saldo into n; select min(p.doc_list_id) from sp_supplier_invoice(0,1,1) p into v_inv_id; select count(*) from srv_make_invnt_saldo into n; select count(*) from sp_add_invoice_to_stock(:v_inv_id) into n; select count(*) from srv_make_invnt_saldo into n; select count(*) from sp_reserve_write_off(:v_res_id) into n; select count(*) from srv_make_invnt_saldo into n; select count(*) from sp_cancel_client_order(:v_clo_id) into n; select count(*) from srv_make_invnt_saldo into n; select count(*) from sp_cancel_supplier_order(:v_ord_id) into n; select count(*) from srv_make_invnt_saldo into n; rdb$set_context('USER_SESSION', 'ORDER_FOR_OUR_FIRM_PERCENT',v_bak); ret_code = iif( exists(select * from qdistr) or exists(select * from qdistr), 1, 0); ret_code = iif( exists(select * from invnt_turnover_log), bin_or(ret_code, 2), ret_code ); ret_code = iif( NOT exists(select * from invnt_saldo), bin_or(ret_code, 4), ret_code ); n = null; select s.id from invnt_saldo s where NOT ( s.qty_clo=1 and s.qty_clr = 1 and s.qty_ord = 0 and s.qty_sup = 0 and s.qty_avl = 0 and s.qty_res = 0 and s.qty_inc = 0 and s.qty_out = 0 ) rows 1 into n; ret_code = iif( n is NOT null, bin_or(ret_code, 8), ret_code ); suspend; end ^ set term ;^ commit; drop exception ex_exclusive_required; drop exception ex_not_suitable_fb_version; set list on; select 'oltp30_sp.sql finish' as msg, current_timestamp from rdb$database; set list off; commit; set bail on; set list on; select 'oltp_main_filling.sql start' as msg, current_timestamp from rdb$database; set list off; commit; set term ^; execute block as declare trg_name type of column rdb$triggers.rdb$trigger_name; declare tab_name type of column rdb$relations.rdb$relation_name; declare stt varchar(255); declare n int; begin for select rt.rdb$trigger_name from rdb$triggers rt join rdb$relations rr on rt.rdb$relation_name = rr.rdb$relation_name where coalesce(rt.rdb$system_flag,0)=0 and rt.rdb$relation_name is not null and rt.rdb$trigger_inactive=0 and rr.rdb$relation_type in (0, 4, 5) into trg_name do begin rdb$set_context('USER_TRANSACTION','ACTIVE_TRIGGER_'||trg_name,trg_name); stt = 'alter trigger '||trg_name||' inactive'; execute statement(stt) with autonomous transaction; end for select t from ( select 'perf_log' t from rdb$database union all select 'mon_log' t from rdb$database union all select 'qdistr' t from rdb$database union all select 'qstorned' t from rdb$database union all select 'pdistr' t from rdb$database union all select 'pstorned' t from rdb$database union all select 'doc_data' t from rdb$database union all select 'doc_list' t from rdb$database union all select 'invnt_turnover_log' t from rdb$database union all select 'money_turnover_log' t from rdb$database union all select 'money_saldo' t from rdb$database union all select 'invnt_saldo' t from rdb$database union all select 'wares' t from rdb$database union all select 'phrases' t from rdb$database union all select 'agents' t from rdb$database union all select 'rules_for_qdistr' t from rdb$database union all select 'rules_for_pdistr' t from rdb$database union all select 'mon_log' t from rdb$database union all select 'mon_log_table_stats' t from rdb$database union all select 'zdoc_data' t from rdb$database union all select 'zdoc_list' t from rdb$database union all select 'zinvnt_turnover_log' t from rdb$database union all select 'zqdistr' t from rdb$database union all select 'zqstorned' t from rdb$database union all select 'zpdistr' t from rdb$database union all select 'zpstorned' t from rdb$database union all select 'ztmp_shopping_cart' t from rdb$database ) d into tab_name do begin if ( exists( select * from rdb$relations r where r.rdb$relation_name = upper( :tab_name ) and r.rdb$relation_type in (0, 4, 5) and coalesce(r.rdb$system_flag, 0) = 0 ) ) then begin stt = 'delete from '||tab_name; execute statement(stt); stt = 'select count(*) from '||tab_name; execute statement(stt) into n; end end for select m.mon$variable_value from mon$context_variables m where m.mon$transaction_id=current_transaction and m.mon$variable_name starting with 'ACTIVE_TRIGGER_' into trg_name do begin stt = 'alter trigger '||trg_name||' active'; execute statement(stt) with autonomous transaction; rdb$set_context('USER_TRANSACTION','ACTIVE_TRIGGER_'||trg_name,null); end end ^ set term ;^ commit; insert into perf_log( unit,info,stack,dts_beg) values('dump_dirty_data_semaphore', '', 'by oltp_main_filling.sql', null); commit; delete from semaphores; insert into semaphores(id, task) values(1, 'srv_make_money_saldo'); insert into semaphores(id, task) values(2, 'srv_recalc_idx_stat'); insert into semaphores(id, task) values(3, 'srv_make_invnt_saldo'); commit; delete from settings; set term ^; execute block as declare v_insert_settings_statement varchar(512); begin for with recursive n as(select 1 i from rdb$database union all select n.i+1 from n where n.i < 6) ,c( working_mode, wares_max_id, customer_doc_max_rows, supplier_doc_max_rows, customer_doc_max_qty, supplier_doc_max_qty, number_of_agents ) as ( select 'DEBUG_01',       1,       1,          1,          2,         5,        3  from rdb$database union all select 'DEBUG_02',       2,       2,          3,          5,         5,        3  from rdb$database union all select 'DEBUG_03',       3,       3,          5,          4,         8,       10  from rdb$database union all select 'DEBUG_04',      10,       5,         30,          5,        30,       15  from rdb$database union all select 'DEBUG_1A',       1,      10,         50,         10,        50,        3  from rdb$database union all select 'SMALL_01',     100,       5,         20,          5,        20,       30  from rdb$database union all select 'SMALL_02',     300,      10,         30,         10,        30,       40  from rdb$database union all select 'SMALL_03',     400,      10,         50,         15,        50,       50  from rdb$database union all select 'MEDIUM_01',    700,      20,         60,         30,       100,      100  from rdb$database union all select 'MEDIUM_02',   1500,      30,         80,         50,       150,      150  from rdb$database union all select 'MEDIUM_03',   3000,      50,        100,         70,       200,      200  from rdb$database union all select 'LARGE_01',    5000,      70,        200,        100,       300,      500  from rdb$database union all select 'LARGE_02',    7000,     100,        300,        150,       450,      700  from rdb$database union all select 'LARGE_03',    9000,     150,        400,        200,       600,     1000  from rdb$database union all select 'HEAVY_01',   50000,     250,        500,        300,       900,     2000  from rdb$database ) ,d as( select 'insert into settings(working_mode, mcode, svalue, init_on) values(''' ||trim(c.working_mode) ||''', ' expr_pref ,iif(n.i=1, c.wares_max_id, null ) v4wares_max_id ,iif(n.i=2, c.customer_doc_max_rows, null ) v4customer_doc_max_rows ,iif(n.i=3, c.supplier_doc_max_rows, null ) v4supplier_doc_max_rows ,iif(n.i=4, c.customer_doc_max_qty, null ) v4customer_doc_max_qty ,iif(n.i=5, c.supplier_doc_max_qty, null ) v4supplier_doc_max_qty ,iif(n.i=6, c.number_of_agents, null ) v4number_of_agents ,')' expr_suff from c cross join n ) select d.expr_pref || iif( v4wares_max_id is not null, ''''||upper('c_wares_max_id')||''', '||v4wares_max_id||', ''db_prepare''' ,iif( v4customer_doc_max_rows is not null, ''''||upper('c_customer_doc_max_rows')||''', '||v4customer_doc_max_rows||', ''connect''' ,iif( v4supplier_doc_max_rows is not null, ''''||upper('c_supplier_doc_max_rows')||''', '||v4supplier_doc_max_rows||', ''connect''' ,iif( v4customer_doc_max_qty is not null, ''''||upper('c_customer_doc_max_qty')||''', '||v4customer_doc_max_qty||', ''connect''' ,iif( v4supplier_doc_max_qty is not null, ''''||upper('c_supplier_doc_max_qty')||''', '||v4supplier_doc_max_qty||', ''connect''' ,iif( v4number_of_agents is not null, ''''||upper('c_number_of_agents')||''', '||v4number_of_agents||', ''db_prepare''', null ) ) ) ) ) ) || d.expr_suff as ins_sttm from d into v_insert_settings_statement do begin execute statement(v_insert_settings_statement); end end ^ set term ;^ commit; insert into settings(working_mode, mcode,           svalue) values('INIT',       'WORKING_MODE',  'SMALL_03'); insert into settings(working_mode, mcode,                  svalue) values('COMMON',       'TRACED_UNITS', ',,'); insert into settings(working_mode, mcode, svalue) values( 'COMMON', 'ENABLE_MON_QUERY', decode( left(rdb$get_context('SYSTEM','ENGINE_VERSION'),3) ,'3.0', '0' ,'2.5', '0' ,'0' ) ); insert into settings(working_mode, mcode, svalue) values( 'COMMON', 'HALT_TEST_ON_ERRORS', decode( left(rdb$get_context('SYSTEM','ENGINE_VERSION'),3) ,'3.0', ',,' ,'2.5', ',CK,' ,',NONE,' ) ); insert into settings(working_mode, mcode,                      svalue,  init_on) values('COMMON',     'LOG_PK_VIOLATION',   '0',     'db_prepare'); insert into settings(working_mode, mcode,         svalue) values('COMMON',     'QMISM_VERIFY_BITSET',  '1'); insert into settings(working_mode, mcode,         svalue) values('COMMON',     'QDISTR_HANDLING_MODE',  'DEL_INS'); insert into settings(working_mode, mcode,                                 svalue) values('COMMON',       'ENABLE_RESERVES_WHEN_ADD_INVOICE',  '1'); insert into settings(working_mode, mcode,          svalue) values('COMMON',     'ORDER_FOR_OUR_FIRM_PERCENT', '25'); insert into settings(working_mode, mcode,                   svalue) values('COMMON',       'ENABLE_FILL_PHRASES', '0'); insert into settings(working_mode, mcode,                      svalue) values('COMMON',       'RANDOM_SEEK_VIA_ROWS_LIMIT', '0'); insert into settings(working_mode, mcode,                      svalue,  init_on) values('COMMON',     'C_INVOICE_MIN_PURCHASE',   '1000',  'db_prepare'); insert into settings(working_mode, mcode,                      svalue,  init_on) values('COMMON',     'C_INVOICE_MAX_PURCHASE',   '2000',  'db_prepare'); insert into settings(working_mode, mcode,                      svalue,  init_on) values('COMMON',     'C_INVOICE_MIN_PROFIT_PRC', '35',  'db_prepare'); insert into settings(working_mode, mcode,                      svalue,  init_on) values('COMMON',     'C_INVOICE_MAX_PROFIT_PRC', '80',  'db_prepare'); insert into settings(working_mode, mcode,  svalue) values('COMMON',     'C_MIN_COST_TO_BE_SPLITTED', '1000'); insert into settings(working_mode, mcode,              svalue) values('COMMON',     'C_ROWS_TO_MULTIPLY', '10'); insert into settings(working_mode, mcode,                             svalue) values('COMMON',     'C_PAYMENT_FROM_CLIENT_MIN_TOTAL', '1000'); insert into settings(working_mode, mcode,                             svalue) values('COMMON',     'C_PAYMENT_FROM_CLIENT_MAX_TOTAL', '5000'); insert into settings(working_mode, mcode,                             svalue) values('COMMON',     'C_PAYMENT_TO_SUPPLIER_MIN_TOTAL', '2000'); insert into settings(working_mode, mcode,              svalue) values('COMMON',     'C_PAYMENT_TO_SUPPLIER_MAX_TOTAL', '15000'); commit; set term ^; execute block as declare fn_oper_order_by_customer dm_ids; declare fn_oper_order_for_supplier dm_ids; declare fn_oper_invoice_get dm_ids; declare fn_oper_invoice_add dm_ids; declare fn_oper_retail_reserve dm_ids; declare fn_oper_pay_from_customer dm_ids; declare fn_oper_retail_realization dm_ids; declare fn_oper_pay_to_supplier dm_ids; begin delete from optypes; fn_oper_order_by_customer = 1000; insert into optypes(id,   mcode,     acn_type,  name,                  m_qty_clo) values( :fn_oper_order_by_customer, 'CLO',     '1',       'add to client order', 1); insert into optypes(id,   mcode,     acn_type,  name,                  m_qty_clr) values( 1100, 'CLR',     '1',       'client refused from order', 1); fn_oper_order_for_supplier = 1200; insert into optypes(id,   mcode,     acn_type,  name,                                   m_qty_clo, m_qty_ord) values( :fn_oper_order_for_supplier, 'ORD',     '2',       'add to stock order, send to supplier', -1,        1); fn_oper_invoice_get = 2000; insert into optypes(id,   mcode,     acn_type,  name,                             m_qty_ord, m_qty_sup) values( :fn_oper_invoice_get, 'SUP',     'i',       'get invoice from supplier',      -1,           1); fn_oper_invoice_add = 2100; insert into optypes(id,   mcode,     acn_type,  name,                                  m_qty_sup, m_qty_avl, m_supp_debt) values( :fn_oper_invoice_add, 'INC',     'i',       'add invoice to avaliable remainders', -1,           1,            1   ); fn_oper_retail_reserve = 3300; insert into optypes(id,   mcode,     acn_type,  name,                                   m_qty_avl, m_qty_res) values( :fn_oper_retail_reserve, 'RES',     'o',       'retail sale - reserve for customer',   -1,           1); fn_oper_retail_realization = 3400; insert into optypes(id,   mcode,     acn_type,  name,                                           m_qty_res, m_cust_debt) values( :fn_oper_retail_realization, 'SAL',     'o',       'retail sale - write-off (realization)',        -1,           1      ); fn_oper_pay_to_supplier = 4000; insert into optypes(id,   mcode,     acn_type,  name,                                m_supp_debt) values( :fn_oper_pay_to_supplier, 'PSU',     's',       'payment to supplier for wares',     -1        ); fn_oper_pay_from_customer = 5000; insert into optypes(id,   mcode,     acn_type,  name,                                                 m_cust_debt) values( :fn_oper_pay_from_customer, 'PCU',     'c',       'payment from customer (advance or target transfer)', -1        ); update optypes o set multiply_rows_for_fifo = 1 where o.id in ( :fn_oper_order_by_customer, :fn_oper_order_for_supplier, :fn_oper_invoice_get ) ; delete from rules_for_qdistr; insert into rules_for_qdistr( mode,           snd_optype_id, rcv_optype_id) values( 'new_doc_only', null,          :fn_oper_order_by_customer ); insert into rules_for_qdistr( mode,            snd_optype_id,              rcv_optype_id,               storno_sub) values( 'distr+new_doc', :fn_oper_order_by_customer, :fn_oper_order_for_supplier, 1 ); insert into rules_for_qdistr(mode,             snd_optype_id,               rcv_optype_id,              storno_sub) values( 'distr+new_doc', :fn_oper_order_for_supplier, :fn_oper_invoice_get,       1 ); insert into rules_for_qdistr( mode,             snd_optype_id,              rcv_optype_id,              storno_sub) values( 'mult_rows_only', :fn_oper_order_by_customer, :fn_oper_retail_reserve,    2 ); insert into rules_for_qdistr( mode,             snd_optype_id,        rcv_optype_id) values( 'mult_rows_only', :fn_oper_invoice_get, :fn_oper_retail_reserve ); insert into rules_for_qdistr( mode,            snd_optype_id,         rcv_optype_id,          storno_sub) values( 'distr+new_doc', :fn_oper_invoice_add, :fn_oper_retail_reserve, 1 ); insert into rules_for_qdistr( mode,           snd_optype_id,           rcv_optype_id) values( 'new_doc_only', :fn_oper_retail_reserve, null  ); delete from rules_for_pdistr; insert into rules_for_pdistr(mode, snd_optype_id,              rcv_optype_id               ) values( '', :fn_oper_pay_from_customer, :fn_oper_retail_realization ); insert into rules_for_pdistr(mode, snd_optype_id,                rcv_optype_id            ) values( '',  :fn_oper_retail_realization, :fn_oper_pay_from_customer ); insert into rules_for_pdistr(mode, snd_optype_id,             rcv_optype_id) values( '',  :fn_oper_pay_to_supplier, :fn_oper_invoice_add); insert into rules_for_pdistr(mode, snd_optype_id,         rcv_optype_id) values( '',  :fn_oper_invoice_add, :fn_oper_pay_to_supplier ); update rules_for_pdistr p set p.rows_to_multiply = ( select cast(s.svalue as int) from settings s where s.working_mode='COMMON' and s.mcode = 'C_ROWS_TO_MULTIPLY' ); end ^set term ;^ commit; delete from doc_states; insert into doc_states(id, mcode, name) values(2000, 'DOC_OPEN_STATE', 'content not checked, changes enable'); insert into doc_states(id, mcode, name) values(2010, 'DOC_FIX_STATE',  'content checked, accept only payments'); insert into doc_states(id, mcode, name) values(2020, 'DOC_CLOS_STATE', 'closed from any changes'); insert into doc_states(id, mcode, name) values(2030, 'DOC_CANC_STATE', 'cancelled without revert'); commit; delete from business_ops; insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_client_order',           'stock', 'creation',  95, 100,    'customer order: creation'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_cancel_client_order',    'stock', 'removal',   30, 120,    'customer order: refuse'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_supplier_order',         'stock', 'creation',  65, 200,    'order to supplier: creation'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_cancel_supplier_order',  'stock', 'removal',   10, 220,    'order to supplier: removal'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_supplier_invoice',       'stock', 'creation',  65, 300,    'invoice (draft): creation'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_cancel_supplier_invoice','stock', 'removal',   10, 320,    'invoice (draft): removal'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_add_invoice_to_stock',   'stock', 'state_next', 62, 400,    'invoice accept: apply'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_cancel_adding_invoice',  'stock', 'state_back', 10, 420,    'invoice accept: cancel'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_customer_reserve',       'stock', 'creation',   20, 500,    'customer reserve: creation'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_cancel_customer_reserve','stock', 'removal',    15, 520,    'customer reserve: removal'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_reserve_write_off',      'stock', 'state_next', 80, 600,    'realization accept: apply'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_cancel_write_off',       'stock', 'state_back', 20, 620,    'realization accept: cancel'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_pay_from_customer',       'payments', 'creation', 72, 700,   'payment from customer: creation'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_cancel_pay_from_customer','payments', 'removal',  15, 720,   'payment from customer: removal'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_pay_to_supplier',         'payments', 'creation', 67, 800,   'payment to supplier: creation'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('sp_cancel_pay_to_supplier',  'payments', 'removal',  10, 820,   'payment to supplier: removal'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('srv_make_invnt_saldo',  'service', 'service',        35, 990,   'service: total inventory turnovers'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('srv_make_money_saldo',  'service', 'service',        25, 995,   'service: total monetary turnovers'); insert into business_ops( unit, mode, kind, random_selection_weight, sort_prior, info ) values('srv_recalc_idx_stat',  'service', 'service',         20, 997,   'service: refresh index statistics'); delete from fb_errors; insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(101, 335544366, 'segment', 'Segment buffer length shorter than expected.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(100, 335544338, 'from_no_match', 'No match for first value expression.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(100, 335544354, 'no_record', 'Invalid database key.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(100, 335544367, 'segstr_eof', 'Attempted retrieval of more segments than exist.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(100, 335544374, 'stream_eof', 'Attempt to fetch past the last record in a record stream.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(0, 335741039, 'gfix_opt_SQL_dialect', 'use -sql_dialect to set database dialect n.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(0, 335544875, 'bad_debug_format', 'Bad debug info format.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-84, 335544554, 'nonsql_security_rel', 'Table/procedure has non-SQL security class defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-84, 335544555, 'nonsql_security_fld', 'Column has non-SQL security class defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-84, 335544668, 'dsql_procedure_use_err', 'Procedure @1 does not return any values.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544747, 'usrname_too_long', 'The username entered is too long. Maximum length is 31 bytes.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544748, 'password_too_long', 'The password specified is too long. Maximum length is 8 bytes.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544749, 'usrname_required', 'A username is required for this operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544750, 'password_required', 'A password is required for this operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544751, 'bad_protocol', 'The network protocol specified is invalid.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544752, 'dup_usrname_found', 'A duplicate user name was found in the security database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544753, 'usrname_not_found', 'The user name specified was not found in the security database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544754, 'error_adding_sec_record', 'An error occurred while attempting to add the user.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544755, 'error_modifying_sec_record', 'An error occurred while attempting to modify the user record.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544756, 'error_deleting_sec_record', 'An error occurred while attempting to delete the user record.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-85, 335544757, 'error_updating_sec_db', 'An error occurred while updating the security database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-103, 335544571, 'dsql_constant_err', 'Data type for constant unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336003075, 'dsql_transitional_numeric', 'Precision 10 to 18 changed from DOUBLE PRECISION in SQL dialect 1 to 64-bit scaled integer in SQL di'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336003077, 'sql_db_dialect_dtype_unsupport', 'Database SQL dialect @1 does not support reference to @2 datatype.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336003087, 'dsql_invalid_label', 'Label @1 @2 in the current scope.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336003088, 'dsql_datatypes_not_comparable', 'Datatypes @1 are not comparable in expression @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544343, 'invalid_blr', 'Invalid request BLR at offset @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544390, 'syntaxerr', 'BLR syntax error: expected @1 at offset @2, encountered @3.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544425, 'ctxinuse', 'Context already in use (BLR error).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544426, 'ctxnotdef', 'Context not defined (BLR error).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544429, 'badparnum', 'Bad parameter number.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544440, 'bad_msg_vec', ''); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544456, 'invalid_sdl', 'Invalid slice description language at offset @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544570, 'dsql_command_err', 'Invalid command.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544579, 'dsql_internal_err', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544590, 'dsql_dup_option', 'Option specified more than once.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544591, 'dsql_tran_err', 'Unknown transaction option.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544592, 'dsql_invalid_array', 'Invalid array reference.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544608, 'command_end_err', 'Unexpected end of command.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544612, 'token_err', 'Token unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544634, 'dsql_token_unk_err', 'Token unknown- line @1, column @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544709, 'dsql_agg_ref_err', 'Invalid aggregate reference.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544714, 'invalid_array_id', 'Invalid blob id.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544730, 'cse_not_supported', 'Client/Server Express not supported in this release.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544743, 'token_too_long', 'Token size exceeds limit.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544763, 'invalid_string_constant', 'A string constant is delimited by double quotes.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544764, 'transitional_date', 'DATE must be changed to TIMESTAMP.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544796, 'sql_dialect_datatype_unsupport', 'Client SQL dialect @1 does not support reference to @2 data type.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544798, 'depend_on_uncommitted_rel', 'You created an indirect dependency on uncommitted metadata. You must roll back the current transacti'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544821, 'dsql_column_pos_err', 'Invalid column position used in the @1 clause.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544822, 'dsql_agg_where_err', 'Cannot use an aggregate function in a WHERE clause, use HAVING instead.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544823, 'dsql_agg_group_err', 'Cannot use an aggregate function in a GROUP BY clause.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544824, 'dsql_agg_column_err', 'Invalid expression in the @1 (not contained in either an aggregate function or the GROUP BY clause).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544825, 'dsql_agg_having_err', 'Invalid expression in the @1 (neither an aggregate function nor a part of the GROUP BY clause).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544826, 'dsql_agg_nested_err', 'Nested aggregate functions are not allowed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544849, 'malformed_string', 'Malformed string.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 335544851, 'command_end_err2', 'Unexpected end of command - line @1, column @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397215, 'dsql_max_sort_items', 'Cannot sort on more than 255 items.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397216, 'dsql_max_group_items', 'Cannot group on more than 255 items.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397217, 'dsql_conflicting_sort_field', 'Cannot include the same field (@1.@2) twice in the ORDER BY clause with conflicting sorting options.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397218, 'dsql_derived_table_more_columns', 'Column list from derived table @1 has more columns than the number of items in its SELECT statement.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397219, 'dsql_derived_table_less_columns', 'Column list from derived table @1 has less columns than the number of items in its SELECT statement.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397220, 'dsql_derived_field_unnamed', 'No column name specified for column number @1 in derived table @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397221, 'dsql_derived_field_dup_name', 'Column @1 was specified multiple times for derived table @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397222, 'dsql_derived_alias_select', 'Internal dsql error: alias type expected by pass1_expand_select_node.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397223, 'dsql_derived_alias_field', 'Internal dsql error: alias type expected by pass1_field.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397224, 'dsql_auto_field_bad_pos', 'Internal dsql error: column position out of range in pass1_union_auto_cast.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397225, 'dsql_cte_wrong_reference', 'Recursive CTE member (@1) can refer itself only in FROM clause.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397226, 'dsql_cte_cycle', 'CTE ''@1'' has cyclic dependencies.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397227, 'dsql_cte_outer_join', 'Recursive member of CTE can''t be member of an outer join.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397228, 'dsql_cte_mult_references', 'Recursive member of CTE can''t reference itself more than once.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397229, 'dsql_cte_not_a_union', 'Recursive CTE (@1) must be a UNION.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397230, 'dsql_cte_nonrecurs_after_recurs', 'CTE ''@1'' defined non-recursive member after recursive.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397231, 'dsql_cte_wrong_clause', 'Recursive member of CTE ''@1'' has @2 clause.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397232, 'dsql_cte_union_all', 'Recursive members of CTE (@1) must be linked with another members via UNION ALL.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397233, 'dsql_cte_miss_nonrecursive', 'Non-recursive member is missing in CTE ''@1''.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397234, 'dsql_cte_nested_with', 'WITH clause can''t be nested.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397235, 'dsql_col_more_than_once_using', 'Column @1 appears more than once in USING clause.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-104, 336397237, 'dsql_cte_not_used', 'CTE "@1" is not used in query.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-105, 335544702, 'like_escape_invalid', 'Invalid ESCAPE sequence.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-105, 335544789, 'extract_input_mismatch', 'Specified EXTRACT part does not exist in input data type.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-150, 335544360, 'read_only_rel', 'Attempted update of read-only table.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-150, 335544362, 'read_only_view', 'Cannot update read-only view @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-150, 335544446, 'non_updatable', 'Not updatable.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-150, 335544546, 'constraint_on_view', 'Cannot define constraints on views.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-151, 335544359, 'read_only_field', 'Attempted update of read-only column.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-155, 335544658, 'dsql_base_table', '@1 is not a valid base table of the specified view.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-157, 335544598, 'specify_field_err', 'Must specify column name for view select expression.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-158, 335544599, 'num_field_err', 'Number of columns does not match select list.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-162, 335544685, 'no_dbkey', 'Dbkey not available for multi-table views.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-170, 335544512, 'prcmismat', 'Input parameter mismatch for procedure @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-170, 335544619, 'extern_func_err', 'External functions cannot have more than 10 parameters.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-170, 335544850, 'prc_out_param_mismatch', 'Output parameter mismatch for procedure @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-171, 335544439, 'funmismat', 'Function @1 could not be matched.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-171, 335544458, 'invalid_dimension', 'Column not array or invalid dimensions (expected @1, encountered @2).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-171, 335544618, 'return_mode_err', 'Return mode by value not allowed for this data type.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-171, 335544873, 'array_max_dimensions', 'Array data type can use up to @1 dimensions.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-172, 335544438, 'funnotdef', 'Function @1 is not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-203, 335544708, 'dyn_fld_ambiguous', 'Ambiguous column reference.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 336003085, 'dsql_ambiguous_field_name', 'Ambiguous field name between @1 and @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544463, 'gennotdef', 'Generator @1 is not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544502, 'stream_not_defined', 'Reference to invalid stream number.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544509, 'charset_not_found', 'CHARACTER SET @1 is not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544511, 'prcnotdef', 'Procedure @1 is not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544515, 'codnotdef', 'Status code @1 unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544516, 'xcpnotdefException', '@1 not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544532, 'ref_cnstrnt_notfound', 'Name of Referential Constraint not defined in constraints table.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544551, 'grant_obj_notfound', 'Could not find table/procedure for GRANT.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544568, 'text_subtype', 'Implementation of text subtype @1 not located.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544573, 'dsql_datatype_err', 'Data type unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544580, 'dsql_relation_err', 'Table unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544581, 'dsql_procedure_err', 'Procedure unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544588, 'collation_not_found', 'COLLATION @1 for CHARACTER SET @2 is not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544589, 'collation_not_for_charset', 'COLLATION @1 is not valid for specified CHARACTER SET.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544595, 'dsql_trigger_err', 'Trigger unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544620, 'alias_conflict_err', 'Alias @1 conflicts with an alias in the same statement.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544621, 'procedure_conflict_error', 'Alias @1 conflicts with a procedure in the same statement.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544622, 'relation_conflict_err', 'Alias @1 conflicts with a table in the same statement.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544635, 'dsql_no_relation_alias', 'There is no alias or table named @1 at this scope level.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544636, 'indexname', 'There is no index @1 for table @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544640, 'collation_requires_text', 'Invalid use of CHARACTER SET or COLLATE.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544662, 'dsql_blob_type_unknown', 'BLOB SUB_TYPE @1 is not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544759, 'bad_default_value', 'Can not define a not null column with NULL as default value.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544760, 'invalid_clause', 'Invalid clause: ''@1''.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544800, 'too_many_contexts', 'Too many Contexts of Relation/Procedure/Views. Maximum allowed is 255.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544817, 'bad_limit_param', 'Invalid parameter to FIRST. Only integers >= 0 are allowed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544818, 'bad_skip_param', 'Invalid parameter to SKIP. Only integers >= 0 are allowed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544837, 'bad_substring_offset', 'Invalid offset parameter @1 to SUBSTRING. Only positive integers are allowed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544853, 'bad_substring_length', 'Invalid length parameter @1 to SUBSTRING. Negative integers are not allowed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544854, 'charset_not_installed', 'CHARACTER SET @1 is not installed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544855, 'collation_not_installed', 'COLLATION @1 for CHARACTER SET @2 is not installed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-204, 335544867, 'subtype_for_internal_use', 'Blob sub_types bigger than 1 (text) are for internal use only.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-205, 335544396, 'fldnotdef', 'Column @1 is not defined in table @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-205, 335544552, 'grant_fld_notfound', 'Could not find column for GRANT.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-205, 335544883, 'fldnotdef2', 'Column @1 is not defined in procedure @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-206, 335544578, 'dsql_field_err', 'Column unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-206, 335544587, 'dsql_blob_err', 'Column is not a BLOB.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-206, 335544596, 'dsql_subselect_err', 'Subselect illegal in this context.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-206, 336397208, 'dsql_line_col_error', 'At line @1, column @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-206, 336397209, 'dsql_unknown_pos', 'At unknown line and column.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-206, 336397210, 'dsql_no_dup_name', 'Column@1 cannot be repeated in @2 statement.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-208, 335544617, 'order_by_err', 'Invalid ORDER BY clause.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-219, 335544395, 'relnotdef', 'Table @1 is not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-219, 335544872, 'domnotdef', 'Domain @1 is not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-230, 335544487, 'walw_err', 'WAL Writer error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-231, 335544488, 'logh_small', 'Log file header of @1 too small.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-232, 335544489, 'logh_inv_version', 'Invalid version of log file @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-233, 335544490, 'logh_open_flag', 'Log file @1 not latest in the chain but open flag still set.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-234, 335544491, 'logh_open_flag2', 'Log file @1 not closed properly; database recovery may be required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-235, 335544492, 'logh_diff_dbname', 'Database name in the log file @1 is different.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-236, 335544493, 'logf_unexpected_eof', 'Unexpected end of log file @1 at offset @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-237, 335544494, 'logr_incomplete', 'Incomplete log record at offset @1 in log file @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-238, 335544495, 'logr_header_small', 'Log record header too small at offset @1 in log file @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-239, 335544496, 'logb_small', 'Log block too small at offset @1 in log file @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-239, 335544691, 'cache_too_small', 'Insufficient memory to allocate page buffer cache.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-239, 335544693, 'log_too_small', 'Log size too small.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-239, 335544694, 'partition_too_small', 'Log partition size too small.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-243, 335544500, 'no_wal', 'Database does not use Write-ahead Log.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-257, 335544566, 'start_cm_for_wal', 'WAL defined; Cache Manager must be started first.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-260, 335544690, 'cache_redef', 'Cache redefined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-260, 335544692, 'log_redef', 'Log redefined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-261, 335544695, 'partition_not_supp', 'Partitions not supported in series of log file specification.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-261, 335544696, 'log_length_spec', 'Total length of a partitioned log must be specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-281, 335544637, 'no_stream_plan', 'Table @1 is not referenced in plan.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-282, 335544638, 'stream_twice', 'Table @1 is referenced more than once in plan; use aliases to distinguish.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-282, 335544643, 'dsql_self_join', 'The table @1 is referenced twice; use aliases to differentiate.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-282, 335544659, 'duplicate_base_table', 'Table @1 is referenced twice in view; use an alias to distinguish.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-282, 335544660, 'view_alias', 'View @1 has more than one base table; use aliases to distinguish.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-282, 335544710, 'complex_view', 'Navigational stream @1 references a view with more than one base table.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-283, 335544639, 'stream_not_found', 'Table @1 is referenced in the plan but not the from list.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-284, 335544642, 'index_unused', 'Index @1 cannot be used in the specified plan.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-291, 335544531, 'primary_key_notnull', 'Column used in a PRIMARY constraint must be NOT NULL.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-292, 335544534, 'ref_cnstrnt_update', 'Cannot update constraints (RDB$REF_CONSTRAINTS).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-293, 335544535, 'check_cnstrnt_update', 'Cannot update constraints (RDB$CHECK_CONSTRAINTS).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-294, 335544536, 'check_cnstrnt_del', 'Cannot delete CHECK constraint entry (RDB$CHECK_CONSTRAINTS).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-295, 335544545, 'rel_cnstrnt_update', 'Cannot update constraints (RDB$RELATION_CONSTRAINTS).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-296, 335544547, 'invld_cnstrnt_type', 'Internal gds software consistency check (invalid RDB$CONSTRAINT_TYPE).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-297, 335544558, 'check_constraint', 'Operation violates CHECK constraint @1 on view or table @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-313, 336003099, 'upd_ins_doesnt_match_pk', 'UPDATE OR INSERT field list does not match primary key of table @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-313, 336003100, 'upd_ins_doesnt_match_matching', 'UPDATE OR INSERT field list does not match MATCHING clause.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-313, 335544669, 'dsql_count_mismatch', 'Count of column list and variable list do not match.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-314, 335544565, 'transliteration_failed', 'Cannot transliterate character between character sets.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-315, 336068815, 'dyn_dtype_invalid', 'Cannot change data type for column @1. Changing datatype is not supported for BLOB or ARRAY columns.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-383, 336068814, 'dyn_dependency_exists', 'Column @1 from table @2 is referenced in @3.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-401, 335544647, 'invalid_operator', 'Invalid comparison operator for find operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-402, 335544368, 'segstr_no_op', 'Attempted invalid operation on a BLOB.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-402, 335544414, 'blobnotsup', 'BLOB and array data types are not supported for @1 operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-402, 335544427, 'datnotsup', 'operation not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-406, 335544457, 'out_of_bounds', 'Subscript out of bounds.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-407, 335544435, 'nullsegkey', 'Null segment of UNIQUE KEY.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-413, 335544334, 'convert_error', 'Conversion error from string "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-413, 335544454, 'nofilter', 'Filter not found to convert type @1 to type @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-413, 335544860, 'blob_convert_error', 'Unsupported conversion to target type BLOB (subtype @1).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-413, 335544861, 'array_convert_error', 'Unsupported conversion to target type ARRAY.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-501, 335544577, 'dsql_cursor_close_err', 'Attempt to reclose a closed cursor.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-502, 336003090, 'dsql_cursor_redefined', 'Statement already has a cursor @1 assigned.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-502, 336003091, 'dsql_cursor_not_found', 'Cursor @1 is not found in the current context.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-502, 336003092, 'dsql_cursor_exists', 'Cursor @1 already exists in the current context.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-502, 336003093, 'dsql_cursor_rel_ambiguous', 'Relation @1 is ambiguous in cursor @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-502, 336003094, 'dsql_cursor_rel_not_found', 'Relation @1 is not found in cursor @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-502, 336003095, 'dsql_cursor_not_open', 'Cursor is not open.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-502, 335544574, 'dsql_decl_err', 'Invalid cursor declaration.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-502, 335544576, 'dsql_cursor_open_err', 'Attempt to reopen an open cursor.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-504, 336003089, 'dsql_cursor_invalid', 'Empty cursor name is not allowed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-504, 335544572, 'dsql_cursor_err', 'Invalid cursor reference.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-508, 335544348, 'no_cur_rec', 'No current record for fetch operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-510, 335544575, 'dsql_cursor_update_err', 'Cursor @1 is not updatable.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-518, 335544582, 'dsql_request_err', 'Request unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-519, 335544688, 'dsql_open_cursor_request', 'The prepare statement identifies a prepare statement with an open cursor.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-530, 335544466, 'foreign_key', 'Violation of FOREIGN KEY constraint "@1" on table "@2".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-530, 335544838, 'foreign_key_target_doesnt_exist', 'Foreign key reference target does not exist.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-530, 335544839, 'foreign_key_references_present', 'Foreign key references are present for the record.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-531, 335544597, 'dsql_crdb_prepare_err', 'Cannot prepare a CREATE DATABASE/SCHEMA statement.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-532, 335544469, 'trans_invalid', 'Transaction marked invalid by I/O error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-551, 335544352, 'no_priv', 'No permission for @1 access to @2 @3.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-551, 335544790, 'insufficient_svc_privileges', 'Service @1 requires SYSDBA permissions. Reattach to the Service Manager using the SYSDBA account.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-552, 335544550, 'not_rel_owner', 'Only the owner of a table may reassign ownership.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-552, 335544553, 'grant_nopriv', 'User does not have GRANT privileges for operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-552, 335544707, 'grant_nopriv_on_base', 'User does not have GRANT privileges on base table/view for operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-553, 335544529, 'existing_priv_mod', 'Cannot modify an existing user privilege.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-595, 335544645, 'stream_crack', 'The current position is on a crack.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-596, 335544644, 'stream_bof', 'Illegal operation when at beginning of stream.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-597, 335544632, 'dsql_file_length_err', 'Preceding file did not specify length, so @1 must include starting page number.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-598, 335544633, 'dsql_shadow_number_err', 'Shadow number must be a positive integer.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-599, 335544607, 'node_err', 'Gen.c: node not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-599, 335544625, 'node_name_err', 'A node name is not permitted in a secondary, | shadow, cache or log file name.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-600, 335544680, 'crrp_data_err', 'Sort error: corruption in data structure.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-601, 335544646, 'db_or_file_exists', 'Database or file exists.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-604, 335544593, 'dsql_max_arr_dim_exceeded', 'Array declared with too many dimensions.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-604, 335544594, 'dsql_arr_range_error', 'Illegal array dimension range.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-605, 335544682, 'dsql_field_ref', 'Inappropriate self-reference of column.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 336003074, 'dsql_dbkey_from_non_table', 'Cannot SELECT RDB$DB_KEY from a stored procedure.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 336003086, 'dsql_udf_return_pos_err', 'External function should have return position between 1 and @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 336003096, 'dsql_type_not_supp_ext_tab', 'Data type @1 is not supported for EXTERNAL TABLES. Relation ''@2'', field ''@3''.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 335544351, 'no_meta_update', 'Unsuccessful metadata update.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 335544549, 'systrig_update', 'Cannot modify or erase a system trigger.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 335544657, 'dsql_no_blob_array', 'Array/BLOB/DATE data types not allowed in arithmetic.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 335544746, 'reftable_requires_pk', 'REFERENCES table without "(column)" requires PRIMARY KEY on referenced table.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 335544815, 'generator_name', 'GENERATOR @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 335544816, 'udf_name', 'UDF @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 335544858, 'must_have_phys_field', 'Can''t have relation with only computed fields or constraints.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 336397206, 'dsql_table_not_found', 'Table @1 does not exist.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 336397207, 'dsql_view_not_found', 'View @1 does not exist.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 336397212, 'dsql_no_array_computed', 'Array and BLOB data types not allowed in computed field.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-607, 336397214, 'dsql_only_can_subscript_array', 'Scalar operator used on field @1 which is not an array.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-612, 336068812, 'dyn_domain_name_exists', 'Cannot rename domain @1 to @2. A domain with that name already exists.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-612, 336068813, 'dyn_field_name_exists', 'Cannot rename column @1 to @2. A column with that name already exists in table @3.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-615, 335544475, 'relation_lock', 'Lock on table @1 conflicts with existing lock.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-615, 335544476, 'record_lock', 'Requested record lock conflicts with existing lock.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-615, 335544507, 'range_in_use', 'Refresh range number @1 already in use.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-616, 335544530, 'primary_key_ref', 'Cannot delete PRIMARY KEY being used in FOREIGN KEY definition.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-616, 335544539, 'integ_index_del', 'Cannot delete index used by an integrity constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-616, 335544540, 'integ_index_mod', 'Cannot modify index used by an integrity constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-616, 335544541, 'check_trig_del', 'Cannot delete trigger used by a CHECK constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-616, 335544543, 'cnstrnt_fld_del', 'Cannot delete column being used in an integrity constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-616, 335544630, 'dependency', 'There are @1 dependencies.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-616, 335544674, 'del_last_field', 'Last column in a table cannot be deleted.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-616, 335544728, 'integ_index_deactivate', 'Cannot deactivate index used by an integrity constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-616, 335544729, 'integ_deactivate_primary', 'Cannot deactivate index used by a PRIMARY/UNIQUE constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-617, 335544542, 'check_trig_update', 'Cannot update trigger used by a CHECK constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-617, 335544544, 'cnstrnt_fld_rename', 'Cannot rename column being used in an integrity constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-618, 335544537, 'integ_index_seg_del', 'Cannot delete index segment used by an integrity constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-618, 335544538, 'integ_index_seg_mod', '@@Cannot update index segment used by an integrity constraint.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-625, 335544347, 'not_valid', 'Validation error for column @1, value "@2".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-625, 335544879, 'not_valid_for_var', 'Validation error for variable @1, value "@2".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-625, 335544880, 'not_valid_for', 'Validation error for @1, value "@2".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-637, 335544664, 'dsql_duplicate_spec', 'Duplicate specification of @1- not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-637, 336397213, 'dsql_implicit_domain_name', 'Implicit domain name @1 not allowed in user created domain.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-660, 336003098, 'primary_key_required', 'Primary key required on table @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-660, 335544533, 'foreign_key_notfound', 'Non-existent PRIMARY or UNIQUE KEY specified for FOREIGN KEY.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-660, 335544628, 'idx_create_err', 'Cannot create index @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-663, 335544624, 'idx_seg_err', 'Segment count of 0 defined for index @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-663, 335544631, 'idx_key_err', 'Too many keys defined for index @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-663, 335544672, 'key_field_err', 'Too few key columns found for index @1 (incorrect column name?).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-664, 335544434, 'keytoobig', 'Key size exceeds implementation restriction for index "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-677, 335544445, 'ext_err', '@1 extension error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-685, 335544465, 'bad_segstr_type', 'Invalid BLOB type for operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-685, 335544670, 'blob_idx_err', 'Attempt to index BLOB column in index @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-685, 335544671, 'array_idx_err', 'Attempt to index array column in index @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-689, 335544403, 'badpagtyp', 'Page@1 is of wrong type (expected @2, found @3).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-689, 335544650, 'page_type_err', 'Wrong page type.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-690, 335544679, 'no_segments_err', 'Segments not allowed in expression index @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-691, 335544681, 'rec_size_err', 'New record size of @1 bytes is too big.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-692, 335544477, 'max_idx', 'Maximum indexes per table (@1) exceeded.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-693, 335544663, 'req_max_clones_exceeded', 'Too many concurrent executions of the same request.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-694, 335544684, 'no_field_access', 'Cannot access column @1 in view @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-802, 335544321, 'arith_except', 'Arithmetic exception, numeric overflow, or string truncation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-802, 335544836, 'concat_overflow', 'Concatenation overflow. Resulting string cannot exceed 32K in length.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-803, 335544349, 'no_dup', 'Attempt to store duplicate value (visible to active transactions) in unique index "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-803, 335544665, 'unique_key_violation', 'Violation of PRIMARY or UNIQUE KEY constraint "@1" on table "@2".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-804, 336003097, 'dsql_feature_not_supported_ods', 'Feature not supported on ODS version older than @1.@2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-804, 335544380, 'wronumarg', 'Wrong number of arguments on call.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-804, 335544583, 'dsql_sqlda_err', 'SQLDA missing or incorrect version, or incorrect number/type of variables.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-804, 335544584, 'dsql_var_count_err', 'Count of read-write columns does not equal count of values.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-804, 335544586, 'dsql_function_err', 'Function unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-804, 335544713, 'dsql_sqlda_value_err', 'Incorrect values within SQLDA structure.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-804, 336397205, 'dsql_too_old_ods', 'ODS versions before ODS@1 are not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-806, 335544600, 'col_name_err', 'Only simple column names permitted for VIEW WITH CHECK OPTION.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-807, 335544601, 'where_err', 'No WHERE clause for VIEW WITH CHECK OPTION.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-808, 335544602, 'table_view_err', 'Only one table allowed for VIEW WITH CHECK OPTION.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-809, 335544603, 'distinct_err', 'DISTINCT, GROUP or HAVING not permitted for VIEW WITH CHECK OPTION.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-810, 335544605, 'subquery_err', 'No subqueries permitted for VIEW WITH CHECK OPTION.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-811, 335544652, 'sing_select_err', 'Multiple rows in singleton select.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-816, 335544651, 'ext_readonly_err', 'Cannot insert because the file is readonly or is on a read only medium.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-816, 335544715, 'extfile_uns_op', 'Operation not supported for EXTERNAL FILE table @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 336003079, 'isc_sql_dialect_conflict_num', 'DB dialect @1 and client dialect @2 conflict with respect to numeric precision @3.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 336003101, 'upd_ins_with_complex_view', 'UPDATE OR INSERT without MATCHING could not be used with views based on more than one table.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 336003102, 'dsql_incompatible_trigger_type', 'Incompatible trigger type.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 336003103, 'dsql_db_trigger_type_cant_chang', 'Database trigger type can''t be changed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 335544361, 'read_only_trans', 'Attempted update during read-only transaction.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 335544371, 'segstr_no_write', 'Attempted write to read-only BLOB.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 335544444, 'read_only', 'Operation not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 335544765, 'read_only_database', 'Attempted update on read-only database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 335544766, 'must_be_dialect_2_and_up', 'SQL dialect @1 is not supported in this database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-817, 335544793, 'ddl_not_allowed_by_db_sql_dial', 'Metadata update statement is not allowed by the current database SQL dialect @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-820, 335544356, 'obsolete_metadata', 'Metadata is obsolete.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-820, 335544379, 'wrong_ods', 'Unsupported on-disk structure for file @1; found @2.@3, support @4.@5.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-820, 335544437, 'wrodynver', 'Wrong DYN version.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-820, 335544467, 'high_minor', 'Minor version too high found @1 expected @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-820, 335544881, 'need_difference', 'Difference file name should be set explicitly for database on raw device.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-823, 335544473, 'invalid_bookmark', 'Invalid bookmark handle.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-824, 335544474, 'bad_lock_level', 'Invalid lock level @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-825, 335544519, 'bad_lock_handle', 'Invalid lock handle.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-826, 335544585, 'dsql_stmt_handle', 'Invalid statement handle.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-827, 335544655, 'invalid_direction', 'Invalid direction for find operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-827, 335544718, 'invalid_key', 'Invalid key for find operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-828, 335544678, 'inval_key_posn', 'Invalid key position.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-829, 336068816, 'dyn_char_fld_too_small', 'New size specified for column @1 must be at least @2 characters.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-829, 336068817, 'dyn_invalid_dtype_conversion', 'Cannot change data type for @1. Conversion from base type @2 to @3 is not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-829, 336068818, 'dyn_dtype_conv_invalid', 'Cannot change data type for column @1 from a character type to a non-character type.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-829, 336068829, 'max_coll_per_charset', 'Maximum number of collations per character set exceeded.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-829, 336068830, 'invalid_coll_attr', 'Invalid collation attributes.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-829, 336068852, 'dyn_scale_too_big', 'New scale specified for column @1 must be at most @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-829, 336068853, 'dyn_precision_too_small', 'New precision specified for column @1 must be at least @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-829, 335544616, 'field_ref_err', 'Invalid column reference.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-830, 335544615, 'field_aggregate_err', 'Column used with aggregate.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-831, 335544548, 'primary_key_exists', 'Attempt to define a second PRIMARY KEY for the same table.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-832, 335544604, 'key_field_count_err', 'FOREIGN KEY column count does not match PRIMARY KEY.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-833, 335544606, 'expression_eval_err', 'Expression evaluation not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-833, 335544810, 'date_range_exceeded', 'Value exceeds the range for valid dates.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-834, 335544508, 'range_not_found', 'Refresh range number @1 not found.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-835, 335544649, 'bad_checksum', 'Bad checksum.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-836, 335544517, 'user_exc', 'Exception @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-836, 335544848, 'except2', 'Exception @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-837, 335544518, 'cache_restart', 'Restart shared cache manager.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-838, 335544560, 'shutwarn', 'Database @1 shutdown in @2 seconds.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-841, 335544677, 'version_err', 'Too many versions.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-842, 335544697, 'precision_err', 'Precision must be from 1 to 18.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-842, 335544698, 'scale_nogt', 'Scale must be between zero and precision.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-842, 335544699, 'expec_short', 'Short integer expected.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-842, 335544700, 'expec_long', 'Long integer expected.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-842, 335544701, 'expec_ushort', 'Unsigned short integer expected.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-842, 335544712, 'expec_positive', 'Positive value expected.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740929, 'gfix_db_name', 'Data base file name (@1) already given.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330753, 'gbak_unknown_switch', 'Found unknown switch.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336920577, 'gstat_unknown_switch', 'Found unknown switch.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336986113, 'fbsvcmgr_bad_am', 'Wrong value for access mode.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740930, 'gfix_invalid_sw', 'Invalid switch @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544322, 'bad_dbkey', 'Invalid database key.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336986114, 'fbsvcmgr_bad_wm', 'Wrong value for write mode.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330754, 'gbak_page_size_missing', 'Page size parameter missing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336920578, 'gstat_retry', 'Please retry, giving a database name.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336986115, 'fbsvcmgr_bad_rs', 'Wrong value for reserve space.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336920579, 'gstat_wrong_ods', 'Wrong ODS version, expected @1, encountered @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330755, 'gbak_page_size_toobig', 'Page size specified (@1) greater than limit (16384 bytes).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740932, 'gfix_incmp_sw', 'Incompatible switch combination.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336920580, 'gstat_unexpected_eof', 'Unexpected end of database file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330756, 'gbak_redir_ouput_missing', 'Redirect location for output is not specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336986116, 'fbsvcmgr_info_err', 'Unknown tag (@1) in info_svr_db_info block after isc_svc_query().'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740933, 'gfix_replay_req', 'Replay log pathname required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330757, 'gbak_switches_conflict', 'Conflicting switches for backup/restore.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336986117, 'fbsvcmgr_query_err', 'Unknown tag (@1) in isc_svc_query() results.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544326, 'bad_dpb_form', 'Unrecognized database parameter block.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740934, 'gfix_pgbuf_req', 'Number of page buffers for cache required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336986118, 'fbsvcmgr_switch_unknown', 'Unknown switch "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330758, 'gbak_unknown_device', 'Device type @1 not known.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544327, 'bad_req_handle', 'Invalid request handle.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740935, 'gfix_val_req', 'Numeric value required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330759, 'gbak_no_protection', 'Protection is not there yet.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544328, 'bad_segstr_handle', 'Invalid BLOB handle.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740936, 'gfix_pval_req', 'Positive Numeric value required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330760, 'gbak_page_size_not_allowed', 'Page size is allowed only on restore or create.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544329, 'bad_segstr_id', 'Invalid BLOB ID.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740937, 'gfix_trn_req', 'Number of transactions per sweep required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330761, 'gbak_multi_source_dest', 'Multiple sources or destinations specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544330, 'bad_tpb_content', 'Invalid parameter in transaction parameter block.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330762, 'gbak_filename_missing', 'Requires both input and output filenames.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544331, 'bad_tpb_form', 'Invalid format for transaction parameter block.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330763, 'gbak_dup_inout_names', 'Input and output have the same name. Disallowed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740940, 'gfix_full_req', 'full or "reserve" required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544332, 'bad_trans_handle', 'Invalid transaction handle (expecting explicit transaction start).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330764, 'gbak_inv_page_size', 'Expected page size, encountered "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740941, 'gfix_usrname_req', 'User name required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330765, 'gbak_db_specified', 'REPLACE specified, but the first file @1 is a database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740942, 'gfix_pass_req', 'Password required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330766, 'gbak_db_exists', 'Database @1 already exists. To replace it, use the -REP switch.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740943, 'gfix_subs_name', 'Subsystem name.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723983, 'gsec_cant_open_db', 'Unable to open database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330767, 'gbak_unk_device', 'Device type not specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723984, 'gsec_switches_error', 'Error in switch specifications.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740945, 'gfix_sec_req', 'Number of seconds required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544337, 'excess_trans', 'Attempt to start more than @1 transactions.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723985, 'gsec_no_op_spec', 'No operation specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740946, 'gfix_nval_req', 'Numeric value between 0 and 32767 inclusive required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723986, 'gsec_no_usr_name', 'No user name specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740947, 'gfix_type_shut', 'Must specify type of shutdown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544339, 'infinap', 'Information type inappropriate for object specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723987, 'gsec_err_add', 'Add record error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544340, 'infona', 'No information of this type available for object specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723988, 'gsec_err_modify', 'Modify record error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330772, 'gbak_blob_info_failed', 'Gds_$blob_info failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740948, 'gfix_retry', 'Please retry, specifying an option.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544341, 'infunk', 'Unknown information item.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723989, 'gsec_err_find_mod', 'Find/modify record error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330773, 'gbak_unk_blob_item', 'Do not understand BLOB INFO item @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544342, 'integ_fail', 'Action cancelled by trigger (@1) to preserve data integrity.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330774, 'gbak_get_seg_failed', 'Gds_$get_segment failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723990, 'gsec_err_rec_not_found', 'Record not found for user: @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723991, 'gsec_err_delete', 'Delete record error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330775, 'gbak_close_blob_failed', 'Gds_$close_blob failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740951, 'gfix_retry_db', 'Please retry, giving a database name.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330776, 'gbak_open_blob_failed', 'Gds_$open_blob failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723992, 'gsec_err_find_del', 'Find/delete record error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544345, 'lock_conflict', 'Lock conflict on no wait transaction.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330777, 'gbak_put_blr_gen_id_failed', 'Failed in put_blr_gen_id.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330778, 'gbak_unk_type', 'Data type @1 not understood.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330779, 'gbak_comp_req_failed', 'Gds_$compile_request failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330780, 'gbak_start_req_failed', 'Gds_$start_request failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723996, 'gsec_err_find_disp', 'Find/display record error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330781, 'gbak_rec_failed', 'gds_$receive failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336920605, 'gstat_open_err', 'Can''t open database file @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723997, 'gsec_inv_param', 'Invalid parameter, no switch defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544350, 'no_finish', 'Program attempted to exit without finishing database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336920606, 'gstat_read_err', 'Can''t read a database page.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330782, 'gbak_rel_req_failed', 'Gds_$release_request failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723998, 'gsec_op_specified', 'Operation already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336920607, 'gstat_sysmemex', 'System memory exhausted.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330783, 'gbak_db_info_failed', 'gds_$database_info failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336723999, 'gsec_pw_specified', 'Password already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724000, 'gsec_uid_specified', 'Uid already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330784, 'gbak_no_db_desc', 'Expected database description record.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544353, 'no_recon', 'Transaction is not in limbo.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724001, 'gsec_gid_specified', 'Gid already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330785, 'gbak_db_create_failed', 'Failed to create database @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724002, 'gsec_proj_specified', 'Project already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330786, 'gbak_decomp_len_error', 'RESTORE: decompression length error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544355, 'no_segstr_close', 'BLOB was not closed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330787, 'gbak_tbl_missing', 'Cannot find table @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724003, 'gsec_org_specified', 'Organization already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330788, 'gbak_blob_col_missing', 'Cannot find column for BLOB.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724004, 'gsec_fname_specified', 'First name already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544357, 'open_trans', 'Cannot disconnect database with open transactions (@1 active).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330789, 'gbak_create_blob_failed', 'Gds_$create_blob failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724005, 'gsec_mname_specified', 'Middle name already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544358, 'port_len', 'Message length error (encountered @1, expected @2).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330790, 'gbak_put_seg_failed', 'Gds_$put_segment failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724006, 'gsec_lname_specified', 'Last name already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330791, 'gbak_rec_len_exp', 'Expected record length.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724008, 'gsec_inv_switch', 'Invalid switch specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330792, 'gbak_inv_rec_len', 'Wrong length record, expected @1 encountered @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330793, 'gbak_exp_data_type', 'Expected data attribute.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724009, 'gsec_amb_switch', 'Ambiguous switch specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330794, 'gbak_gen_id_failed', 'Failed in store_blr_gen_id.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724010, 'gsec_no_op_specified', 'No operation specified for parameters.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544363, 'req_no_trans', 'No transaction for request.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330795, 'gbak_unk_rec_type', 'Do not recognize record type @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724011, 'gsec_params_not_allowed', 'No parameters allowed for this operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544364, 'req_sync', 'Request synchronization error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724012, 'gsec_incompat_switch', 'Incompatible switches specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330796, 'gbak_inv_bkup_ver', 'Expected backup version 1..8. Found @.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544365, 'req_wrong_db', 'Request referenced an unavailable database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330797, 'gbak_missing_bkup_desc', 'Expected backup description record.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330798, 'gbak_string_trunc', 'String truncated.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330799, 'gbak_cant_rest_record', 'warning record could not be restored.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330800, 'gbak_send_failed', 'Gds_$send failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544369, 'segstr_no_read', 'Attempted read of a new, open BLOB.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330801, 'gbak_no_tbl_name', 'No table name for data.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544370, 'segstr_no_trans', 'Attempted action on BLOB outside transaction.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330802, 'gbak_unexp_eof', 'Unexpected end of file on backup file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330803, 'gbak_db_format_too_old', 'Database format @1 is too old to restore to.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544372, 'segstr_wrong_db', 'Attempted reference to BLOB in unavailable database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330804, 'gbak_inv_array_dim', 'Array dimension for column @1 is invalid.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330807, 'gbak_xdr_len_expected', 'Expected XDR record length.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544376, 'unres_rel', 'Table @1 was omitted from the transaction reserving list.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544377, 'uns_ext', 'Request includes a DSRI extension not supported in this implementation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544378, 'wish_list', 'Feature is not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544382, 'erased_rec', 'cannot update erased record in RC REC_VER'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544383, 'fatal_conflict', 'Unrecoverable conflict with limbo transaction @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740991, 'gfix_exceed_max', 'Internal block exceeds maximum size.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740992, 'gfix_corrupt_pool', 'Corrupt pool.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740993, 'gfix_mem_exhausted', 'Virtual memory exhausted.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330817, 'gbak_open_bkup_error', 'Cannot open backup file @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740994, 'gfix_bad_pool', 'Bad pool id.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330818, 'gbak_open_error', 'Cannot open status and error output file @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335740995, 'gfix_trn_not_valid', 'Transaction state @1 not in valid range.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544392, 'bdbincon', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724044, 'gsec_inv_username', 'Invalid user name (maximum 31 bytes allowed).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724045, 'gsec_inv_pw_length', 'Warning- maximum 8 significant bytes of password used.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724046, 'gsec_db_specified', 'Database already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724047, 'gsec_db_admin_specified', 'Database administrator name already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724048, 'gsec_db_admin_pw_specified', 'Database administrator password already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336724049, 'gsec_sql_role_specified', 'SQL role name already specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335741012, 'gfix_unexp_eoi', 'Unexpected end of input.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544407, 'dbbnotzer', 'Database handle not zero.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544408, 'tranotzer', 'Transaction handle not zero.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335741018, 'gfix_recon_fail', 'Failed to reconnect to a transaction in database @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544418, 'trainlim', 'Transaction in limbo.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544419, 'notinlim', 'Transaction not in limbo.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544420, 'traoutsta', 'Transaction outstanding.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544428, 'badmsgnum', 'Undefined message number.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335741036, 'gfix_trn_unknown', 'Transaction description item unknown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335741038, 'gfix_mode_req', 'read_only or "read_write" required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544431, 'blocking_signal', 'Blocking signal has been received.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335741042, 'gfix_pzval_req', 'Positive or zero numeric value required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544442, 'noargacc_read', 'Database system cannot read argument @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544443, 'noargacc_write', 'Database system cannot write argument @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544450, 'misc_interpreted', '@1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544468, 'tra_state', 'Transaction @1 is @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544485, 'bad_stmt_handle', 'Invalid statement handle.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330934, 'gbak_missing_block_fac', 'Blocking factor parameter missing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330935, 'gbak_inv_block_fac', 'Expected blocking factor, encountered "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330936, 'gbak_block_fac_specified', 'A blocking factor may not be used in conjunction with device CT.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068796, 'dyn_role_does_not_exist', 'SQL role @1 does not exist.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330940, 'gbak_missing_username', 'User name parameter missing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330941, 'gbak_missing_password', 'Password parameter missing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068797, 'dyn_no_grant_admin_opt', 'User @1 has no grant admin option on SQL role @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544510, 'lock_timeout', 'Lock time-out on wait transaction.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068798, 'dyn_user_not_role_member', 'User @1 is not a member of SQL role @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068799, 'dyn_delete_role_failed', '@1 is not the owner of SQL role @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068800, 'dyn_grant_role_to_user', '@1 is a SQL role and not a user.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068801, 'dyn_inv_sql_role_name', 'User name @1 could not be used for SQL role.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068802, 'dyn_dup_sql_role', 'SQL role @1 already exists.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068803, 'dyn_kywd_spec_for_role', 'Keyword @1 can not be used as a SQL role name.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068804, 'dyn_roles_not_supported', 'SQL roles are not supported in on older versions of the database. A backup and restore of the databa'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330952, 'gbak_missing_skipped_bytes', 'Missing parameter for the number of bytes to be skipped.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330953, 'gbak_inv_skipped_bytes', 'Expected number of bytes to be skipped, encountered "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068820, 'dyn_zero_len_id', 'Zero length identifiers are not allowed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330965, 'gbak_err_restore_charset', 'Character set.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330967, 'gbak_err_restore_collation', 'Collation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330972, 'gbak_read_error', 'Unexpected I/O error while reading from backup file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330973, 'gbak_write_error', 'Unexpected I/O error while writing to backup file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068840, 'dyn_wrong_gtt_scope', '@1 cannot reference @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330985, 'gbak_db_in_use', 'Could not drop database @1 (database might be in use).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336330990, 'gbak_sysmemex', 'System memory exhausted.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544559, 'bad_svc_handle', 'Invalid service handle.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544561, 'wrospbver', 'Wrong version of service parameter block.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544562, 'bad_spb_form', 'Unrecognized service parameter block.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544563, 'svcnotdef', 'Service @1 is not defined.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336068856, 'dyn_ods_not_supp_feature', 'Feature ''@1'' is not supported in ODS @2.@3.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331002, 'gbak_restore_role_failed', 'SQL role.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331005, 'gbak_role_op_missing', 'SQL role parameter missing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331010, 'gbak_page_buffers_missing', 'Page buffers parameter missing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331011, 'gbak_page_buffers_wrong_param', 'Expected page buffers, encountered "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331012, 'gbak_page_buffers_restore', 'Page buffers is allowed only on restore or create.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331014, 'gbak_inv_size', 'Size specification either missing or incorrect for file @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331015, 'gbak_file_outof_sequence', 'File @1 out of sequence.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331016, 'gbak_join_file_missing', 'Can''t join: one of the files missing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331017, 'gbak_stdin_not_supptd', 'Standard input is not supported when using join operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331018, 'gbak_stdout_not_supptd', 'Standard output is not supported when using split operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331019, 'gbak_bkup_corrupt', 'Backup file @1 might be corrupt.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331020, 'gbak_unk_db_file_spec', 'Database file specification missing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331021, 'gbak_hdr_write_failed', 'Can''t write a header record to file @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331022, 'gbak_disk_space_ex', 'Free disk space exhausted.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331023, 'gbak_size_lt_min', 'File size given (@1) is less than minimum allowed (@2).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331025, 'gbak_svc_name_missing', 'Service name parameter missing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331026, 'gbak_not_ownr', 'Cannot restore over current database, must be SYSDBA or owner of the existing database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331031, 'gbak_mode_req', 'read_only or "read_write" required.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331033, 'gbak_just_data', 'Just data ignore all constraints etc.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336331034, 'gbak_data_only', 'Restoring data only ignoring foreign key, unique, not null & other constraints.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544609, 'index_name', 'INDEX @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544610, 'exception_name', 'EXCEPTION @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544611, 'field_name', 'COLUMN @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544613, 'union_err', 'Union not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544614, 'dsql_construct_err', 'Unsupported DSQL construct.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544623, 'dsql_domain_err', 'Illegal use of keyword VALUE.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544626, 'table_name', 'TABLE @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544627, 'proc_name', 'PROCEDURE @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544641, 'dsql_domain_not_found', 'Specified domain or source column @1 does not exist.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544656, 'dsql_var_conflict', 'Variable @1 conflicts with parameter in same procedure.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544666, 'srvr_version_too_old', 'Server version too old to support all CREATE DATABASE options.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544673, 'no_delete', 'Cannot delete.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544675, 'sort_err', 'Sort error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544703, 'svcnoexe', 'Service @1 does not have an associated executable.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544704, 'net_lookup_err', 'Failed to locate host machine.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544705, 'service_unknown', 'Undefined service @1/@2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544706, 'host_unknown', 'The specified name was not found in the hosts file or Domain Name Services.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544711, 'unprepared_stmt', 'Attempt to execute an unprepared dynamic SQL statement.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544716, 'svc_in_use', 'Service is currently busy: @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544731, 'tra_must_sweep', ''); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544740, 'udf_exception', 'A fatal exception occurred during the execution of a user defined function.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544741, 'lost_db_connection', 'Connection lost to database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544742, 'no_write_user_priv', 'User cannot write to RDB$USER_PRIVILEGES.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544767, 'blob_filter_exception', 'A fatal exception occurred during the execution of a blob filter.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544768, 'exception_access_violation', 'Access violation. The code attempted to access a virtual address without privilege to do so.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544769, 'exception_datatype_missalignmen', 'Data type misalignment. The attempted to read or write a value that was not stored on a memory bound'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544770, 'exception_array_bounds_exceeded', 'Array bounds exceeded. The code attempted to access an array element that is out of bounds.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544771, 'exception_float_denormal_operan', 'Float denormal operand. One of the floating-point operands is too small to represent a standard floa'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544772, 'exception_float_divide_by_zero', 'Floating-point divide by zero. The code attempted to divide a floating-point value by zero.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544773, 'exception_float_inexact_result', 'Floating-point inexact result. The result of a floating-point operation cannot be represented as a d'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544774, 'exception_float_invalid_operand', 'Floating-point invalid operand. An indeterminant error occurred during a floating-point operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544775, 'exception_float_overflow', 'Floating-point overflow. The exponent of a floating-point operation is greater than the magnitude al'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544776, 'exception_float_stack_check', 'Floating-point stack check. The stack overflowed or underflowed as the result of a floating-point op'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544777, 'exception_float_underflow', 'Floating-point underflow. The exponent of a floating-point operation is less than the magnitude allo'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544778, 'exception_integer_divide_by_zer', 'Integer divide by zero. The code attempted to divide an integer value by an integer divisor of zero.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544779, 'exception_integer_overflow', 'Integer overflow. The result of an integer operation caused the most significant bit of the result t'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544780, 'exception_unknown', 'An exception occurred that does not have a description. Exception number @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544781, 'exception_stack_overflow', 'Stack overflow. The resource requirements of the runtime stack have exceeded the memory available to'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544782, 'exception_sigsegv', 'Segmentation fault. The code attempted to access memory without privileges.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544783, 'exception_sigill', 'Illegal instruction. The code attempted to perform an illegal operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544784, 'exception_sigbus', 'Bus error. The code caused a system bus error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544785, 'exception_sigfpe', 'Floating point error. The code caused an arithmetic exception or a floating point exception.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544786, 'ext_file_delete', 'Cannot delete rows from external files.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544787, 'ext_file_modify', 'Cannot update rows in external files.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544788, 'adm_task_denied', 'Unable to perform operation. You must be either SYSDBA or owner of the database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544794, 'cancelled', 'Operation was cancelled.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544797, 'svcnouser', 'User name and password are required while attaching to the services manager.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544801, 'datype_notsup', 'Data type not supported for arithmetic.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544803, 'dialect_not_changed', 'Database dialect not changed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544804, 'database_create_failed', 'Unable to create database @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544805, 'inv_dialect_specified', 'Database dialect @1 is not a valid dialect.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544806, 'valid_db_dialects', 'Valid database dialects are @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544811, 'inv_client_dialect_specified', 'Passed client dialect @1 is not a valid dialect.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544812, 'valid_client_dialects', 'Valid client dialects are @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544814, 'service_not_supported', 'Services functionality will be supported in a later version of the product.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544820, 'invalid_savepoint', 'Unable to find savepoint with name @1 in transaction context.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544835, 'bad_shutdown_mode', 'Target shutdown mode is invalid for database "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544840, 'no_update', 'Cannot update.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544842, 'stack_trace', '@1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544843, 'ctx_var_not_found', 'Context variable @1 is not found in namespace @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544844, 'ctx_namespace_invalid', 'Invalid namespace name @1 passed to @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544845, 'ctx_too_big', 'Too many context variables.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544846, 'ctx_bad_argument', 'Invalid argument passed to @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544847, 'identifier_too_long', 'BLR syntax error. Identifier @1... is too long.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544859, 'invalid_time_precision', 'Time precision exceeds allowed range (0-@1).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544866, 'met_wrong_gtt_scope', '@1 cannot depend on @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544868, 'illegal_prc_type', 'Procedure @1 is not selectable (it does not contain a SUSPEND statement).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544869, 'invalid_sort_datatype', 'Data type @1 is not supported for sorting operation.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544870, 'collation_name', 'COLLATION @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544871, 'domain_name', 'DOMAIN @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544874, 'max_db_per_trans_allowed', 'A multi database transaction cannot span more than @1 databases.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544876, 'bad_proc_BLR', 'Error while parsing procedure @1''s BLR.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 335544877, 'key_too_big', 'Index key too big.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336397211, 'dsql_too_many_values', 'Too many values (more than @1) in member list to match against.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-901, 336397236, 'dsql_unsupp_feature_dialect', 'Feature is not supported in dialect @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544333, 'bug_check', 'Internal gds software consistency check (@1).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544335, 'db_corrupt', 'Database file appears corrupt (@1).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544344, 'io_error', 'I/O error for file "@2".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544346, 'metadata_corrupt', 'Corrupt system table.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544373, 'sys_request', 'Operating system directive @1 failed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544384, 'badblk', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544385, 'invpoolcl', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544387, 'relbadblk', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544388, 'blktoobig', 'Block size exceeds implementation restriction.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544394, 'badodsver', 'Incompatible version of on-disk structure.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544397, 'dirtypage', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544398, 'waifortra', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544399, 'doubleloc', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544400, 'nodnotfnd', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544401, 'dupnodfnd', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544402, 'locnotmar', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544404, 'corrupt', 'Database corrupted.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544405, 'badpage', 'Checksum error on database page @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544406, 'badindex', 'Index is broken.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544409, 'trareqmis', 'Transaction request mismatch (synchronization error).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544410, 'badhndcnt', 'Bad handle count.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544411, 'wrotpbver', 'Wrong version of transaction parameter block.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544412, 'wroblrver', 'Unsupported BLR version (expected @1, encountered @2).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544413, 'wrodpbver', 'Wrong version of database parameter block.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544415, 'badrelation', 'Database corrupted.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544416, 'nodetach', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544417, 'notremote', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544422, 'dbfile', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544423, 'orphan', 'Internal error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544432, 'lockmanerr', 'Lock manager error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544436, 'sqlerr', 'SQL error code = @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544448, 'bad_sec_info', ''); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544449, 'invalid_sec_info', ''); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544470, 'buf_invalid', 'Cache buffer for page @1 invalid.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544471, 'indexnotdefined', 'There is no index in table @1 with id @2.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544472, 'login', 'Your user name and password are not defined. Ask your database administrator to set up a Firebird lo'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544506, 'shutinprog', 'Database @1 shutdown in progress.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544528, 'shutdown', 'Database @1 shutdown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544557, 'shutfail', 'Database shutdown unsuccessful.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544569, 'dsql_error', 'Dynamic SQL Error.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544653, 'psw_attach', 'Cannot attach to password database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544654, 'psw_start_trans', 'Cannot start transaction for password database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544717, 'err_stack_limit', 'Stack size insufficent to execute current request.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544721, 'network_error', 'Unable to complete network request to host "@1".'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544722, 'net_connect_err', 'Failed to establish a connection.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544723, 'net_connect_listen_err', 'Error while listening for an incoming connection.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544724, 'net_event_connect_err', 'Failed to establish a secondary connection for event processing.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544725, 'net_event_listen_err', 'Error while listening for an incoming event connection request.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544726, 'net_read_err', 'Error reading data from the connection.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544727, 'net_write_err', 'Error writing data to the connection.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544732, 'unsupported_network_drive', 'Access to databases on file servers is not supported.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544733, 'io_create_err', 'Error while trying to create file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544734, 'io_open_err', 'Error while trying to open file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544735, 'io_close_err', 'Error while trying to close file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544736, 'io_read_err', 'Error while trying to read from file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544737, 'io_write_err', 'Error while trying to write to file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544738, 'io_delete_err', 'Error while trying to delete file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544739, 'io_access_err', 'Error while trying to access file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544745, 'login_same_as_role_name', 'Your login @1 is same as one of the SQL role name. Ask your database administrator to set up a valid'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544791, 'file_in_use', 'The file @1 is currently in use by another process. Try again later.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544795, 'unexp_spb_form', 'Unexpected item in service parameter block, expected @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544809, 'extern_func_dir_error', 'Function @1 is in @2, which is not in a permitted directory for external functions.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544819, 'io_32bit_exceeded_err', 'File exceeded maximum size of 2GB. Add another database file or use a 64 bit I/O version of Firebird'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544831, 'conf_access_denied', 'Access to @1 "@2" is denied by server administrator.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544834, 'cursor_not_open', 'Cursor is not open.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544841, 'cursor_already_open', 'Cursor is already open.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544856, 'att_shutdown', 'Connection shutdown.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-902, 335544882, 'long_login', 'Login name too long (@1 characters, maximum allowed @2).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544324, 'bad_db_handle', 'Invalid database handle (no active connection).'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544375, 'unavailable', 'Unavailable database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544381, 'imp_exc', 'Implementation limit exceeded.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544386, 'nopoolids', 'Too many requests.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544389, 'bufexh', 'Buffer exhausted.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544391, 'bufinuse', 'Buffer in use.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544393, 'reqinuse', 'Request in use.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544424, 'no_lock_mgr', 'No lock manager available.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544430, 'virmemexh', 'Unable to allocate memory from operating system.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544451, 'update_conflict', 'Update conflicts with concurrent update.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544453, 'obj_in_use', 'Object @1 is in use.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544455, 'shadow_accessed', 'Cannot attach active shadow file.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544460, 'shadow_missing', 'A file in manual shadow @1 is unavailable.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544661, 'index_root_page_full', 'Cannot add index, index root page is full.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544676, 'sort_mem_err', 'Sort error: not enough memory.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544683, 'req_depth_exceeded', 'Request depth exceeded. (Recursive definition?)'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544758, 'sort_rec_size_err', 'Sort record size of @1 bytes is too big.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544761, 'too_many_handles', 'Too many open handles to database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544792, 'service_att_err', 'Cannot attach to services manager.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544799, 'svc_name_missing', 'The service name was not specified.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544813, 'optimizer_between_err', 'Unsupported field type specified in BETWEEN predicate.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544827, 'exec_sql_invalid_arg', 'Invalid argument in EXECUTE STATEMENT cannot convert to string.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544828, 'exec_sql_invalid_req', 'Wrong request type in EXECUTE STATEMENT ''@1''.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544829, 'exec_sql_invalid_var', 'Variable type (position @1) in EXECUTE STATEMENT ''@2'' INTO does not match returned column type.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544830, 'exec_sql_max_call_exceeded', 'Too many recursion levels of EXECUTE STATEMENT.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544832, 'wrong_backup_state', 'Cannot change difference file name while database is in backup mode.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544852, 'partner_idx_incompat_type', 'Partner index segment no @1 has incompatible data type.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544857, 'blobtoobig', 'Maximum BLOB size exceeded.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544862, 'record_lock_not_supp', 'Stream does not support record locking.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544863, 'partner_idx_not_found', 'Cannot create foreign key constraint @1. Partner index does not exist or is inactive.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544864, 'tra_num_exc', 'Transactions count exceeded. Perform backup and restore to make database operable again.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544865, 'field_disappeared', 'Column has been unexpectedly deleted.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-904, 335544878, 'concurrent_transaction', 'Concurrent transaction number is @1.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-906, 335544744, 'max_att_exceeded', 'Maximum user count exceeded. Contact your database administrator.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-909, 335544667, 'drdb_completed_with_errs', 'Drop database completed with errors.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-911, 335544459, 'rec_in_limbo', 'Record from transaction @1 is stuck in limbo.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-913, 335544336, 'deadlock', 'Deadlock.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-922, 335544323, 'bad_db_format', 'File @1 is not a valid database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-923, 335544421, 'connect_reject', 'Connection rejected by remote interface.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-923, 335544461, 'cant_validate', 'Secondary server attachments cannot validate databases.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-923, 335544464, 'cant_start_logging', 'Secondary server attachments cannot start logging.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-924, 335544325, 'bad_dpb_content', 'Bad parameters on attach or create database.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-924, 335544441, 'bad_detach', 'Database detach completed with errors.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-924, 335544648, 'conn_lost', 'Connection lost to pipe server.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-926, 335544447, 'no_rollback', 'No rollback performed.'); insert into fb_errors(fb_sqlcode, fb_gdscode, fb_mnemona, fb_errtext) values(-999, 335544689, 'ib_error', 'Firebird error.'); commit; set term ^; execute block as declare v_tab_name dm_dbobj; declare v_idx_name dm_dbobj; declare v_ctr_type dm_dbobj; declare v_ctr_name dm_dbobj; declare v_run_ddl varchar(128); declare v_rel_list varchar(255); declare v_halt_on_err_list dm_setting_value = ',,'; declare v_log_pk_violation dm_setting_value = '1'; begin select s.svalue from settings s where s.mcode='HALT_TEST_ON_ERRORS' into v_halt_on_err_list; select s.svalue from settings s where s.mcode='LOG_PK_VIOLATION' into v_log_pk_violation; if ( v_log_pk_violation = '1' or v_halt_on_err_list containing ',PK,' ) then exit; v_rel_list = 'doc_data,qdistr,qstorned,pdistr,pstorned'; for select ri.rdb$relation_name tab_name, ri.rdb$index_name idx_name, rc.rdb$constraint_type ctr_type, rc.rdb$constraint_name ctr_name from rdb$indices ri join rdb$index_segments rs on ri.rdb$index_name = rs.rdb$index_name left join rdb$relation_constraints rc on ri.rdb$relation_name=rc.rdb$relation_name and ri.rdb$index_name = rc.rdb$index_name and lower(rc.rdb$constraint_type) in ('primary key','unique') where ri.rdb$index_type is distinct from 1 and position( ','||lower(trim(ri.rdb$relation_name))||',' in ','|| :v_rel_list ||',') > 0 and lower(rs.rdb$field_name)='id' into v_tab_name, v_idx_name, v_ctr_type, v_ctr_name do begin v_run_ddl = iif( v_ctr_name is not null, 'alter table '||trim(v_tab_name)||' drop constraint '||trim(v_ctr_name), 'drop index '||trim(v_idx_name) ); execute statement(v_run_ddl) with autonomous transaction; end end ^ set term ;^ commit; set list on; select 'oltp_main_filling.sql finish' as msg, current_timestamp from rdb$database; set list off; commit;
