{
'id': 'bugs.core_2493',
'qmid': '',
'tracker_id': 'CORE-2493',
'title': 'Append the IP address of the remote host to error messages in firebird.log for TCP connections',
'description':
 """
   Following actions are performed by this test:
   
   1. Obtain current firebird.log and saves it to the file with name = 'tmp_2493_fblog_before.txt';
   
   2. Asynchronously launch ISQL in child process with request to return client IP address (via asking context variable)
      and after this - do some 'heavy query' that for sure will take a lot of time and resources.
      Output is redirected to file with name = 'tmp_2493_isql.log' and will be parsed further (we'll search for client IP there).
   
   3. Kill launched ISQL process after several seconds. At this point new message must appear in firebird.log and it MUST
      be in format described in the ticket. Because this abend will be detected by SERVER, format of message will be like this:
      (for TCPv4):  INET/inet_error: read errno = 10054, client host = prog1, address = 127.0.0.1/4076, user = john
      (for TCPv6):  INET/inet_error: read errno = 10054, client host = prog2, address = fe80::c40e:21ec:b5c7:8963/56831, user = mick
   
   4. Wait several seconds and after it - obtain again firebird.log (new content) and save it in 'tmp_2493_fblog_after.txt'.
   
   5. Make file comparison by calling method from standard Python tool - difflib. Result of this comparison will be stored
      in file with name 'tmp_2493_diff.txt'. This file will have several lines from which we are interested only for one which
      STARTS with "+" (PLUS sign) and does contain phrase 'INET/INET_ERROR'. Diff-file must contain only ONE such line.
   
   6. Next we parse this line: remove "/" and "="characters from it and split then text into array of words:
      + INET inet_error read errno 10054 client host prog1 address 127.0.0.1 4417   user john ------- for IPv4
      0  1       2       3    4      5     6     7     8       9       10      11     12   13
      + INET inet_error read errno 10054 client host prog2 address x::y:z:u:v 56831 user mick ------- for IPv6

   7. Then we scan this array backward and check tokens for matching simple rules (N = array len):
      * token N-1 must be OS user name; this name can be followed by some kind of "suffix": "JOHN.-1.-1" - and we have to take only 1st word from it.
        NB: we current OS user using call of getpass.getuser(). It must be compared in case insensitive manner;
      * token N-2 is just word "user" (as is);
      * token N-3 is port number, it has to be positive value;
      * token N-4 is IP. It must be equal to rdb$get_context('SYSTEM','CLIENT_ADDRESS').

      This is how differences look in firebird.log:
      # 2.5.9:
      #       INET/inet_error: read errno = 10054, client address = 127.0.0.1 3268, user ZOTOV.-1.-1
      #                                                                   ^    ^    ^      ^
      #                                                                  N-4  N-3  N-2    N-1
      # 3.0.4:
      #       INET/inet_error: read errno = 10054, client host = csprog, address = 127.0.0.1 3298, user zotov
      #                                                                                 ^     ^    ^      ^
      #                                                                                N-4   N-3  N-2   N-1



   Checked on WI-V3.0.0.32272 x86 and amd64, OS = Windows XP and 8.1, TCPv4 and TCPv6; fdb version = 1.5, Python 2.7 and 3.4.
   Checked 17.02.2018 after adding 2.5.9 to the list of avaliable versions:
       2.5.9.27103: OK, 5.547s.
       3.0.3.32837: OK, 7.079s.
       3.0.4.32912: OK, 6.094s.
       4.0.0.800: OK, 7.109s.
       4.0.0.890: OK, 6.360s.
   ### NB ###
   First version of this test was implemented on Windows XP and Python 2.7.8, build 02-jul-2014 win32.
   Unfortunatelly, on Python 3.4 + Win 8.1 it is unable to use socket.inet_pton() call -exception raises with text:
   "AttributeError: 'module' object has no attribute 'inet_pton'".
   For that reason it was decided do NOT use calls of socket.inet_pton() and operate only with remote_address that can be easy
   received using built-in FB context variable. User-defined functions 'is_valid_ipv4' and 'is_valid_ipv6' are left here for
   possible further usage in some other tests.
 """   ,
'min_versions': '2.5.9',
'versions': [
{
 'firebird_version': '2.5',
 'platform': 'All',
 'init_script':
  """
    recreate table log(ip varchar(255));
    create sequence g;
    commit;
  """,
 'test_type': 'Python',
 'test_script': 
  """\
import os
import time
import subprocess
from subprocess import Popen
import signal
import difflib
import re
import socket
import getpass



os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password

# Obtain engine version:
cur1 = db_conn.cursor()

cur1.execute("select rdb$get_context('SYSTEM','ENGINE_VERSION') as engine_version from rdb$database")
for row in cur1:
    engine = row[0]

db_conn.close()

#---------------------------------------------------------------

def svc_get_fb_log( engine, f_fb_log ):

    import subprocess

    if engine.startswith('2.5'):
        get_firebird_log_key='action_get_ib_log'
    else:
        get_firebird_log_key='action_get_fb_log'

    subprocess.call([ "fbsvcmgr",
                      "localhost:service_mgr",
                      get_firebird_log_key
                    ],
                     stdout=f_fb_log, 
                     stderr=subprocess.STDOUT
                   )

    return


#---------------------------------------------------------------

# http://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python
def is_valid_ipv4(address):
    import socket
    try:
        socket.inet_pton(socket.AF_INET, address)
    except AttributeError:  # no inet_pton here, sorry
        try:
            socket.inet_aton(address)
        except socket.error:
            return False
        return address.count('.') == 3
    except socket.error:  # not a valid address
        return False

    return True


#---------------------------------------------------------------

def is_valid_ipv6(address):
    import socket
    try:
        socket.inet_pton(socket.AF_INET6, address)
    except socket.error:  # not a valid address
        return False
    return True


#---------------------------------------------------------------


f_fblog_before=open( os.path.join(context['temp_directory'],'tmp_2493_fblog_before.txt'), 'w')

svc_get_fb_log( engine, f_fblog_before )

f_fblog_before.close()

isql_txt='''\
insert into log(ip) values( rdb$get_context('SYSTEM','CLIENT_ADDRESS') );
commit;
select count(i) from (select gen_id(g,1) i from rdb$types a,rdb$types b,rdb$types c,rdb$types d);
'''

f_sql_txt=open( os.path.join(context['temp_directory'],'tmp_2493_isql.sql'), 'w')
f_sql_txt.write(isql_txt)
f_sql_txt.close()

f_sql_log=open( os.path.join(context['temp_directory'],'tmp_2493_isql.log'), 'w')
f_sql_err=open( os.path.join(context['temp_directory'],'tmp_2493_isql.err'), 'w')

p_isql=Popen( [ "isql", dsn, "-user","SYSDBA","-password","masterkey", "-i", f_sql_txt.name ], \
                          stdout=f_sql_log, stderr=f_sql_err
                      )
time.sleep(3)

p_isql.terminate()

f_sql_log.close()
f_sql_err.close()

time.sleep(1)

f_sql_txt=open( os.path.join(context['temp_directory'],'tmp_2493_isql.sql'), 'w')
f_sql_txt.write("set heading off; select iif(gen_id(g,0) = 0, 'Trouble with subprocess: job was not started.', ip) as msg from log; quit;")
f_sql_txt.close()

mon_ip=subprocess.check_output( ['isql', dsn,'-user',user_name,'-pass',user_password, '-i', f_sql_txt.name ]).split()[0]

f_fblog_after=open( os.path.join(context['temp_directory'],'tmp_2493_fblog_after.txt'), 'w')

svc_get_fb_log( engine, f_fblog_after )

f_fblog_after.close()

time.sleep(1)

oldfb=open(f_fblog_before.name, 'r')
newfb=open(f_fblog_after.name, 'r')

difftext = ''.join(difflib.unified_diff(
    oldfb.readlines(), 
    newfb.readlines()
  ))
oldfb.close()
newfb.close()

f_diff_txt=open( os.path.join(context['temp_directory'],'tmp_2493_diff.txt'), 'w')
f_diff_txt.write(difftext)
f_diff_txt.close()

# Sample of comparison result (file tmp_2493_diff.txt):
# --- 
# +++ 
# @@ -1 +1,4 @@
# - + 
# +CSPROG	Tue Jan 12 17:54:27 2016
# +	INET/inet_error: read errno = 10054, client host = prog1, address = 127.0.0.1/4076, user = john
# +     INET/inet_error: read errno = 10054, client host = prog2, address = fe80::c40e:21ec:b5c7:8963/56831, user = mick
# +

# 2.5.9:
#       INET/inet_error: read errno = 10054, client address = 127.0.0.1/3268, user = ZOTOV.-1.-1
#                                                                   ^         ^    ^    ^
#                                                                  N-3       N-2  N-1   N
# 3.0.4:
#       INET/inet_error: read errno = 10054, client host = csprog, address = 127.0.0.1/3298, user = zotov
#                                                                                 ^          ^    ^   ^
#                                                                                N-3        N-2  N-1  N

lst=[]
logged_err=0
with open( f_diff_txt.name,'r') as f:
    for line in f:
        i=1
        if line.startswith('+') and 'INET/INET_ERROR' in line.upper():
            #lst=line.replace(',',' ').replace('/',' ').replace('=',' ').replace(':',' ').split()
            lst=line.replace(',',' ').replace('/',' ').replace('=',' ').split()
            break
f.close()

# Tokens, numerated from zero (NB: leftmost is "PLUS" sign and has index = 0)
# ---------------------------------------------------------------------------
# + INET inet_error read errno 10054 client host prog1 address 127.0.0.1 4417   user john ------- for IPv4
# 0  1       2       3    4      5     6     7     8       9       10      11     12   13
# + INET inet_error read errno 10054 client host prog2 address x::y:z:u:v 56831 user mick ------- for IPv6

n = len(lst)

if 1==0: # len(lst)<14:
    print('Message with "inet_error" could be parsed only for '+str(len(lst))+' elements. Minimum required is 14.')
else:

    #print('Fixed data: '+lst[4]+' '+lst[5]+' '+lst[6]+' '+lst[7])

    # http://stackoverflow.com/questions/4271740/how-can-i-use-python-to-get-the-system-hostname
   
    
    # commented 17.02.2017 due to 2.5.9 (no info about remote host there):
    #if lst[8].upper()==socket.gethostname().upper():
    #    print('Remote host: valid, passed socket.gethostname()')
    #else:
    #    print('Invalid host=|'+lst[8]+'|')

    # does not work on Python 3.4! >>> if is_valid_ipv4(lst[10]) or is_valid_ipv6(lst[10]):
    if lst[n-4] + '/' + lst[n-3] == mon_ip:
        print("String IP/port: valid, equal to 'CLIENT_ADDRESS'")
    else:
        print('Invalid IP/port=|'+lst[n-4]+'/'+lst[n-3]+'| - differ from mon_ip=|'+mon_ip+'|')

    if lst[n-3].isdigit():
        print('Port value: valid, positive integer.')
    else:
        print('Invalid port=|'+lst[n-3]+'|')

    if lst[n-1].upper().split('.')[0] == getpass.getuser().upper():
        # 2.5.9: got 'ZOTOV.-1.-1' ==> must be kust of one word: 'ZOTOV'
        print('OS user: valid, passed getpass.getuser()')
    else:
        print('Invalid OS user=|'+lst[n-1]+'|')

#############################################
# Cleanup.
f_list=( 
    f_sql_txt
    ,f_sql_log
    ,f_sql_err
    ,f_fblog_before
    ,f_fblog_after
    ,f_diff_txt
)

for i in range(len(f_list)):
    if os.path.isfile(f_list[i].name):
        os.remove(f_list[i].name)

#    Fixed data: errno 10054 client host
#    Remote host: valid, passed socket.gethostname()

  """,
 'expected_stdout': 
  """
    String IP/port: valid, equal to 'CLIENT_ADDRESS'
    Port value: valid, positive integer.
    OS user: valid, passed getpass.getuser()
  """,
 'expected_stderr': 
  """
  """
}
]
}
