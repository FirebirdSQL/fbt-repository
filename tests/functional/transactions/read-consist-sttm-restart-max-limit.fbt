{
'id': 'functional.transactions.read-consist-sttm-restart-max-limit',
'qmid': '',
'tracker_id': '',
'title': "READ CONSISTENCY. Maximal number of statement-level restarts must be 10.",
'description': 
 """
    Initial article for reading:
    https://asktom.oracle.com/pls/asktom/f?p=100:11:::::P11_QUESTION_ID:11504247549852
    Note on terms which are used there: "BLOCKER", "LONG" and "FIRSTLAST" - their names are slightly changed here
    to: LOCKER-1, WORKER and LOCKER-2 respectively.

    See also: doc\README.read_consistency.md
    Letter from Vlad: 15.09.2020 20:04 // subj "read consistency // addi test(s)"

    ::: NB :::
    This test uses script %FBT_REPO%\files\read-consist-sttm-restart-DDL.sql which contains common DDL for all other such tests.
    Particularly, it contains two TRIGGERS (TLOG_WANT and TLOG_DONE) which are used for logging of planned actions and actual
    results against table TEST. These triggers use AUTONOMOUS transactions in order to have ability to see results in any
    outcome of test.

    Detailed description can be found in "read-consist-sttm-restart-on-update-04.fbt", this test is based on the same ideas:
       * initial script add records with ID = 1...12 and does commit;
       * start locker-1 which catch record with ID = 1 that is to be involved futher in cursor of worker;
       * start worker DML which must change records in descending order of ID, starting with ID=2; worker must write ID = ID * 100 for each row;
       * start locker-2 which changes record with ID=12 by assigning this ID to -12, makes COMMIT and locks this record again (makes UPDATE w/o commit);
       * locker-1 releases record with ID=1, then changes record with ID=11 by assigning this ID to -11, makes COMMIT and locks this record again;
       * locker-2 releases record with ID=-12, then changes record with ID=10 by assigning this ID to -10, makes COMMIT and locks this record again;
       * ... and so on, until number of such actions iterations less 10 or 11 (see below) ...

    Each UPDATE that is performed by lockers (starting from ID=11) produces new ID (-11, -10, -9, ...) that was not present in the scope which worker
    could see before this action. This forces worker to make statement-level restart.

    When number of such new IDs is less than 10 then worker must finish its job successfully.
    But if this number if 11 then worker must raise exception (SQLSTATE = 40001 / deadlock / update conflicts) and rollback all changes.

    Test verifies both cases, using loop with TWO iterations (see 'main_iter' below): first for 10 and second to 11 records that are to be updated.
    After each iteration we do queries to the table TEST and to the view V_WORKER_LOG which contains data generated by trigger TLOG_DONE for logging.

    Checked on 4.0.0.2195 SS/CS.
 """,
'min_versions': '4.0',
'versions': [
{
 'firebird_version': '4.0',
 'platform': 'All',
 'init_script':
  """
  """,
 'test_type': 'Python',
 'test_script': 
  """
import os
import sys
import subprocess
from subprocess import Popen
import shutil
from fdb import services
import time

os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password

# How long LOCKER must wait before raise update-conflict error
# (useful for debug in case os some error in this test algorithm):
LOCKER_LOCK_TIMEOUT = 5

##############################
# Temply, for debug obly:
this_fdb=db_conn.database_name
this_dbg=os.path.splitext(this_fdb)[0] + '.4debug.fdb'
##############################

db_conn.close()
fb_home = services.connect(host='localhost').get_home_directory()

#-----------------------------------

def flush_and_close(file_handle):
    # https://docs.python.org/2/library/os.html#os.fsync
    # If you're starting with a Python file object f, 
    # first do f.flush(), and 
    # then do os.fsync(f.fileno()), to ensure that all internal buffers associated with f are written to disk.
    global os
    
    file_handle.flush()
    os.fsync(file_handle.fileno())

    file_handle.close()

#--------------------------------------------

def cleanup( f_names_list ):
    global os
    for i in range(len( f_names_list )):
       if os.path.isfile( f_names_list[i]):
            os.remove( f_names_list[i] )
            if os.path.isfile( f_names_list[i]):
                print('ERROR: can not remove file ' + f_names_list[i])


#--------------------------------------------

sql_init_ddl = os.path.join(context['files_location'],'read-consist-sttm-restart-DDL.sql')

for main_iter in (0,1):

    ###################################################################################
    ###  H O W    M A N Y    R E S T A R T S    W E    W A N T    T O    C H E C K  ###
    ###################################################################################
    ROWS_TO_ADD = 10 + main_iter
    ############################

    f_init_log=open( os.path.join(context['temp_directory'],'read-consist-sttm-restart-DDL.log'), 'w')
    f_init_err=open( ''.join( ( os.path.splitext(f_init_log.name)[0], '.err') ), 'w')

    # RECREATION OF ALL DB OBJECTS:
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    subprocess.call( [fb_home + 'isql', dsn, '-q', '-i', sql_init_ddl], stdout=f_init_log, stderr=f_init_err )
    
    flush_and_close(f_init_log)
    flush_and_close(f_init_err)

    sql_addi='''
        set term ^;
        execute block as
        begin
            rdb$set_context('USER_SESSION', 'WHO', 'INIT_DATA');
        end
        ^
        set term ;^
        insert into test(id, x) select row_number()over(),row_number()over() from rdb$types rows (2 + %(ROWS_TO_ADD)s); -- <<< INITIAL DATA
        commit;
    ''' % locals()

    runProgram('isql', [ dsn, '-q' ], sql_addi)

    locker_tpb = fdb.TPB()
    locker_tpb.lock_timeout = LOCKER_LOCK_TIMEOUT
    locker_tpb.lock_resolution = fdb.isc_tpb_wait

    con_lock_1 = fdb.connect( dsn = dsn, isolation_level=locker_tpb )
    con_lock_2 = fdb.connect( dsn = dsn, isolation_level=locker_tpb )

    con_lock_1.execute_immediate( "execute block as begin rdb$set_context('USER_SESSION', 'WHO', 'LOCKER #1'); end" )
    con_lock_2.execute_immediate( "execute block as begin rdb$set_context('USER_SESSION', 'WHO', 'LOCKER #2'); end" )

    #########################
    ###  L O C K E R - 1  ###
    #########################

    con_lock_1.execute_immediate( 'update test set id=id where id = 1' )

    sql_text='''
        connect '%(dsn)s';
        set list on;
        set autoddl off;
        set term ^;
        execute block returns (whoami varchar(30)) as
        begin
            whoami = 'WORKER'; -- , ATT#' || current_connection;
            rdb$set_context('USER_SESSION','WHO', whoami);
            -- suspend;
        end
        ^
        set term ;^
        commit;
        SET KEEP_TRAN_PARAMS ON;
        set transaction read committed read consistency;
        set list off;
        set wng off;

        set count on;
        update test set id = id * 100 where id <= 2 order by id DESC; -- THIS MUST HANG BECAUSE OF LOCKERs

        -- check results:
        -- ###############

        select id from test order by id;

        select v.old_id, v.op, v.snap_no_rank
        from v_worker_log v
        where v.op = 'upd';


        --set width who 10;
        -- DO NOT check this! Values can differ here from one run to another!
        -- select id, trn, who, old_id, new_id, op, rec_vers, global_cn, snap_no from tlog_done order by id;
        rollback;

    '''  % dict(globals(), **locals())

    f_worker_sql=open( os.path.join(context['temp_directory'],'tmp_sttm_restart_max_limit.sql'), 'w')
    f_worker_sql.write(sql_text)
    flush_and_close(f_worker_sql)


    f_worker_log=open( ''.join( ( os.path.splitext(f_worker_sql.name)[0], '.log') ), 'w')
    f_worker_err=open( ''.join( ( os.path.splitext(f_worker_log.name)[0], '.err') ), 'w')

    ############################################################################
    ###  L A U N C H     W O R K E R    U S I N G     I S Q L,   A S Y N C.  ###
    ############################################################################

    p_worker = Popen( [ fb_home+'isql', '-pag', '9999999', '-q', '-i', f_worker_sql.name ],stdout=f_worker_log, stderr=f_worker_err)
    time.sleep(1)

    cur_lock_1 = con_lock_1.cursor()
    cur_lock_2 = con_lock_2.cursor()
    sttm = 'update test set id = ? where abs( id ) = ?'


    for i in range(0,ROWS_TO_ADD):
        v_id = 2 + ROWS_TO_ADD-i
        if i % 2 == 0:
            cur_lock_2.execute( sttm, ( -abs( v_id ), v_id, ) )
            con_lock_2.commit()
            cur_lock_2.execute( sttm, ( -abs( v_id ), v_id, ) )
            con_lock_1.commit()
        else:
            cur_lock_1.execute( sttm, ( -abs( v_id ), v_id, ) )
            con_lock_1.commit()
            cur_lock_1.execute( sttm, ( -abs( v_id ), v_id, ) )
            con_lock_2.commit()

    cur_lock_1.close()
    cur_lock_2.close()

    if ROWS_TO_ADD % 2 == 0:
        con_lock_2.commit()
        con_lock_1.commit()
    else:
        con_lock_1.commit()
        con_lock_2.commit()

    # Close lockers:
    ################
    for c in (con_lock_1, con_lock_2):
        c.close()

    # Here we wait for ISQL complete its mission:
    p_worker.wait()

    flush_and_close(f_worker_log)
    flush_and_close(f_worker_err)

    # CHECK RESULTS
    ###############
    time.sleep(1)

    print( 'iter=%(main_iter)s, restarts number to be tested: %(ROWS_TO_ADD)s' % locals() )

    with open(f_init_err.name,'r') as f:
        for line in f:
            if line:
                print( 'iter=%(main_iter)s, UNEXPECTED STDERR for initial SQL: %(line)s'  % locals() )
   
    for f in (f_worker_log, f_worker_err):
        with open(f.name,'r') as g:
            for line in g:
                if line:
                    logname = 'STDLOG' if f.name == f_worker_log.name else 'STDERR'
                    print( 'iter=%(main_iter)s, worker %(logname)s: %(line)s'  % locals() )


#< for main_iter in (0,1)

# Cleanup.
##########
f_list = [ i.name for i in (f_init_log, f_init_err, f_worker_sql, f_worker_log, f_worker_err) ]
cleanup( f_list )

#shutil.copy2(this_fdb, this_dbg)

  """,
 'expected_stdout':
  """
    iter=0, restarts number to be tested: 10
    iter=0, worker STDLOG: Records affected: 12
    iter=0, worker STDLOG:
    iter=0, worker STDLOG:      ID
    iter=0, worker STDLOG: =======
    iter=0, worker STDLOG:   -1200
    iter=0, worker STDLOG:   -1100
    iter=0, worker STDLOG:   -1000
    iter=0, worker STDLOG:    -900
    iter=0, worker STDLOG:    -800
    iter=0, worker STDLOG:    -700
    iter=0, worker STDLOG:    -600
    iter=0, worker STDLOG:    -500
    iter=0, worker STDLOG:    -400
    iter=0, worker STDLOG:    -300
    iter=0, worker STDLOG:     100
    iter=0, worker STDLOG:     200
    iter=0, worker STDLOG:
    iter=0, worker STDLOG: Records affected: 12
    iter=0, worker STDLOG:
    iter=0, worker STDLOG:  OLD_ID OP              SNAP_NO_RANK
    iter=0, worker STDLOG: ======= ====== =====================
    iter=0, worker STDLOG:       2 UPD                        1
    iter=0, worker STDLOG:       2 UPD                        2
    iter=0, worker STDLOG:       1 UPD                        2
    iter=0, worker STDLOG:       2 UPD                        3
    iter=0, worker STDLOG:       1 UPD                        3
    iter=0, worker STDLOG:       2 UPD                        4
    iter=0, worker STDLOG:       1 UPD                        4
    iter=0, worker STDLOG:       2 UPD                        5
    iter=0, worker STDLOG:       1 UPD                        5
    iter=0, worker STDLOG:       2 UPD                        6
    iter=0, worker STDLOG:       1 UPD                        6
    iter=0, worker STDLOG:       2 UPD                        7
    iter=0, worker STDLOG:       1 UPD                        7
    iter=0, worker STDLOG:       2 UPD                        8
    iter=0, worker STDLOG:       1 UPD                        8
    iter=0, worker STDLOG:       2 UPD                        9
    iter=0, worker STDLOG:       1 UPD                        9
    iter=0, worker STDLOG:       2 UPD                       10
    iter=0, worker STDLOG:       1 UPD                       10
    iter=0, worker STDLOG:       2 UPD                       11
    iter=0, worker STDLOG:       1 UPD                       11
    iter=0, worker STDLOG:      -3 UPD                       11
    iter=0, worker STDLOG:      -4 UPD                       11
    iter=0, worker STDLOG:      -5 UPD                       11
    iter=0, worker STDLOG:      -6 UPD                       11
    iter=0, worker STDLOG:      -7 UPD                       11
    iter=0, worker STDLOG:      -8 UPD                       11
    iter=0, worker STDLOG:      -9 UPD                       11
    iter=0, worker STDLOG:     -10 UPD                       11
    iter=0, worker STDLOG:     -11 UPD                       11
    iter=0, worker STDLOG:     -12 UPD                       11
    iter=0, worker STDLOG:
    iter=0, worker STDLOG: Records affected: 31


    iter=1, restarts number to be tested: 11
    iter=1, worker STDLOG: Records affected: 2
    iter=1, worker STDLOG:
    iter=1, worker STDLOG:      ID
    iter=1, worker STDLOG: =======
    iter=1, worker STDLOG:     -13
    iter=1, worker STDLOG:     -12
    iter=1, worker STDLOG:     -11
    iter=1, worker STDLOG:     -10
    iter=1, worker STDLOG:      -9
    iter=1, worker STDLOG:      -8
    iter=1, worker STDLOG:      -7
    iter=1, worker STDLOG:      -6
    iter=1, worker STDLOG:      -5
    iter=1, worker STDLOG:      -4
    iter=1, worker STDLOG:      -3
    iter=1, worker STDLOG:       1
    iter=1, worker STDLOG:       2
    iter=1, worker STDLOG:
    iter=1, worker STDLOG: Records affected: 13
    iter=1, worker STDLOG:
    iter=1, worker STDLOG:  OLD_ID OP              SNAP_NO_RANK
    iter=1, worker STDLOG: ======= ====== =====================
    iter=1, worker STDLOG:       2 UPD                        1
    iter=1, worker STDLOG:       2 UPD                        2
    iter=1, worker STDLOG:       1 UPD                        2
    iter=1, worker STDLOG:       2 UPD                        3
    iter=1, worker STDLOG:       1 UPD                        3
    iter=1, worker STDLOG:       2 UPD                        4
    iter=1, worker STDLOG:       1 UPD                        4
    iter=1, worker STDLOG:       2 UPD                        5
    iter=1, worker STDLOG:       1 UPD                        5
    iter=1, worker STDLOG:       2 UPD                        6
    iter=1, worker STDLOG:       1 UPD                        6
    iter=1, worker STDLOG:       2 UPD                        7
    iter=1, worker STDLOG:       1 UPD                        7
    iter=1, worker STDLOG:       2 UPD                        8
    iter=1, worker STDLOG:       1 UPD                        8
    iter=1, worker STDLOG:       2 UPD                        9
    iter=1, worker STDLOG:       1 UPD                        9
    iter=1, worker STDLOG:       2 UPD                       10
    iter=1, worker STDLOG:       1 UPD                       10
    iter=1, worker STDLOG:       2 UPD                       11
    iter=1, worker STDLOG:       1 UPD                       11
    iter=1, worker STDLOG:
    iter=1, worker STDLOG: Records affected: 21
    iter=1, worker STDERR: Statement failed, SQLSTATE = 40001
    iter=1, worker STDERR: deadlock
    iter=1, worker STDERR: -update conflicts with concurrent update
    iter=1, worker STDERR: -concurrent transaction number is 343
  """,
 'expected_stderr':
  """
  """,
  'substitutions':[
      ('=','')
     ,('[ \t]+',' ')
     ,('.*After line \d+.*', '')
     ,('.*[\-]?concurrent transaction number is \d+', 'concurrent transaction number is')
   ]
},
]
}
