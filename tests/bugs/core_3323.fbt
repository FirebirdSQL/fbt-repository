{
'id': 'bugs.core_3323',
'qmid': None,
'tracker_id': 'CORE-3323',
'title': 'Ability to cancel waiting in lock manager',
'description': 
 """
    Fully reimplemented 10.01.2020. Reason: ISQL-"killer" could not find record in mon$attachments that should be deleted.

    Test asynchronously launches ISQL with script that will hang because of two concurrent attachments trying to update
    the same record (second attachment is created using ES/EDS).
    After this we have to launch second instance of ISQL which will attempt to kill both connections created in the 1st ISQL.

    The *most* problem here is properly determine time that we have to wait until 1st ISQL will really establish its connect!
    If this time is too short then second ISQL ("killer") will NOT able to see 1st ISQL in mon$attachments and will not be able
    to delete (because there will be NOT YET attachment to delete!). This mean that 2nd ISQL will finish without really check
    that it could kill hanged attachments. Test in this case will not finish if 1st ISQL uses tx with infinite WAIT!

    To be sure that 2nd ISQL ("killer") will be able to see 1st one ("hanged") we have to make pretty long PSQL-loop which tries
    to find any record in mon$attachment that is from concurrent connection (which user name we know for advance: 'tmp$c3323').
    This PSQL loop must finish as fast as we find record that will be then deleted.

    Lot of runs show that there is a problem in 4.0.0 Classic: it requires too long time in PSQL loop to find such attachment.
    Time in 4.0 CS can be about 1-2 seconds and number of iterations will be greater than 100.
    No such problem in all 3.0 and in 4.0 for other modes.

    Checked on:
        4.0.0.1715 SS: 5.292s.
        4.0.0.1714 SC: 9.977s.
        4.0.0.1714 CS: 14.487s.
        3.0.5.33221 SS: 2.126s.
        3.0.5.33221 SC: 4.541s.
        3.0.5.33221 CS: 8.263s.
        2.5.9.27119 SS: 3.391s.
        2.5.9.27149 SC: 0.701s.

 """,
'min_versions': '2.5.1',
'versions': [
{
 'firebird_version': '2.5',
 'platform': 'All',
 'init_script': 
  """
  """,
 'test_type': 'Python',
 'test_script':"""\
import os
import subprocess
from subprocess import Popen
import time

os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password

clear_ext_pool_statement=''
usr_plugin_clause=''

if db_conn.engine_version >= 4.0:
    clear_ext_pool_statement = 'ALTER EXTERNAL CONNECTIONS POOL CLEAR ALL;'

if db_conn.engine_version >= 3.0:
    # usr_plugin_clause='using plugin Legacy_userManager'
    usr_plugin_clause='using plugin Srp'

db_conn.close()


init_ddl='''
    set term ^;
    execute block as
    begin
        begin
            execute statement 'drop user tmp$c3323 %(usr_plugin_clause)s' with autonomous transaction;
            when any do begin end
        end
    end^
    set term ;^
    commit;

    create user tmp$c3323 password '456' %(usr_plugin_clause)s;
    commit;

    recreate table test(id int);
    commit;
    insert into test values(1);
    commit;

    grant select,update on test to tmp$c3323;
    commit;
''' % locals()

runProgram('isql', [dsn], init_ddl)


lock_sql='''
    set list on;
    commit;
    set transaction wait;

    update test set id = -id;
    select 'starting EB with lock-conflict' as "Point_A:" --------------  p o i n t   [ A ]
          ,id as "id_at_point_A:"
    from test; 

    set term ^;
    execute block as
    begin
        -- This statement will for sure finish with exception, but
        -- in 2.5.0 it will be 'lock-conflict' (and this was WRONG),
        -- while on 2.5.1 and above it should be 'connection shutdown'.

        -- 11.05.2017, FB 4.0 only!
        -- Following messages can appear after 'connection shutdown'
        -- (letter from dimitr, 08-may-2017 20:41):
        --   isc_att_shut_killed: Killed by database administrator
        --   isc_att_shut_idle: Idle timeout expired
        --   isc_att_shut_db_down: Database is shutdown
        --   isc_att_shut_engine: Engine is shutdown

        execute statement 'update test set id = - (1000 + id)'
            on external 'localhost:' || rdb$get_context('SYSTEM','DB_NAME')
            as user 'TMP$C3323' password '456';
    end
    ^
    set term ;^

    select 'finished EB with lock-conflict' as "Point_B" --------------  p o i n t   [ B ]
          ,id as "id_at_point_B:"
    from test; 
    rollback;
'''

hang_sql=open( os.path.join(context['temp_directory'],'tmp_3323_hang.sql'), 'w')
hang_sql.write(lock_sql)
hang_sql.close()

hang_log=open( os.path.join(context['temp_directory'],'tmp_3323_hang.log'), "w", buffering = 0)

# Execute a child program in a new process, redirecting STDERR to the same target as of STDOUT:
p_hang = Popen(["isql", dsn, "-c", '96', "-i" , hang_sql.name],stdout=hang_log, stderr=subprocess.STDOUT)

#time.sleep(3) # do NOT reduce this delay because this async invocation may be too slow and next ISQL call will NOT see attachment to be killed!

usr=user_name
pwd=user_password
script='''
    set list on;

    select 'Intro script that must kill other attachment' as "point_C:" ------------------  p o i n t   [ C ]
    from test; 

    /****************
        -- Does not help, at least with 'lock timeout 1' !!
        -- "Killer" attachment can still NOT see other attach (which must be killed) - this occurs on 4.0 Cs only. 10.01.2020
        commit;
        set transaction lock timeout 1;
        set term ^;
        execute block as
        begin
            update test set id = - (2000 + id);
            when any do begin end
        end
        ^
        set term ;^
        rollback;
    *****************/


    set term ^;
    execute block returns( found_other_attach_for_attempts int, found_other_attach_for_ms int ) as
        declare c smallint = 0;
        declare t timestamp;
    begin
        found_other_attach_for_attempts = 0;
        t = 'now';
        while (c = 0) do
        begin
            found_other_attach_for_attempts = found_other_attach_for_attempts + 1;
            in autonomous transaction do
                select count(*) 
                from (
                    select mon$attachment_id 
                    from mon$attachments a
                    where mon$user = upper('TMP$C3323' )
                    rows 1
                )
                into c;
            found_other_attach_for_ms = datediff(millisecond from t to cast('now' as timestamp));
            if (found_other_attach_for_ms > 5000) then
            begin
                suspend;
                leave;
            end
        end
    end
    ^
    set term ;^
    rollback;


    select 'starting kill hanged connection' as "point_D:" ------------------  p o i n t   [ D ]
          ,id as "id_at_point_D:"
    from test; 

    select iif( a.mon$attachment_id is not null, '<EXPECTED: NOT NULL>', '### UNEXPECTED: NULL ###' ) as attachment_to_be_killed
    from rdb$database
    left join mon$attachments a on mon$user = upper('TMP$C3323' ) 
    ;

    select 'Running delete from mon$attachments statement'  as "point_E:" ------------------  p o i n t   [ E ]
    from rdb$database;

    set count on;
    delete from mon$attachments
    where mon$user = upper('TMP$C3323' ) 
    -- returning iif( mon$attachment_id is not null, '<EXPECTED: NOT NULL>', '### UNEXPECTED NULL ###' ) as killed_attachment_id
    ;
    set count off;
    commit;

    connect '$(DSN)' user '%(usr)s' password '%(pwd)s';

    %(clear_ext_pool_statement)s

    select 'Reconnect and look for attachment of other user' as "point_F:" ------------------  p o i n t   [ F ]
          ,id as "id_at_point_F:"
    from test; 

    select iif( a.mon$attachment_id is null, '<EXPECTED: NULL>', '### UNEXPECTED NOT NULL: attach_id=' || a.mon$attachment_id || '; state=' || coalesce(a.mon$state, '<null>') || ' ###' ) as still_alive_attachment_id
    from rdb$database r
    left join mon$attachments a on a.mon$user = upper('TMP$C3323');
    commit;

    set blob all;

    --select a.mon$attachment_id, s.*
    select a.*, s.*
    from mon$attachments a left join mon$statements s using(mon$attachment_id)
    where a.mon$user = upper('TMP$C3323')
    ;

    select 'finished kill hanged connection' as "pointG:"  -----------------  p o i n t   [ G ]
    from rdb$database; 
    commit;

    drop user tmp$c3323 %(usr_plugin_clause)s;
    commit;

''' % locals()


kill_sql=open( os.path.join(context['temp_directory'],'tmp_3323_kill.sql'), 'w')
kill_sql.write(script)
kill_sql.close()

kill_log=open( os.path.join(context['temp_directory'],'tmp_3323_kill.log'), "w", buffering = 0)

subprocess.call( ["isql", dsn, "-c", '96', "-ch", "utf8", "-i" , kill_sql.name],stdout=kill_log, stderr=subprocess.STDOUT )

## Execute a child program in a new process, redirecting STDERR to the same target as of STDOUT:
#p_kill = Popen(["isql", dsn, "-ch", "utf8", "-i" , kill_sql.name],stdout=kill_log, stderr=subprocess.STDOUT)
## Make delay at least on 6 seconds after that point.
## Otherwise temp database will not be removed and we get:
## Exception AttributeError: "'Connection' object has no attribute '_Connection__ic'"
## in <bound method Connection.__del__ of <fdb.fbcore.Connection object at 0x023E4850>> ignored
## Test cleanup: Exception raised while dropping database.
#time.sleep(3)
#p_kill.terminate()

kill_log.close()

p_hang.terminate()
hang_log.close()


with open( hang_log.name,'r') as f:
    print(f.read())
f.close()

with open( kill_log.name,'r') as f:
    print(f.read())
f.close()

# We have to change DB state to full shutdown and bring it back online
# in order to prevent "Object in use" while fbtest will try to drop this DB
#####################################
runProgram('gfix',[dsn,'-shut','full','-force','0'])
runProgram('gfix',[dsn,'-online'])

# CLEANUP
#########
f_list=(hang_sql,kill_sql,kill_log,hang_log)

for i in range(len(f_list)):
   if os.path.isfile(f_list[i].name):
       os.remove(f_list[i].name)
       #pass


  """,
 'expected_stdout':
  """
    Point_A:                        starting EB with lock-conflict
    id_at_point_A:                  -1
    Statement failed, SQLSTATE = 42000
    Execute statement error at isc_dsql_execute2 :
    335544856 : connection shutdown
    Statement : update test set id = - (1000 + id)
    Data source : Firebird::localhost
    -At block line
    Point_B                         finished EB with lock-conflict
    id_at_point_B:                  -1
    point_C:                        Intro script that must kill other attachment
    point_D:                        starting kill hanged connection
    id_at_point_D:                  1
    ATTACHMENT_TO_BE_KILLED         <EXPECTED: NOT NULL>
    point_E:                        Running delete from mon$attachments statement
    Records affected: 1
    point_F:                        Reconnect and look for attachment of other user
    id_at_point_F:                  1
    STILL_ALIVE_ATTACHMENT_ID       <EXPECTED: NULL>
    pointG:                         finished kill hanged connection
  """,
 'expected_stderr':
  """
  """,
 'substitutions':[
    ('Data source : Firebird::localhost:.*','Data source : Firebird::localhost'),
    ('After line.*', ''),
    ('.*Killed by database administrator.*', ''),
    ('-At block line:.*', '-At block line'),
    ('Execute statement error at isc_dsql_(execute2|prepare)','Execute statement error at isc_dsql')
  ]

}
]
}
