{
'id': 'bugs.core_2408',
'qmid': None,
'tracker_id': 'CORE-2408',
'title': 'isql -ex puts default values of sp parameters before the NOT NULL and COLLATE flags',
'description': 
 """
   Quote from ticket: "make a procedure with NOT NULL and/or COLLATE flags *and* a default value on any parameter".
   Test enchances this by checking not only procedure but also function and package.
   Also, check is performed for table (I've encountered the same for TABLES definition in some old databases).

   Algorithm is similar to test for core-5089: we create several DB objects which do have properties from ticket.
   Then we extract metadata and save it into file as 'initial' text.
   After this we drop all objects and make attempt to APPLY just extracted metadata script. It should perform without errors.
   Finally, we extract metadata again and do COMPARISON of their current content and those which are stored 'initial' file.

   Checked on:  WI-V3.0.0.32328 (SS/CS/SC).
 """,
'min_versions': '3.0',
'versions': [
{
 'firebird_version': '3.0',
 'platform': 'All',
 'database_character_set': 'UTF8',
 'connection_character_set': 'UTF8',
 'init_script':
  """
    set bail on;
    set autoddl off;
    commit;

    create collation nums_coll for utf8 from unicode case insensitive 'NUMERIC-SORT=1';
    create collation name_coll for utf8 from unicode no pad case insensitive accent insensitive;

    create domain dm_test varchar(20) character set utf8 default 'foo' not null collate nums_coll;

    create table test(
        s1 varchar(20) character set utf8 default 'foo' not null collate nums_coll
       ,s2 dm_test
       ,s3 dm_test default 'bar'
       ,s4 dm_test default 'rio' collate name_coll
    );

    set term ^;
    create or alter procedure sp_test(
        p1 varchar(20) character set utf8 not null collate nums_coll default 'foo'
       ,p2 dm_test default 'qwe'
       ,p3 dm_test default 'bar'
       ,p4 dm_test collate name_coll default 'rio'
    ) returns (
        o1 varchar(80)
       ,o2 dm_test collate name_coll
    )
    as
    begin
      o1 = lower(p1 || p2 || p3);
      o2 = upper(p4);
      suspend;
    end
    ^
    
    create or alter function fn_test(
        p1 varchar(20) character set utf8 not null collate nums_coll default 'foo'
       ,p2 dm_test default 'qwe'
       ,p3 dm_test default 'bar'
       ,p4 dm_test collate name_coll default 'rio'
    ) returns dm_test collate name_coll
    as
    begin
      return lower(left(p1,5) || left(p2,5) || left(p3,5) || left(p4,5));
    end
    ^

    recreate package pg_test as
    begin
        procedure pg_proc(
            p1 varchar(20) character set utf8 not null collate nums_coll default 'foo'
           ,p2 dm_test default 'qwe'
           ,p3 dm_test default 'bar'
           ,p4 dm_test collate name_coll default 'rio'
        ) returns (
            o1 varchar(80)
           ,o2 dm_test collate name_coll
        );
        function pg_func(
            p1 varchar(20) character set utf8 not null collate nums_coll default 'foo'
           ,p2 dm_test default 'qwe'
           ,p3 dm_test default 'bar'
           ,p4 dm_test collate name_coll default 'rio'
        ) returns dm_test collate name_coll;
    end
    ^

    create package body pg_test as
    begin
        procedure pg_proc(
            p1 varchar(20) character set utf8 not null collate nums_coll
           ,p2 dm_test
           ,p3 dm_test
           ,p4 dm_test collate name_coll
        ) returns (
            o1 varchar(80)
           ,o2 dm_test collate name_coll
        ) as
        begin
            o1 = lower(p1 || p2 || p3);
            o2 = upper(p4);
            suspend;
        end

        function pg_func(
            p1 varchar(20) character set utf8 not null collate nums_coll
           ,p2 dm_test
           ,p3 dm_test
           ,p4 dm_test collate name_coll
        ) returns dm_test collate name_coll as
        begin
            return lower(left(p1,5) || left(p2,5) || left(p3,5) || left(p4,5));
        end
    end
    ^
    set term ;^
    commit;
  """,
 'test_type': 'Python',
 'test_script': 
  """\
import os
import subprocess
import difflib

db_conn.close()

os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password
db_file="$(DATABASE_LOCATION)bugs.core_2408.fdb"

f_extract_initial_meta_sql = open( os.path.join(context['temp_directory'],'tmp_meta_2408_init.sql'), 'w')
subprocess.call( ["isql", dsn, "-x", "-ch", "utf8"], \
                 stdout = f_extract_initial_meta_sql, \
                 stderr = subprocess.STDOUT \
               )
f_extract_initial_meta_sql.close()

ddl_clear_all='''
    drop package pg_test;
    drop function fn_test;
    drop procedure sp_test;
    drop table test;
    drop domain dm_test;
    drop collation name_coll;
    drop collation nums_coll;
    commit;
'''

f_meta_drop_all_sql = open( os.path.join(context['temp_directory'],'tmp_meta_2408_drop_all.sql'), 'w')
f_meta_drop_all_sql.write(ddl_clear_all)
f_meta_drop_all_sql.close()

f_meta_drop_all_log = open( os.path.join(context['temp_directory'],'tmp_meta_2408_drop_all.log'), 'w')
subprocess.call( ["isql", dsn, "-i", f_meta_drop_all_sql.name, "-ch", "utf8" ], \
                 stdout = f_meta_drop_all_log, \
                 stderr = subprocess.STDOUT \
               )
f_meta_drop_all_log.close()


f_apply_extracted_meta_log = open( os.path.join(context['temp_directory'],'tmp_meta_2408_apply.log'), 'w')
subprocess.call( ["isql", dsn, "-i", f_extract_initial_meta_sql.name, "-ch", "utf8" ], \
                 stdout = f_apply_extracted_meta_log, \
                 stderr = subprocess.STDOUT \
               )
f_apply_extracted_meta_log.close()

f_extract_current_meta_sql = open( os.path.join(context['temp_directory'],'tmp_meta_2408_last.sql'), 'w')
subprocess.call( ["isql", dsn, "-x", "-ch", "utf8"], \
                 stdout = f_extract_current_meta_sql, \
                 stderr = subprocess.STDOUT \
               )
f_extract_current_meta_sql.close()


f_diff_txt=open( os.path.join(context['temp_directory'],'tmp_2408_meta_diff.txt'), 'w')

f_old=[]
f_new=[]

f_old.append(f_extract_initial_meta_sql) # tmp_meta_2408_init.sql -- extracted metadata just after 'init_script' was done
f_new.append(f_extract_current_meta_sql) # tmp_meta_2408_last.sql -- extracted metadata after drop all object and applying 'tmp_meta_2408_init.sql'

for i in range(len(f_old)):
    old_file=open(f_old[i].name,'r')
    new_file=open(f_new[i].name,'r')
    
    f_diff_txt.write( ''.join( difflib.unified_diff( old_file.readlines(), new_file.readlines() ) ) )

    old_file.close()
    new_file.close()

f_diff_txt.close()


# Should be EMPTY:
##################
with open( f_meta_drop_all_log.name, 'r') as f:
    for line in f:
        print( 'Error log of dropping existing objects: ' + f.line() )
f.close()

# Should be EMPTY:
##################
with open( f_apply_extracted_meta_log.name, 'r') as f:
    for line in f:
        print( 'Error log of applying extracted metadata: ' + f.line() )
f.close()

# Should be EMPTY:
##################
with open( f_diff_txt.name,'r') as f:
    for line in f:
            print( ' '.join(line.split()).upper() )
f.close()


###############################
# Cleanup.

f_list=[]
f_list.append(f_extract_initial_meta_sql)
f_list.append(f_extract_current_meta_sql)
f_list.append(f_meta_drop_all_sql)
f_list.append(f_meta_drop_all_log)
f_list.append(f_apply_extracted_meta_log)
f_list.append(f_diff_txt)

for i in range(len(f_list)):
    if os.path.isfile(f_list[i].name):
        os.remove(f_list[i].name)

  """,
 'expected_stdout':
  """
  """,
 'expected_stderr':
  """
  """
}
]
}
