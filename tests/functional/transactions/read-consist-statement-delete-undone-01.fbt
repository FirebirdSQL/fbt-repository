{
'id': 'functional.transactions.read-consist-statement-delete-undone-01',
'qmid': '',
'tracker_id': '',
'title': "READ CONSISTENCY. DELETE statement results must be UNDONE on requirement that appears after this statement start. Test-01",
'description': 
 """
    Initial article for reading:
        https://asktom.oracle.com/pls/asktom/f?p=100:11:::::P11_QUESTION_ID:11504247549852
        Note on terms which are used there: "BLOCKER", "LONG" and "FIRSTLAST" - their names are slightly changed here
        to: LOCKER-1, WORKER and LOCKER-2 respectively.
    See also: doc\README.read_consistency.md

    **********************************************

    ::: NB :::
    This test uses script %FBT_REPO%\files\read-consist-sttm-restart-DDL.sql which contains common DDL for all other such tests.
    Particularly, it contains two TRIGGERS (TLOG_WANT and TLOG_DONE) which are used for logging of planned actions and actual
    results against table TEST. These triggers launched AUTONOMOUS transactions in order to have ability to see results in any
    outcome of test.

    ###############
    Following scenario if executed here:
    * five rows are inserted into the table TEST, with IDs: 1...5.

    * session 'locker-1' ("BLOCKER" in Tom Kyte's article ): issues 'update test set id = id where id=1'.

    * session 'worker' ("LONG" in TK article) has mission:
        delete from test where not exists(select * from test where id >= 10) order by id desc; // within Tx with TIL = read committed read consistency
        Execution will have PLAN ORDER <DESCENDING_INDEX>.
        It will delete rows starting with ID = 5 and down to ID = 2, but hang on row with ID = 1 because of locker-1;

    * session 'locker-2' ("FIRSTLAST" in TK article): inserts row with ID = 6 then issues 'commit' and re-lock this row again (update ... where id = 6).
       This will made this row visible to session-worker when it will resume its DML. 

    * session 'locker-1': commit (and allows lead session-worker to delete row with ID = 1).
       At this point session-WORKER will:
       ** set write-lock on row with ID=1 (but worker does  *not* update it yet! It only set write-lock);
       ** tries to find all other rows in the set which is produced by query - but no more records can be found now;
       ** makes UNDO of deletions which it did before (i.e. for records with ID 5...2) - but remain these recors be locked;
       ** start query again - and now it is waiting for record with ID=8

       Then locker-1 inserts row with ID = 7, issues 'commit' (second time) and re-lock this row again (update ... where id = 7).
       This will made this row visible to session-worker when it will resume its DML. 
    
    * session 'locker-2': commit (this allows session-worker to delete row with ID = 6).
       Then locker-2 inserts row with ID = 8, issues 'commit' (second time) and re-lock this row again (update ... where id = 8).
       This will made this row visible to session-worker when it will resume its DML. 
    
    * session 'locker-1': commit (this allows session-worker to delete row with ID = 7).
       Then locker-1 inserts row with ID = 9, issues 'commit' (second time) and re-lock this row again (update ... where id = 9).
       This will made this ro visible to session-worker when it will restart its DML. 

    * session 'locker-2': commit (this allows session-worker to delete row with ID = 6).
       Then locker-2 inserts row with ID = 10, issues 'commit' (second time) and re-lock this row again (update ... where id = 10).
       This will made this row visible to session-worker when it will resume its DML. 
       NOTE: this record will cause session-worker immediately UNDO all changes that it was performed before - see "WHERE NOT EXISTS(...)" in its DML expression.


    Expected result:
    * session-'worker' must be cancelled. No rows must be deleted, PLUS new rows must remain (with ID = 6 ... 10).
    * we must NOT see any restart witnesses because statement no rows actually were affected by session-worker statement.

    ################

    Additional comments for this case - see letter from Vlad, 05-aug-2020 00:51.
    
    Checked on 4.0.0.2126
 """,
'min_versions': '4.0',
'versions': [
{
 'firebird_version': '4.0',
 'platform': 'All',
 'init_script':
  """
  """,
 'test_type': 'Python',
 'test_script': 
  """
import os
import sys
import subprocess
from subprocess import Popen
import re
import difflib
from fdb import services
import time

os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password

db_conn.close()
fb_home = services.connect(host='localhost').get_home_directory()

#-----------------------------------

def flush_and_close(file_handle):
    # https://docs.python.org/2/library/os.html#os.fsync
    # If you're starting with a Python file object f, 
    # first do f.flush(), and 
    # then do os.fsync(f.fileno()), to ensure that all internal buffers associated with f are written to disk.
    global os
    
    file_handle.flush()
    os.fsync(file_handle.fileno())

    file_handle.close()

#--------------------------------------------

def cleanup( f_names_list ):
    global os
    for i in range(len( f_names_list )):
       if os.path.isfile( f_names_list[i]):
            os.remove( f_names_list[i] )
            if os.path.isfile( f_names_list[i]):
                print('ERROR: can not remove file ' + f_names_list[i])


#--------------------------------------------

sql_init_ddl = os.path.join(context['files_location'],'read-consist-sttm-restart-DDL.sql')

f_init_log=open( os.path.join(context['temp_directory'],'read-consist-sttm-restart-DDL.log'), 'w')
f_init_err=open( ''.join( ( os.path.splitext(f_init_log.name)[0], '.err') ), 'w')

subprocess.call( [fb_home + 'isql', dsn, '-q', '-i', sql_init_ddl], stdout=f_init_log, stderr=f_init_err )
flush_and_close(f_init_log)
flush_and_close(f_init_err)

sql_addi='''insert into test(id, x) select row_number()over(),row_number()over() from rdb$types rows 5;'''
runProgram('isql', [ dsn, '-q' ], sql_addi)


con_lock_1 = fdb.connect( dsn = dsn )
con_lock_2 = fdb.connect( dsn = dsn )


#########################
###  L O C K E R - 1  ###
#########################

con_lock_1.execute_immediate( 'update test set id=id where id = 1' )

sql_text='''
    connect '%(dsn)s';
    set list on;
    set autoddl off;
    set term ^;
    execute block returns (whoami varchar(30)) as
    begin
        whoami = 'WORKER'; -- , ATT#' || current_connection;
        rdb$set_context('USER_SESSION','WHO', whoami);
        -- suspend;
    end
    ^
    set term ;^
    commit;
    SET KEEP_TRAN_PARAMS ON;
    set transaction read committed read consistency;
    --select current_connection, current_transaction from rdb$database;
    set list off;
    set wng off;
    --set plan on;
    set count on;

    delete from test where not exists(select * from test where id >= 10) order by id desc; -- THIS MUST BE LOCKED

    -- check results:
    -- ###############

    select id from test; -- this will produce output only after all lockers do their commit/rollback

    -- select * from v_worker_log v where upper(v.op) = upper('del');

    /*
    Expected result here:
    OLD_ID       NEW_ID OP         REC_VERS      SNAP_NO
    ====== ============ ====== ============ ============
         5       <null> DEL              34            5
         4       <null> DEL              34            5
         3       <null> DEL              34            5
         2       <null> DEL              34            5
    */

    -- /*
    select d.op ,count(distinct d.snap_no) as statement_snapshots_count, count(distinct d.rec_vers) rec_vers_count
    from tlog_done d
    where d.who starting with upper('worker') and d.op=upper('del')
    group by d.op;
    --*/

'''  % dict(globals(), **locals())

f_worker_sql=open( os.path.join(context['temp_directory'],'tmp_read_consist_statement_undone_delete_01.sql'), 'w')
f_worker_sql.write(sql_text)
flush_and_close(f_worker_sql)


f_worker_log=open( ''.join( ( os.path.splitext(f_worker_sql.name)[0], '.log') ), 'w')
f_worker_err=open( ''.join( ( os.path.splitext(f_worker_log.name)[0], '.err') ), 'w')

############################################################################
###  L A U N C H     W O R K E R    U S I N G     I S Q L,   A S Y N C.  ###
############################################################################

p_worker = Popen( [ fb_home+'isql', '-q', '-i', f_worker_sql.name ],stdout=f_worker_log, stderr=f_worker_err)
time.sleep(1)


#########################
###  L O C K E R - 2  ###
#########################

# Add record so that it **will* be included in the set of rows that must be affected by session-worker:
con_lock_2.execute_immediate( 'insert into test(id, x) values(6, 6);' )
con_lock_2.commit()
con_lock_2.execute_immediate( 'update test set id = id where id = 6;' )

con_lock_1.commit() # releases record with ID=1 (allow it to be deleted by session-worker)

# Add record so that it **will* be included in the set of rows that must be affected by session-worker:
con_lock_1.execute_immediate( 'insert into test(id, x) values(7, 7);' )
con_lock_1.commit()
con_lock_1.execute_immediate( 'update test set id = id where id = 7;' )


con_lock_2.commit() # releases record with ID = 6, but session-worker is waiting for record with ID = 7 (that was added by locker-1).

con_lock_2.execute_immediate( 'insert into test(id, x) values(8, 8);' )
con_lock_2.commit()
con_lock_2.execute_immediate( 'update test set id = id where id = 8;' )


con_lock_1.commit() # releases record with ID = 7, but session-worker is waiting for record with ID = 8 (that was added by locker-2).

con_lock_1.execute_immediate( 'insert into test(id, x) values(9, 9);' )
con_lock_1.commit()
con_lock_1.execute_immediate( 'update test set id = id where id = 9;' )


con_lock_2.commit() # releases record with ID = 8, but session-worker is waiting for record with ID = 9 (that was added by locker-1).

con_lock_2.execute_immediate( 'insert into test(id, x) values(10, 10);' )
con_lock_2.commit()
con_lock_2.execute_immediate( 'update test set id = id where id = 10;' )
         

con_lock_1.commit() # <<< THIS MUST CANCEL ALL PERFORMED DELETIONS OF SESSION-WORKER
con_lock_2.commit()


# Let ISQL finishes output to its log.
# ::: NB ::: do NOT reduce this delay less than two seconds otherwise
# ISQL log can remain empty and test will be considered as failed.
time.sleep(2)

p_worker.terminate()

flush_and_close(f_worker_log)
flush_and_close(f_worker_err)

# Close lockers:
################
for c in (con_lock_1, con_lock_2):
    c.close()


# CHECK RESULTS
###############

for f in (f_init_err, f_worker_err):
    with open(f.name,'r') as g:
        for line in g:
            if line:
                print( 'UNEXPECTED STDERR IN ' + g.name + ':' +  line)

with open(f_worker_log.name,'r') as f:
    for line in f:
        print(line)

time.sleep(1)

# Cleanup.
##########
f_list = [ i.name for i in (f_init_log, f_init_err, f_worker_sql, f_worker_log, f_worker_err) ]
cleanup( f_list )


  """,
 'expected_stdout':
  """
    Records affected: 0

              ID 
    ============ 
               1 
               2 
               3 
               4 
               5 
               6 
               7 
               8 
               9 
              10 

    Records affected: 10


    OP     STATEMENT_SNAPSHOTS_COUNT        REC_VERS_COUNT 
    ====== ========================= ===================== 
    DEL                            1                     1 

    Records affected: 1

  """,
 'expected_stderr':
  """
  """,
  'substitutions':[('=',''), ('[ \t]+',' ')]
},
]
}
