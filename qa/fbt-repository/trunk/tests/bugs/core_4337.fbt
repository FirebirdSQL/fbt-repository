{
'id': 'bugs.core_4337',
'qmid': None,
'tracker_id': 'CORE-4337',
'title': 'gfix -sweep makes "reconnect" when it is removed from mon$attachments by delete command (issued in another window)',
'description': 
 """
   We create table with very long char field and fill it with uuid data. 
   Then we create index for this field and finally - delete all rows.
   Such table will require valuable time to be swept, about 4 seconds.

   After this, we launch asynchronously ISQL which makes delay ~2 seconds inside itself.
   Also, we launch trace for logging.

   After this we run 'gfix -sweep' in another process (synchronously).
   When delay in ISQL expires, ISQL connection executes 'DELETE FROM MON$ATTACHMENT' command 
   which should kill gfix connection. This command is issued with 'set count on' for additional 
   check that isql really could find this record in momn$attachments table. 

   Process of GFIX should raise error 'connection shutdown'.
   Trace log should contain line with text 'SWEEP_FAILED' and after this line we should NOT
   discover any lines with 'ATTACH_DATABASE' event - this is especially verified.

   Finally, we compare content of firebird.log: new lines in it should contain messages about 
   interrupted sweep ('error during sweep' and 'connection shutdown').

   Checked on WI-V3.0.2.32620 (SS/SC/CS), 4.0.0.420 (SS/SC).
   Total time of test run is ~25 seconds (data filling occupies about 3 seconds).
 """,
'min_versions': '3.0',
'versions': [
{
 'firebird_version': '3.0',
 'platform': 'All',
 'page_size': '16384',
 'test_type': 'Python',
 'test_script': 
  """\
import os
import time
import subprocess
from subprocess import Popen
import difflib
import re

def svc_get_fb_log( engine, f_fb_log ):

  import subprocess

  if engine.startswith('2.5'):
      get_firebird_log_key='action_get_ib_log'
  else:
      get_firebird_log_key='action_get_fb_log'

  subprocess.call([ "fbsvcmgr",
                    "localhost:service_mgr",
                    get_firebird_log_key
                  ],
                   stdout=f_fb_log, stderr=subprocess.STDOUT
                 )
  return

cur1 = db_conn.cursor()
cur1.execute("select rdb$get_context('SYSTEM','ENGINE_VERSION') as engine_version from rdb$database")
for row in cur1:
    engine = row[0]

db_conn.close()

os.environ["ISC_USER"] = user_name
os.environ["ISC_PASSWORD"] = user_password


db_file="$(DATABASE_LOCATION)bugs.core_4337.fdb"

# Change FW to OFF in order to speed up initial data filling:
##################

fn_nul = open(os.devnull, 'w')
subprocess.call([ "fbsvcmgr", "localhost:service_mgr",
                  "action_properties", "prp_write_mode", "prp_wm_async",
                  "dbname", db_file ],
                  stdout = fn_nul,
                  stderr = subprocess.STDOUT
               )
fn_nul.close()

f_work_sql=open( os.path.join(context['temp_directory'],'tmp_work_4337.sql'), 'w')

sql_dml='''
    set list on;
    select current_time from rdb$database;
    recreate table t(s01 varchar(4000));
    commit;
    set term ^;
    execute block as
    declare n int = 15000;
    begin
    while (n>0) do
        insert into t(s01) values( rpad('',4000,uuid_to_char(gen_uuid())) ) returning :n-1 into n;
    end^
    set term ;^
    commit;
    create index t_s01 on t(s01);
    commit;
    delete from t;
    commit;
    -- overall time for data filling , create index and delete all rows: ~ 3 seconds.
    -- This database requires about 4 seconds to be swept (checked on P-IV 3.0 GHz).
    select current_time from rdb$database;
    --show database;
    quit;
'''
f_work_sql.write(sql_dml)
f_work_sql.close()

f_work_log=open( os.path.join(context['temp_directory'],'tmp_work_4337.log'), 'w')

subprocess.call( ["isql", dsn, "-i", f_work_sql.name],
                  stdout = f_work_log,
                  stderr = subprocess.STDOUT
                )

f_work_log.close()

# REDUCE number of cache buffers in DB header in order to sweep make its work as long as possible
################################
'''

temply disabled, see CORE-5385:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

fn_nul = open(os.devnull, 'w')
subprocess.call([ "fbsvcmgr", "localhost:service_mgr",
                  "action_properties", "prp_page_buffers", "100",
                  "dbname", db_file ],
                  stdout = fn_nul,
                  stderr = subprocess.STDOUT
               )
fn_nul.close()
'''


f_fblog_before=open( os.path.join(context['temp_directory'],'tmp_4337_fblog_before.txt'), 'w')
svc_get_fb_log( engine, f_fblog_before )
f_fblog_before.close()


trc30_cfg = '''# Trace config, format for 3.0. Generated auto, do not edit!
database=%[\\\\\\\\/]bugs.core_4337.fdb
{
  enabled = true
  log_sweep = true
  log_errors = true
  log_connections = true
}
services {
  enabled = false
  log_services = true
  log_service_query = true
}
'''

f_trccfg=open( os.path.join(context['temp_directory'],'tmp_trace_4337.cfg'), 'w')
f_trccfg.write(trc30_cfg)
f_trccfg.close()

# Starting trace session in new child process (async.):
#######################################################

f_trclog=open( os.path.join(context['temp_directory'],'tmp_trace_4337.log'), 'w')
f_trcerr=open( os.path.join(context['temp_directory'],'tmp_trace_4337.err'), 'w')

p_trace=Popen(["fbsvcmgr", "localhost:service_mgr",
               "action_trace_start",
                "trc_cfg", f_trccfg.name],
                stdout=f_trclog, 
                stderr=f_trcerr
             )

# Wait! Trace session is initialized not instantly!
time.sleep(1)


# Launch (async.) ISQL which will make small delay and then kill GFIX attachment:
######################

sql_mon='''
    set list on;

    recreate table tmp4wait(id int);
    commit;
    insert into tmp4wait(id) values(1);
    commit;

    set transaction lock timeout 2; ------------------  D E L A Y
    update tmp4wait set id=id;
    select 'Waiting for GFIX start SWEEP' as " " from rdb$database;
    set term ^;
    execute block as
    begin
       in autonomous transaction do
       begin
           update tmp4wait set id=id;
           when any do 
           begin 
              -- NOP --
           end
       end
    end
    ^
    set term ;^
    commit;
    --select MON$PAGE_BUFFERS from mon$database;
    select 'Starting to delete GFIX process from mon$attachments' as " " from rdb$database;
    set count on;
    delete from mon$attachments
    where mon$remote_process containing 'gfix'
    ;
    commit;
    set count off;
    select 'Finished deleting GFIX process from mon$attachments' as " " from rdb$database;
'''

f_wait_sql=open( os.path.join(context['temp_directory'],'tmp_wait_4337.sql'), 'w')
f_wait_sql.write(sql_mon)
f_wait_sql.close()

f_wait_log=open( os.path.join(context['temp_directory'],'tmp_wait_4337.log'), 'w')

p_isql = subprocess.Popen( ["isql", dsn, "-i", f_wait_sql.name],
                  stdout = f_wait_log,
                  stderr = subprocess.STDOUT
                )


# Launch GFIX -SWEEP (sync.). It should be killed by ISQL which we have launched previously
# after delay in its script will expire:
########################################

f_gfix_log=open( os.path.join(context['temp_directory'],'tmp_gfix_4337.log'), 'w')
f_gfix_log.write('Point before GFIX -SWEEP.'+os.linesep)
f_gfix_log.seek(0,2)
subprocess.call( ["gfix", dsn, "-sweep"],
                  stdout = f_gfix_log,
                  stderr = subprocess.STDOUT
                )


f_gfix_log.seek(0,2)
f_gfix_log.write('Point after GFIX -SWEEP.')

# Small delay to be sure that ISQL was successfully completed.
##############

time.sleep(2)

p_isql.terminate()
f_wait_log.close()
f_gfix_log.close()


#####################################################
# Getting ID of launched trace session and STOP it:

# Save active trace session info into file for further parsing it and obtain session_id back (for stop):
f_trclst=open( os.path.join(context['temp_directory'],'tmp_trace_4337.lst'), 'w')

subprocess.call(["fbsvcmgr", "localhost:service_mgr",
                 "action_trace_list"],
                 stdout=f_trclst, stderr=subprocess.STDOUT
               )
f_trclst.close()

trcssn=0
with open( f_trclst.name,'r') as f:
    for line in f:
        i=1
        if 'Session ID' in line:
            for word in line.split():
                if i==3:
                    trcssn=word
                i=i+1
            break
f.close()

# Result: `trcssn` is ID of active trace session. Now we have to terminate it:
f_trclst=open(f_trclst.name,'a')
f_trclst.seek(0,2)
subprocess.call(["fbsvcmgr", "localhost:service_mgr",
                 "action_trace_stop",
                 "trc_id",trcssn],
                 stdout=f_trclst, stderr=subprocess.STDOUT
               )
f_trclst.close()

time.sleep(2)

p_trace.terminate()
f_trclog.close()
f_trcerr.close()

# Make DB shutdown and bring online because some internal server process still can be active!
# If we skip this step than runtime error related to dropping test DB can occur!
#########################################

f_db_reset_log=open( os.path.join(context['temp_directory'],'tmp_reset_4337.log'), 'w')

f_db_reset_log.write('Point before DB shutdown.'+os.linesep)
f_db_reset_log.seek(0,2)
subprocess.call( ["fbsvcmgr", "localhost:service_mgr",
                  "action_properties", "prp_shutdown_mode", "prp_sm_full", "prp_shutdown_db", "0",
                  "dbname", db_file,
                 ],
                 stdout = f_db_reset_log,
                 stderr = subprocess.STDOUT
               )
f_db_reset_log.write(os.linesep+'Point after DB shutdown.'+os.linesep)

subprocess.call( ["fbsvcmgr", "localhost:service_mgr",
                  "action_properties", "prp_db_online",
                  "dbname", db_file,
                 ],
                 stdout = f_db_reset_log,
                 stderr = subprocess.STDOUT
               )

f_db_reset_log.write(os.linesep+'Point after DB online.'+os.linesep)
f_db_reset_log.close()


# Get content of firebird.log AFTER test finish.
#############################

f_fblog_after=open( os.path.join(context['temp_directory'],'tmp_4337_fblog_after.txt'), 'w')
svc_get_fb_log( engine, f_fblog_after )
f_fblog_after.close()

# _!_!_!_!_!_!_!_!_!_! do NOT reduce this delay: firebird.log get new messages NOT instantly !_!_!_!_!_!_!_!_
# Currently firebird.log can stay with OLD content if heavy concurrent workload exists on the same host!
time.sleep(5)

# Compare firebird.log versions BEFORE and AFTER this test:
######################

oldfb=open(f_fblog_before.name, 'r')
newfb=open(f_fblog_after.name, 'r')

difftext = ''.join(difflib.unified_diff(
    oldfb.readlines(), 
    newfb.readlines()
  ))
oldfb.close()
newfb.close()

f_diff_txt=open( os.path.join(context['temp_directory'],'tmp_4337_diff.txt'), 'w')
f_diff_txt.write(difftext)
f_diff_txt.close()

# Check logs:
#############

# 1. Log of GFIX -SWEEP should contain:
'''
   Point before GFIX -SWEEP.
   connection shutdown
   Point after GFIX -SWEEP.
'''
with open( f_gfix_log.name,'r') as f:
    for line in f:
        if line.strip():
            print( line.upper() )
f.close()


# 2. Log of ISQL that was launched to kill 'GFIX -SWEEP' attachment should contain:
'''
MSG                             Waiting for GFIX start SWEEP
MSG                             Starting to delete GFIX process from mon$attachments
Records affected: 1
MSG                             Finished deleting GFIX process from mon$attachments
'''
with open( f_wait_log.name,'r') as f:
    for line in f:
        if line.strip():
            print( 'ISQL LOG: ' + line.upper() )
f.close()


# 3. Log of TRACE should contain 'SWEEP_FAILED' only 'DETACH_DATABASE' event after this line:
'''
    2016-10-26T21:49:06.4040 (2184:00D33200) SWEEP_FAILED
    	C:\MIX\FIREBIRD\QA\FBT-REPO\TMP\BUGS.CORE_4337.FDB (ATT_16, SYSDBA:NONE, NONE, TCPv4:127.0.0.1/1406)
    	C:\MIX\Firebird\fb40\gfix.exe:4700
       2061 ms, 17273 read(s), 781 write(s), 538838 fetch(es), 146541 mark(s)

    2016-10-26T21:49:06.4040 (2184:00D33200) ERROR AT JProvider::attachDatabase
    	C:\MIX\FIREBIRD\QA\FBT-REPO\TMP\BUGS.CORE_4337.FDB (ATT_16, SYSDBA:NONE, NONE, TCPv4:127.0.0.1/1406)
    	C:\MIX\Firebird\fb40\gfix.exe:4700
    335544856 : connection shutdown

    2016-10-26T21:49:06.4040 (2184:00D33200) DETACH_DATABASE
    	C:\MIX\FIREBIRD\QA\FBT-REPO\TMP\BUGS.CORE_4337.FDB (ATT_16, SYSDBA:NONE, NONE, TCPv4:127.0.0.1/1406)
    	C:\MIX\Firebird\fb40\gfix.exe:4700
'''

found_sweep_failed=0
with open( f_trclog.name,'r') as f:
    for line in f:
        if 'SWEEP_FAILED' in line:
            print( 'TRACE_LOG:' + (' '.join(line.split()).upper()) )
            found_sweep_failed = 1

        if found_sweep_failed == 1 and ('ATTACH_DATABASE' in line):
            print( 'TRACE: ATTACH DETECTED AFTER SWEEP FAILED! ' )
            print( 'TRACE_LOG:' + (' '.join(line.split()).upper()) )

f.close()
# Output should contain only ONE message with 'SWEEP_FAILED', and NO any rows related to ATTACH_DATABASE.


# 4. Difference between old and current firebird.log should be like this:
'''
    +
    +CSPROG	Wed Oct 26 21:49:04 2016
    +	Sweep is started by SYSDBA
    +	Database "C:\MIX\FIREBIRD\QA\FBT-REPO\TMP\BUGS.CORE_4337.FDB" 
    +	OIT 21, OAT 22, OST 19, Next 25
    +
    +
    +CSPROG	Wed Oct 26 21:49:06 2016
    +	Error during sweep:
    +	connection shutdown
'''

# 5. Log of fbsvcmgr when it did shutdown DB and bring it back online should be EMPTY.
# NB: difflib.unified_diff() can show line(s) that present in both files, without marking that line(s) with "+". 
# Usually these are 1-2 lines that placed just BEFORE difference starts.
# So we have to check output before display diff content: lines that are really differ must start with "+".

pattern  = re.compile("\+[\s]+OIT[ ]+[0-9]+,[\s]*OAT[\s]+[0-9]+,[\s]*OST[\s]+[0-9]+,[\s]*NEXT[\s]+[0-9]+")
# OIT 160, OAT 159, OST 159, Next 161

with open( f_diff_txt.name,'r') as f:
    for line in f:
        if line.startswith('+'):
            if  'sweep'.upper() in line.upper() or 'connection'.upper() in line.upper() or pattern.match(line.upper()):
                print( 'FIREBIRD.LOG: ' + (' '.join(line.split()).upper()) )
f.close()


time.sleep(1)

# Cleanup.
###############################

f_list=[f_work_sql,f_work_log,f_fblog_before,f_trccfg,f_trclog,f_trcerr,f_wait_sql,f_wait_log,f_gfix_log,f_trclst,f_db_reset_log,f_fblog_after,f_diff_txt]

for i in range(len(f_list)):
    if os.path.isfile(f_list[i].name):
        os.remove(f_list[i].name)

  """,
 'expected_stdout':
  """
    POINT BEFORE GFIX -SWEEP.
    CONNECTION SHUTDOWN
    POINT AFTER GFIX -SWEEP.
    ISQL LOG:                                 WAITING FOR GFIX START SWEEP
    ISQL LOG:                                 STARTING TO DELETE GFIX PROCESS FROM MON$ATTACHMENTS
    ISQL LOG: RECORDS AFFECTED: 1
    ISQL LOG:                                 FINISHED DELETING GFIX PROCESS FROM MON$ATTACHMENTS
    TRACE_LOG: SWEEP_FAILED
    FIREBIRD.LOG: + SWEEP IS STARTED BY SYSDBA
    FIREBIRD.LOG: + OIT, OAT, OST, NEXT
    FIREBIRD.LOG: + ERROR DURING SWEEP:
    FIREBIRD.LOG: + CONNECTION SHUTDOWN
  """,
  'substitutions':[
     ('TRACE_LOG:.* SWEEP_START','TRACE_LOG: SWEEP_START'),
     ('TRACE_LOG:.* SWEEP_FAILED','TRACE_LOG: SWEEP_FAILED'),
     ('TRACE_LOG:.* ERROR AT JPROVIDER::ATTACHDATABASE','TRACE_LOG: ERROR AT JPROVIDER::ATTACHDATABASE'),
     ('TRACE_LOG:.*GFIX.EXE.*','TRACE_LOG: GFIX.EXE'),
     ('OIT [0-9]+','OIT'),
     ('OAT [0-9]+','OAT'),
     ('OST [0-9]+','OST'),
     ('NEXT [0-9]+','NEXT')
   ]

}                                                                                                      
]
}
